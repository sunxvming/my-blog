### 第一部分：简介


#### 第1章、温故而知新


主要介绍一些操作系统的基本知识，简述了设备驱动、操作系统、虚拟空间、物理空间、页映射、线程等基本概念。


---


### 第二部分：静态链接


#### 第2章、编译和链接


使用gcc编译程序生成目标文件中，经历了四个过程：预处理、编译、汇编、链接


预编译：处理源代码文件中以“#”开头的与编译指令（生成 .i 文件）


编译：对预处理后的文件进行词法分析、语法分析、语义分析及优化，产生相应的汇编代码文件（生成 .s 文件）


（gcc把预编译和编译合成一个步骤，使用cc1程序完成，改程序位于 /usr/lib/gcc/x86_64-linux-gnu/4.7/ 中）


汇编：将汇编代码转成机器可执行的指令，每一个汇编语句几乎对应着一条机器指令（使用汇编器 as 完成，生成 .o 目标文件）


链接：链接需要用到的其他文件，生成最终可执行文件（使用ld程序，生成 .out 文件）（其过程包括地址和空间分配、符号决议、重定位）


---


#### 第3章、目标文件里有什么


可执行文件格式：PE（windows下的Portable Executable）、ELF（linux下的 Executable Linkable Format），都是COFF（Common file firmat）格式的变种


动态链接库（DLL，Dynamic Linking Library，windows下的.dll和linux下的.so）和静态链接文库（Static Linking Library，windows下的的.lib和linux下的.a）文件已可执行文件格式存储。


linux下可用 file 指令查看文件格式


ELF文件结构：代码段、数据段、BSS段、文件头、段表、重定位表、字符串表、符号表、调试表


---


#### 第4章、静态链接


空间与地址分配、符号解析和重定位


---


#### 第5章、Windows PE/COFF


因为基于Linux开发，windows相关的暂时跳过


---


### 第三部分：装载与动态链接


#### 第6章、可执行文件的装载与进程


操作系统装载程序到内存：覆盖装入和页映射


---


#### 第7章、动态链接


静态链接会浪费内存和磁盘空间、模块更新困难


静态链接是链接时重定位，动态链接是装载时重定位


地址无关代码（PIC）：解决共享对象指令中对绝对地址的重定位问题


延迟绑定（PLT）：当函数第一次被调用时才进行绑定


ldd：查看程序依赖库


readelf：查看ELF结构相关信息


objdump：打印对象信息


---


#### 第8章、Linux共享库的组织


共享库版本命名：libname.so.x.y.z（主版本号x（重大升级，不兼容其他版本），次版本号y（增量升级），发布版本号z（修正、改进））


SO-NAME：只保留主版本号的共享库名


链接名：即libname.so.x.y.z中的name


LD_LIBRARY_PATH：改变某程序的共享库查找路径


LD_PRELOAD：指定预先装载的一些共享库或目标文件


LD_DEBUG：打开动态链接器的调试功能


---


#### 第9章、Windows下的动态链接


跳过


---


### 第四部分：库与运行库


#### 第10章、内存


调用惯例：约定的函数调用方式


---


#### 第11章、运行库


程序运行步骤：操作系统创建进程，把控制权交给程序入口（一般是运行库中某个入口函数）；入口函数对运行库和运行环境进行初始化，包括堆、I/O、线程、全局变量构造等；入口函数完成初始化后，调用main函数，执行程序主体部分；main函数执行完毕后，返回入口函数，进行清理工作，包括全局变量析构、堆销毁、关闭I/O等，然后进行系统调用结束进程


线程私有存储空间：栈、线程局部存储、寄存器


CRT（C语言运行库）：启动与退出、标准函数、I/O、堆、语言实现、调试


---


#### 第12章、系统调用与API


系统调用：应用程序与操作系统内核之间的接口


---


#### 第13章、运行库与实现


主要讲 Mini CRT的实现