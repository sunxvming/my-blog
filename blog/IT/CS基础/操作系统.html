<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta name="generator" content="pandoc" />




<link rel="stylesheet" href="../../.././css/style.css" />




<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Saira+Semi+Condensed%3A400%2C700&ver=4.9.18" type="text/css" />

<script src="https://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
<script>
jQuery(document).ready(function(){
    jQuery('pre').each(function(){
        var el = jQuery(this).find('code');
        var code_block = el.html(); 
 
        if (el.length > 0) { 
            jQuery(this).addClass('prettyprint').html(code_block).attr('style', 'max-height:450px');
        } else { 
            jQuery(this).removeClass().addClass('prettyprint'); 
        }
    });
});
</script>

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js?skin=desert"></script>

</head>


<body>
<div id="wrapper">


<style type="text/css">

#masthead .site-branding {
    margin-bottom: 7px;
}

#masthead .site-branding .site-title {
    font-size: 2.2rem;
    line-height: 1;
    text-transform: uppercase;
    margin: 0;
    margin-bottom: 0.5rem;
}


#masthead .site-description{
	margin:0px;
}




#masthead .site-branding .site-title a {
    display: inline-block;
    position: relative;
    top: -11px;
}

#masthead  a {
    <!-- color: #007bff; -->
    text-decoration: none;
    background-color: transparent;
}



.io-menu-desktop {
    display: block;
    text-align: right;
}
.io-menu-desktop span.io-menu-button-span {
    display: none;
}
.io-menu-desktop ul {
    padding: 0;
    margin: 0;
    list-style: none;
    background: transparent;
    display: block;
}
.io-menu-desktop ul > li {
    margin-right: -4px;
    display: inline-block;
    position: relative;
    height: 30px;
    color: #212529;
    font-size: 12px;
    text-transform: uppercase;
    text-shadow: 0 0 0 rgb(0 0 0 / 0%);
    font-weight: 400;
}
.io-menu-desktop ul > li > a {
    padding: 0;
    line-height: 29px;
    padding-left: 20px;
    padding-right: 20px;
    padding-top: 1px;
    color: #212529;
    font-size: 12px;
    text-transform: uppercase;
    text-shadow: 0 0 0 rgb(0 0 0 / 0%);
    font-weight: 400;
}
.io-menu-desktop a {
    display: block;
    -o-transition: none;
    -moz-transition: none;
    -webkit-transition: none;
    transition: none;
}
.io-menu-desktop > ul > li.current-menu-item > a, .io-menu-desktop > div > ul > li.current-menu-item > a {
    background: rgba(0, 0, 0, 0.01);
}



#colophon {
    margin-top: 70px;
    margin-bottom: 30px;
}
#colophon .site-info {
    text-align: center;
}

</style>


<header id="masthead" class="site-header row">
    <div class="site-branding col-sm-6">
        <span class="site-title" style="font-size: 2.2rem">
            <span>
                <img width="60px" height="60px"
                    src="http://www.sunxvming.com/imgs/QQ图片20191023170517.jpg">
            </span>


            <a href="http://www.sunxvming.com/" rel="home">忧郁的大能猫</a>
        </span>
        <p class="site-description">好奇的探索者，理性的思考者，踏实的行动者。</p>
    </div><!-- .site-branding -->

    <nav id="site-navigation" class="main-navigation col-sm-9">
        <div class="io-menu io-menu-desktop"><span class="io-menu-button io-menu-button-span">≡</span>

            <div class="menu-%e4%b8%bb%e8%8f%9c%e5%8d%95-container">
                <ul id="primary-menu" class="menu">
                    <li id="menu-item-38"
                        class="menu-item menu-item-type-custom menu-item-object-custom current-menu-item current_page_item menu-item-home menu-item-38">
                        <a href="http://www.sunxvming.com">首页</a></li>
                    <li id="menu-item-175"
                        class="menu-item menu-item-type-post_type menu-item-object-page menu-item-175"><a
                            href="http://www.sunxvming.com/">所有文章</a></li>
                    <li id="menu-item-176"
                        class="menu-item menu-item-type-post_type menu-item-object-page menu-item-176"><a
                            href="http://www.sunxvming.com/blog/about-me.html">关于俺</a></li>
                </ul>
            </div>
        </div><!-- .io-menu -->
    </nav><!-- #site-navigation -->
</header>

<div id="header">
<h1 class="title">blog/IT/CS基础/操作系统</h1>
</div> <!--id="header"-->
 <!--if(title)-->

 <!--if(toc)-->

<p>```<br />
处理器管理<br />
    处理器调度<br />
        作业调度<br />
            把磁盘上用来存放作业信息的专业区域称为<strong>输入井</strong>，把在输入井中等待处理的作业称为<strong>后备作业</strong><br />
            从输入井中选取后备作业装入主存储器的工作称为作业调度<br />
            作业调度算法:<br />
                先来先服务（FCFS）方法<br />
                短作业优先算法（SJF）<br />
                最高响应比优化法    <br />
                优先级调度算法<br />
                均衡调度算法</p>
<p>            周转时间=作业完成时刻—作业到达时刻；<br />
            平均周转时间=作业周转总时间/作业个数；<br />
            带权周转时间=周转时间/服务时间；<br />
            平均带权周转时间=带权周转总时间/作业个数；<br />
                <br />
    进程<br />
        进程控制块<br />
            标识信息：用于标识一个进程包括进程名。<br />
            说明信息：用于说明进程情况，包括进程状态等待原因进程程序和数据存放位置。<br />
            现场信息：用于保留进程存放在cup中的信息，包括通用、控制和程序状态字寄存器的内容。<br />
            管理信息：用于进程调度包括进程优先数队列指针。<br />
        进程调度<br />
            准则：<br />
                1.提高处理器的利用率<br />
                2.增大吞吐量<br />
                3.减少等待时间<br />
                4.缩短响应时间。<br />
            进程调度算法:    <br />
                先来先服务调度算法<br />
                最高优先级调度算法<br />
                时间片轮转调度算法<br />
                多级队列调度算法<br />
                多级反馈队列调度算法<br />
        <br />
        并发进程<br />
            当一个进程独占处理器顺序执行时具有的两个特性：封闭性、可再现性<br />
            并发：间断性 失去封闭性、不可再现性<br />
            临界区<br />
                并发进程中与共享变量有关的程序段称为临界区；<br />
            临界区的三个要求<br />
                1、一次最多一个进程能够进入临界区；<br />
                2、不能让一个进程无限制地在临界区执行；<br />
                3、不能强迫一个进程无限制地等待进入它的临界区</p>
<p>        进程的互斥与同步<br />
            互斥<br />
                有若干个进程都要使用某一共享资源时，任何时刻最多只允许一个进程去使用该资源<br />
            同步<br />
                一个进程的执行依赖另一个进程的消息，当一个进程没有得到另一个进程的消息时应等待，直到消息到达才能被唤醒<br />
            同步机制应遵循的准则<br />
                空闲让进、忙则等待、有限等待、让权等待<br />
            死锁<br />
                条件<br />
                    互斥地使用资源、占有且等待资源、非抢夺式分配、循环等待资源；<br />
                解决死锁的方法通常有<br />
                    死锁的防止，死锁的避免和死锁的检测<br />
                银行家算法（Banker's Algorithm）<br />
                    need = max - allocation<br />
                    <br />
            同步原语    <br />
                PV操作  signal wait<br />
                    1、P操作(测试资源是否可用)：将信号量S减去1，若结果小于0，则把调用P（S）的进程置成等待信号量S的状态； <br />
                    2、V操作：将信号量S加1，若结果不大于0，则释放一个等待信号量S的进程。            <br />
        进程通信<br />
            通信原语<br />
                发送原语：send（N,M），功能：把信件M送到指定的信箱N中。<br />
                接收原语：receive（N,Z），功能：从指定的信箱取一封信，存到指定的地址Z中。<br />
      <br />
    线程<br />
        进程可以提高CPU的利用率，进程之间的切换是非常耗费资源和时间的，为了能更进一步的提高操作系统的并发性，从而引进了线程</p>
<p>    中断(才能有异常控制流)<br />
        由于某些事件的出现，中止现行进程的运行，而转去处理出现的事件，待适当的时候让被中止的进程继续运行<br />
        <br />
        中断处理程序<br />
            对出现的事件进行处理的程序.是操作系统的组成部分<br />
        中断响应    <br />
            通常在cup执行完一条指令后，硬件的中断装置立即检查有无中断事件发生，<br />
            若有则暂停运行进程的运行而让操作系统中的中断处理程序占用cpu.<br />
                判断是否有中断事件发生；<br />
                判别自愿性中断，只要检查操作码是否为访管指令即可；<br />
                判别强迫性中断，则要检查<strong>中断寄存器</strong>的内容。若为0则无中断，若非0则有中断发生，若有中断发生，保护断点信息。</p>
<p>    <br />
存储管理<br />
    分类：<br />
        寄存器、主存储器和高速缓冲存储器、辅助存储器（包括磁带、软盘、硬盘、光盘等）三个层次<br />
    <br />
    主要功能<br />
        主存空间的分配和回收<br />
        主存空间的共享与保护<br />
        地址转换以及主存空间的扩充等工作<br />
        <br />
            存储保护的目的<br />
                保护内存中各区域的信息不被破坏，防止作业执行时相互干扰。为了实现存储保护必须由硬件和软件配合实现<br />
    <br />
    重定位<br />
        绝对地址、逻辑地址<br />
        静态重定位<br />
            在装入一个作业时，把作业中的指令地址和数据地址全部转换成<strong>绝对地址</strong>，在作业执行过程中无需转换<br />
        动态重定位<br />
            在作业执行时由MMU(Memory Management Unit)来动态转换<br />
            动态重定位需要由操作系统和硬件（MMU）相互配合来实现<br />
    <br />
    内存管理方式<br />
        单用户连续存储管理<br />
            1.设置一个界限寄存器（BR），其内容是主存中用户区的首地址，之前的都是操作系统的<br />
            2.绝对地址=逻辑地址+BR的值（界限地址）<br />
            3.采用静态重定位。<br />
            4.执行指令时要检查：界限地址 &lt;= 绝对地址 &lt;= 最大地址。<br />
              若越界，则产生一个“地址越界”中断事件，由操作系统进行处理，以达到存储保护的目的<br />
            算法：<br />
                最佳适应算法<br />
        <br />
        固定分区存储管理<br />
            把内存中可分配的用户区域预先划分成若干个连续分区，一旦划分好后，这些分区的大小和个数就固定不变<br />
            利用一张“主存分配表”说明各分区情况。表中指出各分区的起始地址和长度，和是否空闲的标志位<br />
        可变分区存储管理<br />
            主存空间的分配与回收：<br />
                最先适应分配算法：第一个能满足作业长度要求的空闲区；<br />
                最优适应分配算法：能满足作业要求的最小空闲区；<br />
                最坏适应分配算法：能满足作业要求的最大空闲区；<br />
                回收：回收时同时收回相邻的区域；<br />
            地址转换和存储保护<br />
                一般均采用动态重定位方式装入作业，需要有硬件地址转换机制作支持：基址寄存器、限长寄存器；<br />
                基址寄存器 &lt;= 绝对地址 &lt;= 限长寄存器<br />
            移动技术：<br />
                一是集中分散的空闲区；<br />
                二是便于作业动态扩充主存；    <br />
        <br />
        页式内存管理<br />
            解决如何把大块的内存拆成小块<br />
            逻辑地址由两部分组成页号和页内地址<br />
                绝对地址＝块号 <em> 块长 + 页内地址            <br />
            一单级页表<br />
                逻辑地址：|--页号20位--|--页内偏移量12位|， 处理器会根据前20位来找页表<br />
                存在问题：页表过大需要连续存储    需要2^20</em>4字节<br />
            二级页表<br />
                逻辑地址：|--一级页号10位--|--二级页号10位--|--页内偏移量12位--|            <br />
            <br />
            Linux伙伴系统算法(buddy system)<br />
                把所有的空闲页框分组为11个块链表，每个块链表分别包含大小为1，2，4，8，16，32，64，128，256，512和1024<br />
                个<strong>连续页框</strong>的页框块<br />
            局部性原理<br />
                在一段时间内，程序的执行仅限制在某个部分。相应的，它访问的存储空间也局限在某个局域<br />
                局部性表现在两个方面<br />
                    时间局部性：访问了某个单元之后可能还会在访问<br />
                    空间局部性：访问了某个单元之后，其附近的单元也可能被访问<br />
        页式虚拟存储管理<br />
            解决内存扩展问题，涉及到页的换入和换出<br />
            需要解决的两个问题：<br />
                一是怎样知道主存储器中哪些块已被占用，哪些块是空闲的：主存分配表；采用<strong>位图</strong>实现，每一位代表一块主存<br />
                二是作业信息被分散存放后如何保证作业的正确执行：    <br />
            页面调度算法<br />
                先进先出调度算法<br />
                最近最久未使用调度算法（Last Recently Used，LRU）<br />
                    选择最近最长时间未访问过的页面予以淘汰<br />
        段式内存管理<br />
        <br />
        段页式内存管理<br />
            请求内存地址分三步：<br />
                1.请求段表，获取页表开始地址<br />
                2.请求页表，取出该页对应的物理块号，并根据页内地址算出物理地址<br />
                3.根据物理地址访问具体的内存地址，取出数据</p>
<p>            <br />
文件管理<br />
    文件的组织<br />
        文件的逻辑结构：逻辑文件：一是流式文件；二是记录式文件；<br />
        文件的存储结构：物理文件：存放在存储介质上的文件称为物理文件；<br />
            文件存储结构<br />
                顺序文件、链接文件、索引文件<br />
                存取方式：<br />
                    顺序存取<br />
                        磁带<br />
                    随机存取<br />
                        硬盘<br />
    类型：普通文件、目录文件、字符设备文件、块设备文件</p>
<p>设备管理<br />
    外围设备的分类<br />
        独占设备<br />
            把在作业执行期间只允许一个作业独占使用的设备称为独占设备<br />
        可共享设备<br />
            一时刻仍只有一个作业能启动设备，允许他们交替地启动<br />
            <br />
    功能<br />
        异步传输<br />
        缓冲管理<br />
        设备的分配和释放<br />
        实现IO设备的独立性和错误处理<br />
        实现IO控制方式<br />
            <br />
    缓冲技术<br />
        操作系统把利用缓冲区来缓解处理器与外围设备之间工作速度不匹配的矛盾而采用的技术称为缓冲技术        <br />
            <br />
    I/O控制方式        <br />
        程序查询方式(也称程序轮询方式)<br />
            用用户程序直接控制主机与外部设备之间输入/输出操作<br />
            CPU必须不停地循环测试I/O设备的状态端口，当发现设备处于准备好(Ready)状态时，CPU就可以与I/O设备进行数据存取操作<br />
        中断方式<br />
            当I/O设备结束(完成、特殊或异常)时，就会向CPU发出中断请求信号，CPU收到信号就可以采取相应措施。<br />
            当某个进程要启动某个设备时，CPU就向相应的设备控制器发出一条设备I/O启动指令，然后CPU又返回做原来的工作。<br />
        DMA方式(Direct Memory Access,直接存储器访问)<br />
            允许主存储器和I/O设备之间通过“DMA控制器(DMAC)”直接进行批量数据交换，除了在数据传输开始和结束时，<br />
            整个过程无须CPU的干预。<br />
        I/O通道控制方式<br />
            通道(Channel)也称为外围设备处理器、输入输出处理机，是相对于CPU而言的。是一个处理器。<br />
            也能执行指令和由指令的程序，只不过通道执行的指令是与外部设备相关的指令。<br />
            是一种实现主存与I/O设备进行直接数据交换的控制方式。<br />
    用户请求IO，IO中断处理的过程<br />
        1.用户请求IO，由于等待I/O操作的完成而被阻塞<br />
        2.cpu转去执行其他任务<br />
        3.当I/O任务完成，控制器向cpu发中断请求信号<br />
        4.cpu转去执行中断处理程序，由中断处理程序唤醒被阻塞的用户进程<br />
            <br />
    磁盘调度<br />
        先来先服务<br />
        最短寻找时间优先（ShortestSeekTimeFirst）<br />
            这种算法会产生“饥饿”现象。<br />
        循环扫描算法（CSCAN）<br />
            从里往外扫，扫到最外，然后再返回到最里<br />
            <br />
            <br />
实时系统<br />
    进程调度<br />
        周期性实时任务可调度的限制条件<br />
            sum(Ci/Pi) &lt;= 1 (1 &lt;= i &lt;= m)   Ci为处理时间  Pi为周期时间<br />
            <br />
```   <br />
            <br />
            <br />
            <br />
            <br />
            <br />
            <br />
            </p>

<footer id="colophon" >
		<div class="site-info col">
			Powered by <a href="https://github.com/sunxvming/my-blog">my-blog</a>
			<span class="sep"> | </span>
				<span><a target="_blank" href="http://beian.miit.gov.cn">【京ICP备19018538号】</a></span>
			<span><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11010502037753">【京公网安备 11010502037753号】</a></span>
		</div><!-- .site-info col -->
        <div class="site-info col"> This page is hosted at <a target="_blank" href="https://github.com/sunxvming">Github</a>.To see the source code you can visit the <a target="_blank" href="https://github.com/sunxvming/my-blog">repo</a> and I'd be glad if you like and star it.</div>
</footer>
</div> <!--wrapper-->
</body>
</html>
