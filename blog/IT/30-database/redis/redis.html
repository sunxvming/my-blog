<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta name="generator" content="pandoc" />




<link rel="stylesheet" href="../../../.././css/style.css" />




<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Saira+Semi+Condensed%3A400%2C700&ver=4.9.18" type="text/css" />

<script src="https://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
<script>
jQuery(document).ready(function(){
    jQuery('pre').each(function(){
        var el = jQuery(this).find('code');
        var code_block = el.html(); 
 
        if (el.length > 0) { 
            jQuery(this).addClass('prettyprint').html(code_block).attr('style', 'max-height:450px');
        } else { 
            jQuery(this).removeClass().addClass('prettyprint'); 
        }
    });
});
</script>

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js?skin=desert"></script>

</head>


<body>
<div id="wrapper">


<style type="text/css">

#masthead .site-branding {
    margin-bottom: 7px;
}

#masthead .site-branding .site-title {
    font-size: 2.2rem;
    line-height: 1;
    text-transform: uppercase;
    margin: 0;
    margin-bottom: 0.5rem;
}


#masthead .site-description{
	margin:0px;
}




#masthead .site-branding .site-title a {
    display: inline-block;
    position: relative;
    top: -11px;
}

#masthead  a {
    <!-- color: #007bff; -->
    text-decoration: none;
    background-color: transparent;
}



.io-menu-desktop {
    display: block;
    text-align: right;
}
.io-menu-desktop span.io-menu-button-span {
    display: none;
}
.io-menu-desktop ul {
    padding: 0;
    margin: 0;
    list-style: none;
    background: transparent;
    display: block;
}
.io-menu-desktop ul > li {
    margin-right: -4px;
    display: inline-block;
    position: relative;
    height: 30px;
    color: #212529;
    font-size: 12px;
    text-transform: uppercase;
    text-shadow: 0 0 0 rgb(0 0 0 / 0%);
    font-weight: 400;
}
.io-menu-desktop ul > li > a {
    padding: 0;
    line-height: 29px;
    padding-left: 20px;
    padding-right: 20px;
    padding-top: 1px;
    color: #212529;
    font-size: 12px;
    text-transform: uppercase;
    text-shadow: 0 0 0 rgb(0 0 0 / 0%);
    font-weight: 400;
}
.io-menu-desktop a {
    display: block;
    -o-transition: none;
    -moz-transition: none;
    -webkit-transition: none;
    transition: none;
}
.io-menu-desktop > ul > li.current-menu-item > a, .io-menu-desktop > div > ul > li.current-menu-item > a {
    background: rgba(0, 0, 0, 0.01);
}



#colophon {
    margin-top: 70px;
    margin-bottom: 30px;
}
#colophon .site-info {
    text-align: center;
}

</style>


<header id="masthead" class="site-header row">
    <div class="site-branding col-sm-6">
        <span class="site-title" style="font-size: 2.2rem">
            <span>
                <img width="60px" height="60px"
                    src="http://www.sunxvming.com/imgs/QQ图片20191023170517.jpg">
            </span>


            <a href="http://www.sunxvming.com/" rel="home">忧郁的大能猫</a>
        </span>
        <p class="site-description">好奇的探索者，理性的思考者，踏实的行动者。</p>
    </div><!-- .site-branding -->

    <nav id="site-navigation" class="main-navigation col-sm-9">
        <div class="io-menu io-menu-desktop"><span class="io-menu-button io-menu-button-span">≡</span>

            <div class="menu-%e4%b8%bb%e8%8f%9c%e5%8d%95-container">
                <ul id="primary-menu" class="menu">
                    <li id="menu-item-38"
                        class="menu-item menu-item-type-custom menu-item-object-custom current-menu-item current_page_item menu-item-home menu-item-38">
                        <a href="http://www.sunxvming.com">首页</a></li>
                    <li id="menu-item-175"
                        class="menu-item menu-item-type-post_type menu-item-object-page menu-item-175"><a
                            href="http://www.sunxvming.com/">所有文章</a></li>
                    <li id="menu-item-176"
                        class="menu-item menu-item-type-post_type menu-item-object-page menu-item-176"><a
                            href="http://www.sunxvming.com/blog/about-me.html">关于俺</a></li>
                </ul>
            </div>
        </div><!-- .io-menu -->
    </nav><!-- #site-navigation -->
</header>

<div id="header">
<h1 class="title">blog/IT/30-database/redis/redis</h1>
</div> <!--id="header"-->
 <!--if(title)-->

<p>Table of Contents:</p>
<div id="TOC">
<ul>
<li><a href="#使用时遇到的错误">使用时遇到的错误</a></li>
<li><a href="#redis简介">redis简介</a></li>
<li><a href="#redis下载安装">Redis下载安装</a>
<ul>
<li><a href="#官网下载最新版或者最新stable版">1. 官网下载最新版或者最新stable版</a></li>
<li><a href="#解压源码并进入目录">2. 解压源码并进入目录</a></li>
<li><a href="#不用configure直接make">3. 不用configure，直接make</a></li>
<li><a href="#可选步骤-make-test测试编译情况">4. 可选步骤: make test测试编译情况</a></li>
<li><a href="#安装到指定的目录比如-usrlocalredis">5. 安装到指定的目录,比如 /usr/local/redis</a></li>
<li><a href="#make-install之后得到如下几个文件">6. make install之后,得到如下几个文件:</a></li>
<li><a href="#复制配置文件">7. 复制配置文件</a></li>
<li><a href="#启动与连接">8. 启动与连接</a></li>
<li><a href="#连接-用redis-cli">9. 连接: 用redis-cli</a></li>
<li><a href="#让redis以后台进程的形式运行">10. 让redis以后台进程的形式运行</a></li>
</ul></li>
<li><a href="#redis对于key的操作命令">Redis对于key的操作命令</a>
<ul>
<li><a href="#keys-pattern-查询key">keys pattern, 查询key</a></li>
<li><a href="#del-key1-key2-...-keyn">del key1 key2 ... Keyn</a></li>
<li><a href="#rename-key-newkey">rename key newkey</a></li>
<li><a href="#renamenx-key-newkey">renamenx key newkey</a></li>
<li><a href="#move-key-db">move key db</a></li>
<li><a href="#其他">其他</a></li>
</ul></li>
<li><a href="#redis字符串类型的操作">Redis字符串类型的操作</a>
<ul>
<li><a href="#xx">set key value [ex 秒数] / [px 毫秒数] [nx] /</a></li>
<li><a href="#mset-multi-set-一次性设置多个键值">mset multi set , 一次性设置多个键值</a></li>
<li><a href="#get-key">get key</a></li>
<li><a href="#mget-key1-key2-..keyn">mget key1 key2 ..keyn</a></li>
<li><a href="#setrange-key-offset-value">setrange key offset value</a></li>
<li><a href="#append-key-value">append key value</a></li>
<li><a href="#getrange-key-start-stop">getrange key start stop</a></li>
<li><a href="#getset-key-newvalue">getset key newvalue</a></li>
<li><a href="#incr-key">incr key</a></li>
<li><a href="#incrby-key-number">incrby key number</a></li>
<li><a href="#incrbyfloat-key-floatnumber">incrbyfloat key floatnumber</a></li>
<li><a href="#decr-key">decr key</a></li>
<li><a href="#decrby-key-number">decrby key number</a></li>
<li><a href="#getbit-key-offset">getbit key offset</a></li>
<li><a href="#setbit-key-offset-value">setbit key offset value</a></li>
<li><a href="#setbit-的实际应用">Setbit 的实际应用</a></li>
<li><a href="#key2...">bitop operation destkey key1</a></li>
</ul></li>
<li><a href="#link-链表结构">link 链表结构</a>
<ul>
<li><a href="#lpush-key-value">lpush key value</a></li>
<li><a href="#lindex-key-index">lindex key index</a></li>
<li><a href="#llen-key">llen key</a></li>
<li><a href="#lrange-key-start-stop">lrange key start stop</a></li>
<li><a href="#rpop-key">rpop key</a></li>
<li><a href="#rpushlpop">rpush,lpop</a></li>
<li><a href="#lrem-key-count-value">lrem key count value</a></li>
<li><a href="#ltrim-key-start-stop">ltrim key start stop</a></li>
<li><a href="#linsert-key-afterbefore-search-value">linsert key after|before search value</a></li>
<li><a href="#rpoplpush-source-dest">rpoplpush source dest</a></li>
</ul></li>
<li><a href="#集合-set-相关命令">集合 set 相关命令</a>
<ul>
<li><a href="#sadd-key-value1-value2">sadd key value1 value2</a></li>
<li><a href="#smembers-key">smembers key</a></li>
<li><a href="#scard-key">scard key</a></li>
<li><a href="#srem-key-value1-value2">srem key value1 value2</a></li>
<li><a href="#spop-key">spop key</a></li>
<li><a href="#srandmember-key">srandmember key</a></li>
<li><a href="#sismember-key-value">sismember key value</a></li>
<li><a href="#smove-source-dest-value">smove source dest value</a></li>
<li><a href="#sinter-key1-key2-key3">sinter key1 key2 key3</a></li>
<li><a href="#sinterstore-dest-key1-key2-key3">sinterstore dest key1 key2 key3</a></li>
<li><a href="#suion-key1-key2..-keyn">suion key1 key2.. Keyn</a></li>
<li><a href="#sdiff-key1-key2-key3">sdiff key1 key2 key3</a></li>
</ul></li>
<li><a href="#order-set有序集合">order set(有序集合)</a>
<ul>
<li><a href="#zadd-key-score1-value1-score2-value2-..">zadd key score1 value1 score2 value2 ..</a></li>
<li><a href="#withscores">zrange key start stop</a></li>
<li><a href="#zrem-key-value1-value2-..">zrem key value1 value2 ..</a></li>
<li><a href="#zremrangebyscore-key-min-max">zremrangebyscore key min max</a></li>
<li><a href="#zremrangebyrank-key-start-end">zremrangebyrank key start end</a></li>
<li><a href="#zrank-key-member">zrank key member</a></li>
<li><a href="#zrevrank-key-memeber">zrevrank key memeber</a></li>
<li><a href="#zrevrange-key-start-stop-当然按score排序了">zrevrange key start stop 当然按score排序了</a></li>
<li><a href="#zrangebyscore-key-min-max-withscores-limit-offset-n-当然按score排序">zrangebyscore key min max <span>withscores</span> limit offset N 当然按score排序</a></li>
<li><a href="#zcard-key">zcard key</a></li>
<li><a href="#zcount-key-min-max">zcount key min max</a></li>
<li><a href="#aggregatesum|min|max">zinterstore destination numkeys key1 [key2 ...] [WEIGHTS weight [weight ...]]</a></li>
</ul></li>
<li><a href="#hash-哈希数据类型相关命令">Hash 哈希数据类型相关命令</a>
<ul>
<li><a href="#hset-key-field-value">hset key field value</a></li>
<li><a href="#field2value2field3value3......fieldnvaluen">hmset key field1 value1</a></li>
<li><a href="#hget-key-field">hget key field</a></li>
<li><a href="#hmget-key-field1-field2-fieldn">hmget key field1 field2 fieldN</a></li>
<li><a href="#hgetall-key">hgetall key</a></li>
<li><a href="#hdel-key-field">hdel key field</a></li>
<li><a href="#hlen-key">hlen key</a></li>
<li><a href="#hexists-key-field">hexists key field</a></li>
<li><a href="#hinrby-key-field-value">hinrby key field value</a></li>
<li><a href="#hinrby-float-key-field-value">hinrby float key field value</a></li>
<li><a href="#hkeys-key">hkeys key</a></li>
<li><a href="#kvals-key">kvals key</a></li>
</ul></li>
<li><a href="#redis-中的事务">Redis 中的事务</a></li>
<li><a href="#消息订阅">消息订阅</a></li>
<li><a href="#redis-数据备份与恢复">Redis 数据备份与恢复</a></li>
<li><a href="#redis持久化配置">Redis持久化配置</a></li>
<li><a href="#redis-服务器端命令">redis 服务器端命令</a></li>
<li><a href="#redis-key-设计技巧">Redis key 设计技巧</a></li>
<li><a href="#php-redis扩展编译">php-redis扩展编译</a></li>
<li><a href="#安全问题">安全问题</a>
<ul>
<li><a href="#redis设置访问权限">redis设置访问权限</a></li>
</ul></li>
</ul>
</div>
 <!--if(toc)-->

<h2 id="使用时遇到的错误">使用时遇到的错误</h2>
<p>用redis-cli进行数据操作报错(error) MOVED 的解决方法<br />
报错原因：<br />
没有用集群模式连接（连接节点命令 没有加 -c 参数）<br />
解决办法：<br />
用 -c 参数连接redis集群节点：redis-cli -c -h 172.17.0.1 -p 6391</p>
<h2 id="redis简介">redis简介</h2>
<p>redis是开源,BSD许可,高级的key-value存储系统.</p>
<p>可以用来存储字符串,哈希结构,链表,集合,因此,常用来提供数据结构服务.</p>
<p>redis和memcached相比,的独特之处:</p>
<ol>
<li><p>redis可以用来做存储(storge),<br />
而memccached是用来做缓存(cache)这个特点主要因为其有”持久化”的功能.</p></li>
<li><p>存储的数据有”结构”,对于memcached来说,存储的数据,只有1种类型--”字符串”,<br />
而redis则可以存储字符串,链表,哈希结构,集合,有序集合.</p></li>
</ol>
<h2 id="redis下载安装">Redis下载安装</h2>
<h3 id="官网下载最新版或者最新stable版">1. 官网下载最新版或者最新stable版</h3>
<h3 id="解压源码并进入目录">2. 解压源码并进入目录</h3>
<h3 id="不用configure直接make">3. 不用configure，直接make</h3>
<p>注:易碰到的问题,时间错误.<br />
原因: 源码是官方configure过的,但官方configure时,生成的文件有时间戳信息,<br />
Make只能发生在configure之后,<br />
如果你的虚拟机的时间不对,比如说是2012年<br />
解决: date -s ‘yyyy-mm-dd hh:mm:ss’ 重写时间<br />
再 clock -w 写入cmos</p>
<h3 id="可选步骤-make-test测试编译情况">4. 可选步骤: make test测试编译情况</h3>
<p>若出要安装ctl的错$sudo yum install tcl</p>
<h3 id="安装到指定的目录比如-usrlocalredis">5. 安装到指定的目录,比如 /usr/local/redis</h3>
<pre><code>make  PREFIX=/usr/local/redis install</code></pre>
<p>注: PREFIX要大写</p>
<h3 id="make-install之后得到如下几个文件">6. make install之后,得到如下几个文件:</h3>
<ul>
<li>redis-benchmark 性能测试工具</li>
<li>redis-check-aof 日志文件检测工(比如断电造成日志损坏,可以检测并修复)</li>
<li>redis-check-dump 快照文件检测工具,效果类上，检查rbd日志工具</li>
<li>redis-cli 客户端</li>
<li>redis-server 服务端</li>
</ul>
<h3 id="复制配置文件">7. 复制配置文件</h3>
<pre><code>cp /path/redis.conf /usr/local/redis</code></pre>
<h3 id="启动与连接">8. 启动与连接</h3>
<pre><code>/path/to/redis/bin/redis-server  ./path/to/conf-file</code></pre>
<h3 id="连接-用redis-cli">9. 连接: 用redis-cli</h3>
<pre><code>/path/to/redis/bin/redis-cli [-h localhost -p 6379 ]</code></pre>
<h3 id="让redis以后台进程的形式运行">10. 让redis以后台进程的形式运行</h3>
<p>编辑conf配置文件,修改如下内容;</p>
<pre><code>daemonize yes</code></pre>
<h2 id="redis对于key的操作命令">Redis对于key的操作命令</h2>
<h3 id="keys-pattern-查询key">keys pattern, 查询key</h3>
<p>在redis里,允许模糊查询key</p>
<p>有3个通配符 <code>*, ? ,[  ]</code></p>
<pre><code>*: 通配任意多个字符
?: 通配单个字符
[ ]: 通配括号内的某1个字符</code></pre>
<pre><code>keys *            查询所有
keys k*           查询以k开头的key
keys on[eaw]     
keys on?</code></pre>
<h3 id="del-key1-key2-...-keyn">del key1 key2 ... Keyn</h3>
<p>作用: 删除1个或多个键<br />
返回值: 不存在的key忽略掉,返回真正删除的key的数量</p>
<h3 id="rename-key-newkey">rename key newkey</h3>
<p>作用: 给key赋一个新的key名<br />
注:如果newkey已存在,则newkey的原值被覆盖</p>
<h3 id="renamenx-key-newkey">renamenx key newkey</h3>
<p>作用: 把key改名为newkey<br />
返回: 发生修改返回1,未发生修改返回0</p>
<p>注: nx--&gt; not exists, 即, newkey不存在时,作改名动作</p>
<h3 id="move-key-db">move key db</h3>
<pre><code># 数据库的概念
redis 127.0.0.1:6379[1]&gt; select 2    # 选库，默认是0库
OK

redis 127.0.0.1:6379[2]&gt; keys *
(empty list or set)

redis 127.0.0.1:6379[2]&gt; select 0
OK

redis 127.0.0.1:6379&gt; keys *
1) &quot;name&quot;
2) &quot;cc&quot;
3) &quot;a&quot;
4) &quot;b&quot;

redis 127.0.0.1:6379&gt; move cc 2  # 将cc移动到2库
(integer) 1

(注意: 一个redis进程,打开了不止一个数据库, 默认打开16个数据库,从0到15编号,如果想打开更多数据库,可以从配置文件修改)</code></pre>
<h3 id="其他">其他</h3>
<ul>
<li><p>randomkey 返回随机key</p></li>
<li><p>exists key<br />
判断key是否存在,返回1/0</p></li>
<li><p>type key<br />
返回key存储的值的类型<br />
有string,link,set,order set, hash</p></li>
<li><p>ttl key<br />
作用: 查询key的生命周期<br />
返回: 秒数<br />
注:对于不存在的key或已过期的key/不过期的key,都返回-1</p></li>
<li><p>expire key 整型值<br />
作用: 设置key的生命周期,以秒为单位</p></li>
<li><p>pexpire key 毫秒数, 设置生命周期</p></li>
<li><p>pttl key, 以毫秒返回生命周期</p></li>
<li><p>persist key<br />
作用: 把指定key置为永久有效</p></li>
<li><p>Flushdb 清空key</p></li>
</ul>
<h2 id="redis字符串类型的操作">Redis字符串类型的操作</h2>
<h3 id="xx">set key value [ex 秒数] / [px 毫秒数] [nx] /</h3>
<p>如: set a 1 ex 10 , 10秒有效<br />
Set a 1 px 9000 , 9毫秒数<br />
注: 如果ex,px同时写,以后面的有效期为准<br />
如 set a 1 ex 100 px 9000, 实际有效期是9000毫秒<br />
nx: 表示key不存在时,执行操作<br />
xx: 表示key存在时,执行操作</p>
<h3 id="mset-multi-set-一次性设置多个键值">mset multi set , 一次性设置多个键值</h3>
<p>例: mset key1 v1 key2 v2 ....</p>
<h3 id="get-key">get key</h3>
<p>作用:获取key的值</p>
<h3 id="mget-key1-key2-..keyn">mget key1 key2 ..keyn</h3>
<p>作用:获取多个key的值</p>
<h3 id="setrange-key-offset-value">setrange key offset value</h3>
<p>作用:把字符串的offset偏移字节,改成value<br />
注意: 如果偏移量&gt;字符长度, 该字符自动补0x00</p>
<h3 id="append-key-value">append key value</h3>
<p>作用: 把value追加到key的原值上</p>
<h3 id="getrange-key-start-stop">getrange key start stop</h3>
<p>作用: 是获取字符串中 [start, stop]范围的值<br />
0. 对于字符串的下标,左数从0开始,右数从-1开始<br />
1. start&gt;=length, 则返回空字符串<br />
2. stop&gt;=length,则截取至字符结尾<br />
3. 如果start 所处位置在stop右边, 返回空字符串</p>
<h3 id="getset-key-newvalue">getset key newvalue</h3>
<p>作用: 获取并返回旧值,设置新值</p>
<h3 id="incr-key">incr key</h3>
<p>作用: 指定的key的值加1,并返回加1后的值<br />
注意:<br />
1: 不存在的key当成0,再incr操作<br />
2: 范围为64有符号</p>
<h3 id="incrby-key-number">incrby key number</h3>
<p>把key增加number</p>
<h3 id="incrbyfloat-key-floatnumber">incrbyfloat key floatnumber</h3>
<p>把key增加floatnumber</p>
<h3 id="decr-key">decr key</h3>
<h3 id="decrby-key-number">decrby key number</h3>
<h3 id="getbit-key-offset">getbit key offset</h3>
<p>作用:获取值的二进制表示,对应位上的值(从左,从0编号)</p>
<h3 id="setbit-key-offset-value">setbit key offset value</h3>
<p>设置offset对应二进制位上的值<br />
返回: 该位上的旧值<br />
注意:<br />
1. 如果offset过大,则会在中间填充0,<br />
2. offset最大大到多少<br />
3. offset最大2^32-1,可推出最大的的字符串为512M</p>
<h3 id="setbit-的实际应用">Setbit 的实际应用</h3>
<p>场景: 1亿个用户, 每个用户 登陆/做任意操作 ,记为 今天活跃,否则记为不活跃</p>
<p>每周评出: 有奖活跃用户: 连续7天活动 每月评,等等...</p>
<p>思路:</p>
<pre><code>Userid       date            active
1        2013-07-27           1
1       2013-0726             1</code></pre>
<p>如果是放在表中, 1.表急剧增大, 2.要用group ,sum运算,计算较慢<br />
用: 位图法bit-map</p>
<pre><code>Log0721:  &#39;011001...............0&#39;
......
log0726 :   &#39;011001...............0&#39;
Log0727 :  &#39;0110000.............1&#39;</code></pre>
<ol>
<li>记录用户登陆:<br />
每天按日期生成一个位图, 用户登陆后,把user_id位上的bit值置为1</li>
<li>把1周的位图 and 计算,<br />
位上为1的,即是连续登陆的用户</li>
</ol>
<p>优点:<br />
1. 节约空间, 1亿人每天的登陆情况,用1亿bit,约1200WByte,约10M 的字符就能表示<br />
2. 计算方便</p>
<h3 id="key2...">bitop operation destkey key1</h3>
<p>对key1,key2..keyN作operation,并将结果保存到 destkey 上。<br />
operation 可以是 AND 、 OR 、 NOT 、 XOR<br />
注意: 对于NOT操作, key不能多个</p>
<h2 id="link-链表结构">link 链表结构</h2>
<h3 id="lpush-key-value">lpush key value</h3>
<p>作用: 把值插入到链接头部</p>
<h3 id="lindex-key-index">lindex key index</h3>
<p>作用: 返回index索引上的值,<br />
如 lindex key 2</p>
<h3 id="llen-key">llen key</h3>
<p>作用:计算链接表的元素个数</p>
<h3 id="lrange-key-start-stop">lrange key start stop</h3>
<p>作用: 返回链表中[start ,stop]中的元素，即查看元素<br />
规律: 左数从0开始,右数从-1开始,lrange key 0 -1</p>
<h3 id="rpop-key">rpop key</h3>
<p>作用: 返回并删除链表尾元素</p>
<h3 id="rpushlpop">rpush,lpop</h3>
<p>不解释</p>
<h3 id="lrem-key-count-value">lrem key count value</h3>
<p>作用: 从key链表中删除 value值<br />
注: 删除count的绝对值个value后结束<br />
Count&gt;0 从表头删除<br />
Count&lt;0 从表尾删除</p>
<h3 id="ltrim-key-start-stop">ltrim key start stop</h3>
<p>作用: 剪切key对应的链接,切[start,stop]一段,并把该段重新赋给key</p>
<h3 id="linsert-key-afterbefore-search-value">linsert key after|before search value</h3>
<p>作用: 在key链表中寻找’search’,并在search值之前|之后,.插入value<br />
注: 一旦找到一个search后,命令就结束了,因此不会插入多个value</p>
<h3 id="rpoplpush-source-dest">rpoplpush source dest</h3>
<p>作用: 把source的尾部拿出,放在dest的头部,<br />
并返回 该单元值</p>
<h2 id="集合-set-相关命令">集合 set 相关命令</h2>
<p>集合的性质: 唯一性,无序性,确定性<br />
注: 在string和link的命令中,可以通过range 来访问string中的某几个字符或某几个元素<br />
但,因为集合的无序性,无法通过下标或范围来访问部分元素.<br />
因此想看元素,要么随机先一个,要么全选</p>
<h3 id="sadd-key-value1-value2">sadd key value1 value2</h3>
<p>作用: 往集合key中增加元素</p>
<h3 id="smembers-key">smembers key</h3>
<p>作用: 返回集中中所有的元素，即查看</p>
<h3 id="scard-key">scard key</h3>
<p>作用: 返回集合中元素的个数</p>
<h3 id="srem-key-value1-value2">srem key value1 value2</h3>
<p>作用: 删除集合中集为 value1 value2的元素<br />
返回值: 忽略不存在的元素后,真正删除掉的元素的个数</p>
<h3 id="spop-key">spop key</h3>
<p>作用: 返回并删除集合中key中1个随机元素<br />
随机--体现了无序性</p>
<h3 id="srandmember-key">srandmember key</h3>
<p>作用: 返回集合key中,随机的1个元素.</p>
<h3 id="sismember-key-value">sismember key value</h3>
<p>作用: 判断value是否在key集合中<br />
是返回1,否返回0</p>
<h3 id="smove-source-dest-value">smove source dest value</h3>
<p>作用:把source中的value删除,并添加到dest集合中</p>
<h3 id="sinter-key1-key2-key3">sinter key1 key2 key3</h3>
<p>作用: 求出key1 key2 key3 三个集合中的交集,并返回</p>
<h3 id="sinterstore-dest-key1-key2-key3">sinterstore dest key1 key2 key3</h3>
<p>作用: 求出key1 key2 key3 三个集合中的交集,并赋给dest</p>
<h3 id="suion-key1-key2..-keyn">suion key1 key2.. Keyn</h3>
<p>作用: 求出key1 key2 keyn的并集,并返回</p>
<h3 id="sdiff-key1-key2-key3">sdiff key1 key2 key3</h3>
<p>作用: 求出key1与key2 key3的差集<br />
即key1-key2-key3</p>
<h2 id="order-set有序集合">order set(有序集合)</h2>
<h3 id="zadd-key-score1-value1-score2-value2-..">zadd key score1 value1 score2 value2 ..</h3>
<p>添加元素 有score才能排序呢,才是有序的<br />
redis 127.0.0.1:6379&gt; zadd stu 18 lily 19 hmm 20 lilei 21 lilei<br />
(integer) 3 # lilei添加了两次</p>
<h3 id="withscores">zrange key start stop</h3>
<p>把集合排序后,返回名次[start,stop]的元素<br />
默认是升续排列<br />
Withscores 是把score也打印出来</p>
<h3 id="zrem-key-value1-value2-..">zrem key value1 value2 ..</h3>
<p>作用: 删除集合中的元素</p>
<h3 id="zremrangebyscore-key-min-max">zremrangebyscore key min max</h3>
<p>作用: 按照socre来删除元素,删除score在[min,max]之间的</p>
<p>redis 127.0.0.1:6379&gt; zremrangebyscore stu 4 10<br />
(integer) 2</p>
<p>redis 127.0.0.1:6379&gt; zrange stu 0 -1<br />
1) "f"</p>
<h3 id="zremrangebyrank-key-start-end">zremrangebyrank key start end</h3>
<p>作用: 按排名删除元素,删除名次在[start,end]之间的</p>
<pre><code>redis 127.0.0.1:6379&gt; zremrangebyrank stu 0 1
(integer) 2</code></pre>
<h3 id="zrank-key-member">zrank key member</h3>
<p>查询member的排名(升续 0名开始),查询排在第几位</p>
<h3 id="zrevrank-key-memeber">zrevrank key memeber</h3>
<p>查询 member的排名(降续 0名开始)</p>
<h3 id="zrevrange-key-start-stop-当然按score排序了">zrevrange key start stop 当然按score排序了</h3>
<p>作用:把集合降序排列,取名字[start,stop]之间的元素</p>
<h3 id="zrangebyscore-key-min-max-withscores-limit-offset-n-当然按score排序">zrangebyscore key min max <a href="#withscores">withscores</a> limit offset N 当然按score排序</h3>
<p>作用: 集合(升续)排序后,取score在[min,max]内的元素,</p>
<p>并跳过 offset个, 取出N个</p>
<pre><code>redis 127.0.0.1:6379&gt; zadd stu 1 a 3 b 4 c 9 e 12 f 15 g

(integer) 6

redis 127.0.0.1:6379&gt; zrangebyscore stu 3 12 limit 1 2 withscores
1) &quot;c&quot;
2) &quot;4&quot;
3) &quot;e&quot;
4) &quot;9&quot;</code></pre>
<h3 id="zcard-key">zcard key</h3>
<p>返回元素个数</p>
<h3 id="zcount-key-min-max">zcount key min max</h3>
<p>返回[min,max] 区间内元素的数量</p>
<h3 id="aggregatesum|min|max">zinterstore destination numkeys key1 [key2 ...] [WEIGHTS weight [weight ...]]</h3>
<p>numkeys 是取几个</p>
<p>求key1,key2的交集,key1,key2的权重分别是 weight1,weight2</p>
<p>聚合方法用: sum |min|max</p>
<p>聚合的结果,保存在dest集合内</p>
<p>注意: weights ,aggregate如何理解?</p>
<p>答: 如果有交集, 交集元素又有socre,score怎么处理?<br />
Aggregate sum-&gt;score相加,min求最小score,max最大score</p>
<p>另: 可以通过weigth设置不同key的权重,交集时,key1.socre * key1.weights + key2.socre * key2.weights + ...</p>
<p>详见下例</p>
<pre><code>redis 127.0.0.1:6379&gt; zadd z1 2 a 3 b 4 c
(integer) 3

redis 127.0.0.1:6379&gt; zadd z2 2.5 a 1 b 8 d
(integer) 3

redis 127.0.0.1:6379&gt; zinterstore tmp 2 z1 z2
(integer) 2

redis 127.0.0.1:6379&gt; zrange tmp 0 -1
1) &quot;b&quot;
2) &quot;a&quot;

redis 127.0.0.1:6379&gt; zrange tmp 0 -1 withscores
1) &quot;b&quot;
2) &quot;4&quot;
3) &quot;a&quot;
4) &quot;4.5&quot;

redis 127.0.0.1:6379&gt; zinterstore tmp 2 z1 z2 aggregate sum
(integer) 2

redis 127.0.0.1:6379&gt; zrange tmp 0 -1 withscores
1) &quot;b&quot;
2) &quot;4&quot;
3) &quot;a&quot;
4) &quot;4.5&quot;

redis 127.0.0.1:6379&gt; zinterstore tmp 2 z1 z2 aggregate min
(integer) 2

redis 127.0.0.1:6379&gt; zrange tmp 0 -1 withscores
1) &quot;b&quot;
2) &quot;1&quot;
3) &quot;a&quot;
4) &quot;2&quot;

redis 127.0.0.1:6379&gt; zinterstore tmp 2 z1 z2 weights 1 2
(integer) 2

redis 127.0.0.1:6379&gt; zrange tmp 0 -1 withscores
1) &quot;b&quot;
2) &quot;5&quot;
3) &quot;a&quot;
4) &quot;7&quot;</code></pre>
<h2 id="hash-哈希数据类型相关命令">Hash 哈希数据类型相关命令</h2>
<h3 id="hset-key-field-value">hset key field value</h3>
<p>作用: 把key中 filed域的值设为value</p>
<p>注:如果没有field域,直接添加,如果有,则覆盖原field域的值</p>
<h3 id="field2value2field3value3......fieldnvaluen">hmset key field1 value1</h3>
<p>作用: 设置field1-&gt;N 个域, 对应的值是value1-&gt;N</p>
<p>(对应PHP理解为 $key = array(file1=&gt;value1, field2=&gt;value2 ....fieldN=&gt;valueN))</p>
<h3 id="hget-key-field">hget key field</h3>
<p>作用: 返回key中field域的值</p>
<h3 id="hmget-key-field1-field2-fieldn">hmget key field1 field2 fieldN</h3>
<p>作用: 返回key中field1 field2 fieldN域的值</p>
<h3 id="hgetall-key">hgetall key</h3>
<p>作用:返回key中,所有域与其值</p>
<h3 id="hdel-key-field">hdel key field</h3>
<p>作用: 删除key中 field域</p>
<h3 id="hlen-key">hlen key</h3>
<p>作用: 返回key中元素的数量</p>
<h3 id="hexists-key-field">hexists key field</h3>
<p>作用: 判断key中有没有field域</p>
<h3 id="hinrby-key-field-value">hinrby key field value</h3>
<p>作用: 是把key中的field域的值增长整型值value</p>
<h3 id="hinrby-float-key-field-value">hinrby float key field value</h3>
<p>作用: 是把key中的field域的值增长浮点值value</p>
<h3 id="hkeys-key">hkeys key</h3>
<p>作用: 返回key中所有的field</p>
<h3 id="kvals-key">kvals key</h3>
<p>作用: 返回key中所有的value</p>
<h2 id="redis-中的事务">Redis 中的事务</h2>
<p>Redis与 mysql事务的对比</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>Mysql</th>
<th>Redis</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>开启</td>
<td>start transaction</td>
<td>muitl</td>
</tr>
<tr class="even">
<td>语句</td>
<td>普通sql</td>
<td>普通命令</td>
</tr>
<tr class="odd">
<td>失败</td>
<td>rollback 回滚</td>
<td>discard 取消</td>
</tr>
<tr class="even">
<td>成功</td>
<td>commit</td>
<td>exec</td>
</tr>
</tbody>
</table>
<p>注: rollback与discard 的区别</p>
<p>如果已经成功执行了2条语句, 第3条语句出错.<br />
Rollback后,前2条的语句影响消失.<br />
Discard只是结束本次事务,前2条语句造成的影响仍然还在</p>
<p>注:<br />
在mutil后面的语句中, 语句出错可能有2种情况</p>
<p>1: 语法就有问题,<br />
这种,exec时,报错, 所有语句得不到执行</p>
<p>2: 语法本身没错,但适用对象有问题. 比如 zadd 操作list对象<br />
Exec之后,会执行正确的语句,并跳过有不适当的语句.<br />
(如果zadd操作list这种事怎么避免? 这一点,由程序员负责)</p>
<p>Redis支持简单的事务,Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：<br />
* 批量操作在发送 EXEC 命令前被放入队列缓存。<br />
* 收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。<br />
* 在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p>
<p>一个事务从开始到执行会经历以下三个阶段：<br />
* 开始事务。<br />
* 命令入队。<br />
* 执行事务。</p>
<p>思考:</p>
<p>我正在买票<br />
Ticket -1 , money -100</p>
<p>而票只有1张, 如果在我multi之后,和exec之前, 票被别人买了---即ticket变成0了.<br />
我该如何观察这种情景,并不再提交</p>
<ul>
<li><p>悲观的想法:<br />
世界充满危险,肯定有人和我抢, 给 ticket上锁, 只有我能操作. [悲观锁]</p></li>
<li><p>乐观的想法:<br />
没有那么人和我抢,因此,我只需要注意,有没有人更改ticket的值就可以了 [乐观锁]</p></li>
</ul>
<p>Redis的事务中,启用的是<strong>乐观锁</strong>,只负责监测key没有被改动.<strong>要是改了就不执行了</strong></p>
<p>具体的命令----<code>watch</code>命令</p>
<pre><code>redis 127.0.0.1:6379&gt; watch ticket
OK

redis 127.0.0.1:6379&gt; multi
OK

redis 127.0.0.1:6379&gt; decr ticket
QUEUED

redis 127.0.0.1:6379&gt; decrby money 100
QUEUED

redis 127.0.0.1:6379&gt; exec
(nil)   // 返回nil,说明监视的ticket已经改变了,事务就取消了.

redis 127.0.0.1:6379&gt; get ticket
&quot;0&quot;

redis 127.0.0.1:6379&gt; get money
&quot;200&quot;</code></pre>
<ul>
<li><p>watch key1 key2 ... keyN<br />
作用:监听key1 key2..keyN有没有变化,如果有变, 则事务取消</p></li>
<li><p>unwatch<br />
作用: 取消所有watch监听</p></li>
</ul>
<h2 id="消息订阅">消息订阅</h2>
<p>Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。<br />
Redis 客户端可以订阅任意数量的频道。</p>
<ul>
<li>订阅端: Subscribe 频道名称</li>
<li>发布端: publish 频道名称 发布内容</li>
</ul>
<p>实例：<br />
1. 开启本地 Redis 服务，开启两个 redis-cli 客户端。<br />
2. 在<strong>第一个 redis-cli 客户端</strong>输入 SUBSCRIBE runoobChat，意思是订阅 <code>runoobChat</code> 频道。<br />
3. 在<strong>第二个 redis-cli 客户端</strong>输入 PUBLISH runoobChat "Redis PUBLISH test" 往 runoobChat 频道发送消息，这个时候在第一个 redis-cli 客户端就会看到由第二个 redis-cli 客户端发送的测试消息。</p>
<h2 id="redis-数据备份与恢复">Redis 数据备份与恢复</h2>
<p>Redis SAVE 命令用于创建当前数据库的备份。</p>
<p>redis Save 命令基本语法如下：</p>
<pre><code>redis 127.0.0.1:6379&gt; SAVE
OK</code></pre>
<p>该命令将在 redis 安装目录中创建dump.rdb文件。<br />
恢复数据<br />
如果需要恢复数据，只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可。获取 redis 目录可以使用 CONFIG 命令，</p>
<h2 id="redis持久化配置">Redis持久化配置</h2>
<p>Redis的持久化有2种方式:1.快照 2.是日志</p>
<p>Rdb(Redis DataBase)快照的配置选项<br />
RDB 是 Redis 默认的持久化方案。在指定的时间间隔内，执行指定次数的写操作，则会将内存中的数据写入到磁盘中。即在指定目录下生成一个dump.rdb文件。Redis 重启会通过加载dump.rdb文件恢复数据。</p>
<pre><code>// (这3个选项都屏蔽,则rdb禁用)
save 900 1      // 900内,有1条写入,则产生快照
save 300 1000   // 如果300秒内有1000次写入,则产生快照
save 60 10000  // 如果60秒内有10000次写入,则产生快照

 

stop-writes-on-bgsave-error yes  // 后台备份进程出错时,主进程停不停止写入?
rdbcompression yes    // 导出的rdb文件是否压缩
Rdbchecksum   yes //  导入rbd恢复时数据时,要不要检验rdb的完整性
dbfilename dump.rdb  //导出来的rdb文件名
dir ./  //rdb的放置路径</code></pre>
<p>Aof (Append Only File) 配置<br />
AOF ：Redis 默认不开启。它的出现是为了弥补RDB的不足（数据的不一致性），所以它采用日志的形式来记录每个写操作，并追加到文件中。Redis 重启的会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p>
<pre><code>appendonly no # 是否打开 aof日志功能
appendfsync always   # 每1个命令,都立即同步到aof. 安全,速度慢
appendfsync everysec # 折衷方案,每秒写1次
appendfsync no      # 写入工作交给操作系统,由操作系统判断缓冲区大小,统一写入到aof. 同步频率低,速度快,


no-appendfsync-on-rewrite  yes: # 正在导出rdb快照的过程中,要不要停止同步aof
auto-aof-rewrite-percentage 100 #aof文件大小比起上次重写时的大小,增长率100%时,重写
auto-aof-rewrite-min-size 64mb #aof文件,至少超过64M时,重写</code></pre>
<p>注: 在dump rdb过程中,aof如果停止同步,会不会丢失?<br />
答: 不会,所有的操作缓存在内存的队列里, dump完成后,统一操作.</p>
<p>注: aof重写是指什么?<br />
答: aof重写是指把内存中的数据,逆化成命令,写入到.aof日志里.<br />
以解决 aof日志过大的问题.</p>
<p>问: 如果rdb文件,和aof文件都存在,优先用谁来恢复数据?<br />
答: aof</p>
<p>问: 2种是否可以同时用?<br />
答: 可以,而且推荐这么做</p>
<p>问: 恢复时rdb和aof哪个恢复的快<br />
答: rdb快,因为其是数据的内存映射,直接载入到内存,而aof是命令,需要逐条执行</p>
<h2 id="redis-服务器端命令">redis 服务器端命令</h2>
<pre><code>redis 127.0.0.1:6380&gt; dbsize  // 当前数据库的key的数量</code></pre>
<p>Flushall 清空所有库所有键<br />
Flushdb 清空当前库所有键<br />
Showdown [save/nosave]</p>
<p>注: 如果不小心运行了flushall, 立即 shutdown nosave ,关闭服务器<br />
然后 手工编辑aof文件, 去掉文件中的 “flushall ”相关行, 然后开启服务器,就可以导入回原来数据.</p>
<p>Slowlog 显示慢查询<br />
注:多慢才叫慢?<br />
答: 由slowlog-log-slower-than 10000 ,来指定,(单位是微秒)</p>
<p>服务器储存多少条慢查询的记录?<br />
答: 由 slowlog-max-len 128 ,来做限制</p>
<p>Info [Replication/CPU/Memory..]<br />
查看redis服务器的信息</p>
<h2 id="redis-key-设计技巧">Redis key 设计技巧</h2>
<ol>
<li>把表名转换为key前缀 如, tag:</li>
<li>第2段放置用于区分区key的字段--对应mysql中的主键的列名,如userid</li>
<li>第3段放置主键值,如2,3,4...., a , b ,c</li>
<li>第4段,写要存储的列名</li>
</ol>
<p>用户表 user , 转换为key-value存储</p>
<pre><code>userid  username  passworde  email
9       Lisi      1111111    lisi@163.com</code></pre>
<p>set user:userid:9:username lisi<br />
set user:userid:9:password 111111<br />
set user:userid:9:email lisi@163.com<br />
keys user:userid:9*</p>
<p>注意:<br />
在关系型数据中,除主键外,还有可能其他列也步骤查询,<br />
如上表中, username 也是极频繁查询的,往往这种列也是加了索引的.<br />
转换到k-v数据中,则也要相应的生成一条按照该列为主的key-value</p>
<pre><code>Set  user:username:lisi:uid  9 </code></pre>
<p>这样,我们可以根据username:lisi:uid ,查出userid=9,<br />
再查user:9:password/email ...</p>
<h2 id="php-redis扩展编译">php-redis扩展编译</h2>
<ol>
<li>到pecl.php.net 搜索redis</li>
<li>下载stable版(稳定版)扩展</li>
<li>解压,</li>
<li>执行/php/path/bin/phpize (作用是检测PHP的内核版本,并为扩展生成相应的编译配置)</li>
<li>configure --with-php-config=/php/path/bin/php-config</li>
<li>make &amp;&amp; make install</li>
</ol>
<p>引入编译出的redis.so插件<br />
1: 编辑php.ini<br />
2: 添加</p>
<p>php配置文件</p>
<pre><code>extension=php_igbinary.dll
extension=php_redis.dll           windows上要装这两个
http://pecl.php.net/package/redis  官方网站上有安装包</code></pre>
<p>redis在php中的的使用</p>
<pre><code>// get instance
$redis = new Redis();

 
// connect to redis server
$redis-&gt;open(&#39;localhost&#39;,6380);
$redis-&gt;set(&#39;user:userid:9:username&#39;,&#39;wangwu&#39;);
var_dump($redis-&gt;get(&#39;user:userid:9:username&#39;));</code></pre>
<h2 id="安全问题">安全问题</h2>
<h3 id="redis设置访问权限">redis设置访问权限</h3>
<p>漏洞描述：<br />
redis 默认不需要密码即可访问，黑客直接访问即可获取数据库中所有信息，造成严重的信息泄露。</p>
<p>修复方案：<br />
1. 绑定需要访问数据库的IP<br />
修改 redis.conf 中的 “bind 127.0.0.1” ，改成需要访问此数据库的IP地址。</p>
<ol>
<li>设置访问密码<br />
在 redis.conf 中找到“requirepass”字段，在后面填上你需要的密码。</li>
</ol>
<blockquote>
<p>注：上述两种方法修改后，需要重启redis才能生效。</p>
</blockquote>

<footer id="colophon" >
		<div class="site-info col">
			Powered by <a href="https://github.com/sunxvming/my-blog">my-blog</a>
			<span class="sep"> | </span>
				<span><a target="_blank" href="http://beian.miit.gov.cn">【京ICP备19018538号】</a></span>
			<span><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11010502037753">【京公网安备 11010502037753号】</a></span>
		</div><!-- .site-info col -->
        <div class="site-info col"> This page is hosted at <a target="_blank" href="https://github.com/sunxvming">Github</a>.To see the source code you can visit the <a target="_blank" href="https://github.com/sunxvming/my-blog">repo</a> and I'd be glad if you like and star it.</div>
</footer>
</div> <!--wrapper-->
</body>
</html>
