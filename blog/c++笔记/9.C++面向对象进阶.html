<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta name="generator" content="pandoc" />




<link rel="stylesheet" href="../../style.css" type="text/css" />



<script src="https://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
<script>
jQuery(document).ready(function(){
    jQuery('pre').each(function(){
        var el = jQuery(this).find('code');
        var code_block = el.html(); 
 
        if (el.length > 0) { 
            jQuery(this).addClass('prettyprint').html(code_block).attr('style', 'max-height:450px');
        } else { 
            jQuery(this).removeClass().addClass('prettyprint'); 
        }
    });
});
</script>

<script type="text/javascript" src="../../run_prettify.js"></script>

</head>


<body>
<div id="wrapper">

<div id="header">
    <p class="header_titleline">忧郁的大能猫的博客</p>
    <p class="header_subline"><a href="/index.html">首页</a></p>
</div>


 <!--if(title)-->

<p>目录:</p>
<div id="TOC">
<ul>
<li><a href="#c拷贝构造函数"> C++拷贝构造函数</a></li>
<li><a href="#到底什么时候会调用拷贝构造函数"> 到底什么时候会调用拷贝构造函数</a></li>
<li><a href="#c深拷贝和浅拷贝"> C++深拷贝和浅拷贝</a></li>
<li><a href="#c重载赋值运算符"> C++重载=（赋值运算符）</a></li>
<li><a href="#c拷贝控制操作三五法则"> C++拷贝控制操作（三/五法则）</a></li>
<li><a href="#c转换构造函数将其它类型转换为当前类的类型"> C++转换构造函数：将其它类型转换为当前类的类型</a></li>
<li><a href="#c类型转换函数将当前类的类型转换为其它类型"> C++类型转换函数：将当前类的类型转换为其它类型</a></li>
<li><a href="#再谈c转换构造函数和类型转换函数进阶"> 再谈C++转换构造函数和类型转换函数（进阶）</a></li>
<li><a href="#cc类型转换的本质"> C/C++类型转换的本质</a></li>
<li><a href="#四种类型转换运算符"> 四种类型<strong>转换运算符</strong></a></li>
</ul>
</div>
 <!--if(toc)-->

<h3 id="c拷贝构造函数"> C++拷贝构造函数</h3>
<p><em> 拷贝是在用<strong>其它对象</strong>的数据来<strong>初始化</strong>新对象的内存时发生的 </em> <strong>默认</strong>的拷贝构造函数很简单，就是使用“老对象”的成员变量对“新对象”的成员变量进行挨个赋值 <em> 当类持有其它资源时，如动态分配的内存、打开的文件、指向其他数据的指针、网络连接等，默认拷贝构造函数就不能拷贝这些资源，我们必须显式地定义拷贝构造函数，以完整地拷贝对象的所有数据。 </em> 此时有两种做法：1.behavior like a value(深拷贝)  2.behavior like a ref(引用计数)</p>
<h3 id="到底什么时候会调用拷贝构造函数"> 到底什么时候会调用拷贝构造函数</h3>
<p>以拷贝的方式来初始化对象的情况： 1. 将其它对象作为实参 <code>Student stu2(stu1); //以拷贝的方式初始化</code> 2. 在创建对象的同时以对象赋值 3. 函数调用时，形参为类类型，将实参传递给形参就是以拷贝的方式初始化的 4. 函数返回值为类类型 当函数的返回值为类类型时，return 语句会返回一个对象，不过为了防止局部对象被销毁，编译器并不会直接返回这个对象，而是根据这个对象先创建出一个<strong>临时对象（匿名对象）</strong>，再将这个临时对象返回。而创建临时对象的过程，就是以拷贝的方式进行的，会调用拷贝构造函数。</p>
<pre><code>Student func(){
    Student s(&quot;小明&quot;, 16, 90.5);
    return s;
}
Student stu = func();</code></pre>
<p>理论上讲，运行代码后会调用<strong>两次拷贝构造函数</strong>，一次是返回 s 对象时，另外一次是创建 stu 对象时。但是在现代编译器上，只会调用一次拷贝构造函数，或者一次也不调用这是因为，现代编译器都支持<strong>返回值优化技术</strong>，会尽量避免拷贝对象，以提高程序运行效率</p>
<h3 id="c深拷贝和浅拷贝"> C++深拷贝和浅拷贝</h3>
<p>默认浅拷贝，深拷贝要自己处理（behavior like a value(深拷贝)） 深拷贝例子：</p>
<pre><code>Array(const Array &amp;arr); //拷贝构造函数
Array::Array(const Array &amp;arr){ //拷贝构造函数
    this-&gt;m_len = arr.m_len;
    this-&gt;m_p = (int*)calloc( this-&gt;m_len, sizeof(int) );
    memcpy( this-&gt;m_p, arr.m_p, m_len * sizeof(int) );
}</code></pre>
<p>深拷贝的例子比比皆是，标准模板库（STL）中的 <code>string、vector、stack、set、map</code> 等都必须使用深拷贝。</p>
<p>深拷贝的时机： 1. 存在指针成员，和动态分配的内存,因为只有这样，才能将指针指向的内容再复制出一份来，让原有对象和新生对象相互独立，彼此之间不受影响。</p>
<h3 id="c重载赋值运算符"> C++重载=（赋值运算符）</h3>
<p>编译器会默认生成。功能就是将原有对象的所有成员变量挨个赋值给新对象，这和默认拷贝构造函数的功能类似。 若<strong>需要拷贝构造函数，则必须有赋值运算符</strong>。</p>
<pre><code>Array &amp; operator=(const Array &amp;arr);
Array &amp;Array::operator=(const Array &amp;arr){ //重载赋值运算符
    if( this != &amp;arr){ //判断是否是给自己赋值
        this-&gt;m_len = arr.m_len;
        free(this-&gt;m_p); //释放原来的内存
        this-&gt;m_p = (int*)calloc( this-&gt;m_len, sizeof(int) );
        memcpy( this-&gt;m_p, arr.m_p, m_len * sizeof(int) );
    }
    return *this;
}</code></pre>
<h3 id="c拷贝控制操作三五法则"> C++拷贝控制操作（三/五法则）</h3>
<p>由于<strong>拷贝控制操作</strong>是由三个特殊的成员函数来完成的，所以我们称此为“C++三法则”。在较新的 C++11 标准中，为了支持移动语义，又增加了移动构造函数和移动赋值运算符，这样共有五个特殊的成员函数，所以又称为“C++五法则”。合称三/五法则。 C++ 并不要求我们定义所有的这些操作，你可以只定义其中的一个或两个。但是，这些操作<strong>通常应该被看做一个整体</strong>，只需要定义其中一个操作，而不需要定义其他操作的情况很少见。 <em> 1.需要析构函数的类也需要拷贝和赋值操作 若没有拷贝和赋值操作，那么析构函数free()的时候可能free两次，造成错误 </em> 2.需要拷贝操作的类也需要赋值操作，反之亦然</p>
<h3 id="c转换构造函数将其它类型转换为当前类的类型"> C++转换构造函数：将其它类型转换为当前类的类型</h3>
<p>不管是自动类型转换还是强制类型转换，<strong>前提必须是编译器知道如何转换</strong>，例如，将小数转换为整数会抹掉小数点后面的数字，将<code>int *</code>转换为<code>float *</code>只是简单地复制指针的值，这些规则都是编译器内置的，我们并没有告诉编译器。 换句话说，<strong>如果编译器不知道转换规则就不能转换，使用强制类型也无用</strong> 幸运的是，C++ 允许我们自定义类型转换规则，用户可以将其它类型转换为当前类类型，也可以将当前类类型转换为其它类型。 这种自定义的类型转换规则只能以<strong>类的成员函数</strong>的形式出现，换句话说，这种转换规则只适用于类。 在进行数学运算、赋值、拷贝等操作时，如果遇到类型不兼容、需要将 double 类型转换为 Complex 类型时，编译器会检索当前的类<strong>是否定义了转换构造函数</strong>，如果没有定义的话就转换失败，如果定义了的话就调用转换构造函数。 #### 再谈构造函数</p>
<p>* 1) 默认构造函数。就是编译器自动生成的构造函数。以 Complex 类为例，它的原型为：</p>
<pre><code>Complex(); //没有参数</code></pre>
<p>* 2) 普通构造函数。就是用户自定义的构造函数。以 Complex 类为例，它的原型为：</p>
<pre><code>Complex(double real, double imag); //两个参数</code></pre>
<p>* 3) 拷贝构造函数。在以拷贝的方式初始化对象时调用。以 Complex 类为例，它的原型为：</p>
<pre><code>Complex(const Complex &amp;c);</code></pre>
<p>* 4) 转换构造函数。将其它类型转换为当前类类型时调用。以 Complex 为例，它的原型为：</p>
<pre><code>Complex(double real);</code></pre>
<p>不管哪一种构造函数，都能够<strong>用来初始化对象</strong>，这是构造函数的本意。 除了在创建对象时初始化对象，其他情况下也会调用构造函数，例如，以拷贝的的方式初始化对象时会调用拷贝构造函数，将其它类型转换为当前类类型时会调用转换构造函数。</p>
<h3 id="c类型转换函数将当前类的类型转换为其它类型"> C++类型转换函数：将当前类的类型转换为其它类型</h3>
<p><strong>转换构造函数</strong>能够将其它类型转换为当前类类型（例如将 double 类型转换为 Complex 类型），但是不能反过来将当前类类型转换为其它类型（例如将 Complex 类型转换为 double 类型）。 语法：</p>
<pre><code>operator type(){        //this参数会自动传入进去
    return data;
}
//例子：
operator double() const { return m_real; } //类型转换函数</code></pre>
<p>因为要转换的目标类型是 type，所以返回值 data 也必须是 type 类型。 类型转换函数看起来没有返回值类型，其实是<strong>隐式地指明了返回值类型</strong>。 关于类型转换函数的说明: <em> 1) type 可以是内置类型、类类型以及由 typedef 定义的类型别名，任何可作为函数返回类型的类型（void 除外）都能够被支持。一般而言，不允许转换为数组或函数类型，转换为指针类型或引用类型是可以的。 </em> 2) 类型转换函数一般不会更改被转换的对象，所以通常被定义为 <strong>const 成员</strong>。 <em> 3) 类型转换函数可以被继承，可以是虚函数。 </em> 4) 一个类虽然可以有多个类型转换函数（类似于函数重载），但是如果多个类型转换函数要转换的目标类型本身又可以相互转换（类型相近），那么有时候就会产生二义性 比如：</p>
<pre><code>operator double() const { return m_real; } //转换为double类型
operator int() const { return (int)m_real; } //转换为int类型
// 下面会出错
Complex c1(24.6, 100);
float f = 12.5 + c1;</code></pre>
<h3 id="再谈c转换构造函数和类型转换函数进阶"> 再谈C++转换构造函数和类型转换函数（进阶）</h3>
<p><code>std::string</code>就是最好的例子 转换构造函数和类型转换函数的<strong>作用是相反的</strong>： 转换构造函数会将其它类型转换为当前类类型，类型转换函数会将当前类类型转换为其它类型。 如果没有这两个函数，Complex 类和 int、double、bool 等基本类型的四则运算、逻辑运算都将变得非常复杂，<strong>要编写大量的运算符重载函数</strong>。 <strong>但是，如果一个类同时存在这两个函数，就有可能产生二义性。</strong> 解决二义性问题的办法也很简单粗暴，要么只使用转换构造函数，要么只使用类型转换函数。 实践证明，<strong>用户对转换构造函数的需求往往更加强烈</strong>，这样能<strong>增加编码的灵活性</strong>，例如，可以将一个字符串字面量或者一个字符数组直接赋值给 string 类的对象，可以将一个 int、double、bool 等基本类型的数据直接赋值给 Complex 类的对象。 如果我们想把当前类类型转换为其它类型怎么办呢？很简单，增加一个<strong>普通的成员函数即可</strong>，例如，string 类使用 <code>c_str()</code> 函数转换为 C 风格的字符串，complex 类使用 <code>real() 和 imag()</code> 函数来获取复数的实部和虚部。</p>
<h3 id="cc类型转换的本质"> C/C++类型转换的本质</h3>
<p>原则：有强制转换就有风险 内存中的数据有多种解释方式，使用之前必须要确定。这种「确定数据的解释方式」的工作就是由数据类型（Data Type）来完成的。例如int a;表明，a 这份数据是整数，不能理解为像素、声音、视频等。 所谓数据类型转换，就是<strong>对数据所占用的二进制位做出重新解释</strong>。如果有必要，在重新解释的同时<strong>还会修改数据</strong>，改变它的二进制位。 对于隐式类型转换，编译器可以根据<strong>已知的转换规则</strong>来决定是否需要修改数据的二进制位； 而对于强制类型转换，由于没有对应的转换规则，所以能做的事情仅仅是<strong>重新解释数据的二进制位</strong>，但无法对数据的二进制位做出修正。这就是隐式类型转换和强制类型转换最根本的区别。 隐式类型转换必须使用已知的转换规则，虽然灵活性受到了限制，但是由于能够对数据进行恰当地调整，所以更加安全（几乎没有风险）。强制类型转换能够在更大范围的数据类型之间进行转换，例如不同类型指针（引用）之间的转换、从 const 到非 const 的转换、从 int 到指针的转换（有些编译器也允许反过来）等，这虽然增加了灵活性，但是由于不能恰当地调整数据，所以也充满了风险，程序员要小心使用。</p>
<h4 id="为什么会有隐式类型转换和强制类型转换之分"> 为什么会有隐式类型转换和强制类型转换之分？ </h4>
<p>隐式类型转换和显式类型转换最根本的区别： <em> 隐式类型转换除了会重新解释数据的二进制位，还会利用<strong>已知的转换规则</strong>（编译器和自己定义的转换函数）对数据进行恰当地调整； </em> 显式类型转换只能简单粗暴地重新解释二进制位，不能对数据进行任何调整。</p>
<h4 id="强制类型转换也不是万能的"> 强制类型转换也不是万能的</h4>
<p><em> 两个没有继承关系的类不能相互转换 </em> 基类不能向派生类转换（向下转型） <em> 类类型不能向基本类型转换 </em> 指针和类类型之间不能相互转换。</p>
<h3 id="四种类型转换运算符"> 四种类型<strong>转换运算符</strong></h3>
<p>C风格的强制类型转换统一使用<code>( )</code>,而他是很难再程序中搜索到的。 为了使潜在风险更加细化，使问题追溯更加方便，使书写格式更加规范，C++ <strong>对类型转换进行了分类</strong>，并新增了四个关键字来予以支持，它们分别是：</p>
<h4 id="static_cast"> static_cast</h4>
<p>用于良性转换，一般不会导致意外发生，风险很低。 是“静态转换”的意思，也就是在<strong>编译期间转换</strong>，能够更加及时地发现错误,转换失败的话会抛出一个编译错误。 <em> 原有的自动类型转换，例如 short 转 int、int 转 double、向上转型等； </em> void 指针和具体类型指针之间的转换，例如<code>void *</code>转<code>int *</code>、<code>char *</code>转<code>void *</code>等； * 有转换构造函数或者类型转换函数的类与其它类型之间的转换，例如 double 转 Complex（调用转换构造函数）、Complex 转 double（调用类型转换函数）。</p>
<pre><code>//下面是正确的用法
int m = 100;
Complex c(12.5, 23.8);
long n = static_cast&lt;long&gt;(m); //宽转换，没有信息丢失
char ch = static_cast&lt;char&gt;(m); //窄转换，可能会丢失信息
int *p1 = static_cast&lt;int*&gt;( malloc(10 * sizeof(int)) ); //将void指针转换为具体类型指针
void *p2 = static_cast&lt;void*&gt;(p1); //将具体类型指针，转换为void指针
double real= static_cast&lt;double&gt;(c); //调用类型转换函数

//下面的用法是错误的
float *p3 = static_cast&lt;float*&gt;(p1); //不能在两个具体类型的指针之间进行转换
p3 = static_cast&lt;float*&gt;(0X2DF9); //不能将整数转换为指针类型</code></pre>
<h4 id="const_cast"> const_cast</h4>
<p>它用来去掉表达式的 const 修饰或 volatile 修饰。换句话说，const_cast 就是用来将 const/volatile 类型转换为非 const/volatile 类型。</p>
<pre><code>int main(){
    const int n = 100;
    int *p = const_cast&lt;int*&gt;(&amp;n);
    *p = 234;
    cout&lt;&lt;&quot;n = &quot;&lt;&lt;n&lt;&lt;endl;
    cout&lt;&lt;&quot;*p = &quot;&lt;&lt;*p&lt;&lt;endl;
    return 0;
}
// 运行结果：
// n = 100,  是因为n相当于编译期间的替换。
// *p = 234</code></pre>
<h4 id="reinterpret_cast"> reinterpret_cast</h4>
<p>高度危险的转换，这种转换仅仅是对<strong>二进制位的重新解释</strong>，<strong>不会借助已有的转换规则对数据进行调整</strong>，但是最灵活</p>
<h4 id="dynamic_cast"> dynamic_cast</h4>
<p><em> 1) 向上转型（Upcasting） 向上转型始终是安全的，所以 dynamic_cast 不会进行任何运行期间的检查，这个时候的 <code>dynamic_cast</code> 和 <code>static_cast</code> 就没有什么区别了 </em> 2) 向下转型（Downcasting） 借助 RTTI，用于类型安全的向下转型（Downcasting）。 会在程序运行期间借助 RTTI 进行类型转换，这就要求基类必须包含虚函数 <code>dynamic_cast &lt;newType&gt; (expression)</code>  对于指针，如果转换失败将返回 NULL；对于引用，如果转换失败将抛出std::bad_cast异常。</p>
<p>dynamic_cast 只能转换<strong>指针类型</strong>和<strong>引用类型</strong>，其它类型（int、double、数组、类、结构体等）都不行。 每个类都会在内存中保存一份类型信息，编译器会将存在继承关系的类的类型信息使用指针“连接”起来，从而形成一个<strong>继承链</strong>（Inheritance Chain） 总起来说，dynamic_cast 会<strong>在程序运行过程中遍历继承链</strong>，如果途中遇到了要转换的目标类型，那么就能够转换成功，如果直到继承链的顶点（最顶层的基类）还没有遇到要转换的目标类型，那么就转换失败。 但是从本质上讲，dynamic_cast 还是只允许向上转型，因为它只会向上遍历继承链。 造成这种假象的根本原因在于，派生类对象可以用任何一个基类的指针指向它（基类指针本来就指向派生类对象）</p>

<div id="footer">
    <p class="footer_titleline">忧郁的大能猫的博客</p>
    <p class="footer_subline">Contact: sunxvming@gmail.com</p>
    <p class="footer_subline">声明: 本站如有侵权行为请及时通知至以上邮箱</p>
</div>
</div> <!--wrapper-->
</body>
</html>
