<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta name="generator" content="pandoc" />




<link rel="stylesheet" href="../../style.css" type="text/css" />



<script src="https://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
<script>
jQuery(document).ready(function(){
    jQuery('pre').each(function(){
        var el = jQuery(this).find('code');
        var code_block = el.html(); 
 
        if (el.length > 0) { 
            jQuery(this).addClass('prettyprint').html(code_block).attr('style', 'max-height:450px');
        } else { 
            jQuery(this).removeClass().addClass('prettyprint'); 
        }
    });
});
</script>

<script type="text/javascript" src="../../run_prettify.js"></script>

</head>


<body>
<div id="wrapper">

<div id="header">
    <p class="header_titleline">忧郁的大能猫的博客</p>
    <p class="header_subline"><a href="/index.html">首页</a></p>
</div>


 <!--if(title)-->

<p>目录:</p>
<div id="TOC">
<ul>
<li><a href="#开篇词c这么难为什么我们还要用c"> 开篇词 | C++这么难，为什么我们还要用C++？</a></li>
<li><a href="#课前必读有关术语发音及环境要求"> 课前必读 | 有关术语发音及环境要求</a></li>
<li><a href="#堆栈raiic里该如何管理资源"> 01 | 堆、栈、RAII：C++里该如何管理资源？</a><ul>
<li><a href="#raii"> RAII</a></li>
</ul></li>
<li><a href="#自己动手实现c的智能指针"> 02 | 自己动手，实现C++的智能指针</a></li>
<li><a href="#右值和移动究竟解决了什么问题"> 03 | 右值和移动究竟解决了什么问题？</a></li>
<li><a href="#容器汇编i比较简单的若干容器"> 04 | 容器汇编 I：比较简单的若干容器</a></li>
<li><a href="#异常用还是不用这是个问题"> 06 | 异常：用还是不用，这是个问题</a></li>
</ul>
</div>
 <!--if(toc)-->

<h2 id="开篇词c这么难为什么我们还要用c"> 开篇词 | C++这么难，为什么我们还要用C++？</h2>
<p>C++ 的国际标准有 6 个版本，98, 03, 11, 14, 17，20 。 C++03是在C++98上面进行了小幅度的修订，C++11则是一次全面的大进化。 C++11—之后，C++ 以每三年一版的频度发布着新的语言标准。 C++ 是一门多范式的通用编程语言，这些不同的范式，都可以在同一项目中组合使用，这就大大增加了开发的灵活性。因此，C++ 适用的领域非常广泛，小到嵌入式，大到分布式服务器，到处可以见到 C++ 的身影。</p>
<p>C++ 的核心竞争力： <em> 抽象能力：意味着较高的开发效率，同时，更重要的是，不会因抽象而降低性能。 </em> 性能：这不用多说了，就是快并且占用资源少。 <em> 功耗：这是近年来我们越来越关注的问题，跟性能直接相关，性能好了功耗自然就低。移动设备上。 </em> 和 C 的兼容性，也是 C++ 的一大优势 目前，跟 C++ 定位差不多、能有直接竞争关系的，也就是既支持高度抽象、又追求高性能 的通用编程语言，其实只有 Rust 一种。 我的个人经验，完成同样的功能，C++ 需要的代码行数一般是 Python 的三倍左右，而性能则可以达到 Python 的十倍以上。 当你的软件属于运算密集或者内存密集型，你需要性能、且愿意为性能付出额外代 价的时候，应该考虑用 C++，特别在你的代码需要部署在多台服务器或者移动设备的场 合。反之，如果性能不会成为你开发的软件的瓶颈，那 C++ 可能就不是一个最合适的工 具。</p>
<h2 id="课前必读有关术语发音及环境要求"> 课前必读 | 有关术语发音及环境要求</h2>
<p>对于 CentOS 7，系统安装的 GCC 版本是 4.8，太老，你可以通过安装 centos- release-scl 和 devtoolset-7-gcc-c++ 两个包来获得 GCC 7；随后，可以使用命令 scl enable devtoolset-7 bash 或 . /opt/rh/devtoolset-7/enable 来启用 GCC7</p>
<p>即使不用较新的 C++ 特性，你也一定要用比较新的编译器。单单是输出错误信息的 友好程度，老版本和新版本就是没法比的。</p>
<h2 id="堆栈raiic里该如何管理资源"> 01 | 堆、栈、RAII：C++里该如何管理资源？</h2>
<p>RAII，完整的英文是 Resource Acquisition Is Initialization，是 C++ 所特有的资源管理 方式。有少量其他语言，如 D、Ada 和 Rust 也采纳了 RAII。 RAII 依托栈和析构函数，来对所有的资源——包括堆内存在内——进行管理。对 RAII 的 使用，使得 C++ 不需要类似于 Java 那样的垃圾收集方法，也能有效地对内存进行管理。 RAII 的存在，也是垃圾收集虽然理论上可以在 C++ 使用，但从来没有真正流行过的主要原因。 ### 堆 序通常需要牵涉到三个可能的内存管理器的操作： 1. 让内存管理器分配一个某个大小的内存块  2. 让内存管理器释放一个之前分配的内存块  3. 让内存管理器进行垃圾收集操作，寻找不再使用的内存块并予以释放  C++ 通常会做上面的操作 1 和 2。Java 会做上面的操作 1 和 3。而 Python 会做上面的操 作 1、2、3。这是语言的特性和实现方式决定的。 例子：</p>
<pre><code>void foo()
{
bar* ptr = new bar();
…
delete ptr;
}</code></pre>
<p>存在两个问题： 1.省略的代码部分也许会抛出异常，导致最后的 delete ptr 得不到执行。 2.更重要的，这个代码不符合 C++ 的惯用法。在 C++ 里，这种情况下有 99% 的可能性 不应该使用堆内存分配，而应使用栈内存分配。这样写代码的，估计可能是从 Java 转过 来的（偷笑）——但我真见过这样的代码 ### 栈 栈上的分配极为简单，移动一下栈指针而已。 栈上的释放也极为简单，函数执行结束时移动一下栈指针即可。 由于后进先出的执行过程，不可能出现内存碎片。</p>
<p>编译器会自动调用析构函数，包括在函数执行发生异常的情况。在发生 异常时对析构函数的调用，还有一个专门的术语，叫栈展开（stack unwinding）。</p>
<h3 id="raii"> RAII</h3>
<p>C++ 支持将对象存储在栈上面。但是，在很多情况下，对象不能，或不应该，存储在栈上。比如： 对象很大； 对象的大小在编译时不能确定； 对象是函数的返回值，但由于特殊的原因，不应使用对象的值返回。</p>
<h2 id="自己动手实现c的智能指针"> 02 | 自己动手，实现C++的智能指针</h2>
<p>智能指针本质上并不神秘，其实就是 RAII 资源管理功能的自然展现而已。</p>
<pre><code>class shape_wrapper {
public:
explicit shape_wrapper(
shape* ptr = nullptr)
: ptr_(ptr) {}
~shape_wrapper()
{
delete ptr_;
}
shape* get() const { return ptr_; }
private:
    shape* ptr_;
};</code></pre>
<p>这个类可以完成智能指针的最基本的功能：对超出作用域的对象进行释放。但它缺了点东西： 1.只适用于 shape 类  2. 该类对象的行为不够像指针  3. 拷贝该类对象会引发程序行为异常 </p>
<p>上面给出的语义本质上就是 C++98 的 auto_ptr 的定义。如果你觉得这个实现很别扭的  话，也恭喜你，因为 C++ 委员会也是这么觉得的：auto_ptr 在 C++17 时已经被正式从  C++ 标准里删除了。</p>
<h2 id="右值和移动究竟解决了什么问题"> 03 | 右值和移动究竟解决了什么问题？</h2>
<pre><code>class A {
B b_;
C c_;
};</code></pre>
<p>从实际内存布局的角度，很多语言——如 Java 和 Python——会在 A 对象里放 B 和 C 的 指针（虽然这些语言里本身没有指针的概念）。而 C++ 则会直接把 B 和 C 对象放在 A 的 内存空间里。这种行为既是优点也是缺点。说它是优点，是因为它保证了内存访问的局域 性，而局域性在现代处理器架构上是绝对具有性能优势的。说它是缺点，是因为复制对象的 开销大大增加：在 Java 类语言里复制的是指针，在 C++ 里是完整的对象。这就是为什么 C++ 需要移动语义这一优化，而 Java 类语言里则根本不需要这个概念。</p>
<p>所有的现代 C++ 的标准容器都针对移动进行了优化。</p>
<h2 id="容器汇编i比较简单的若干容器"> 04 | 容器汇编 I：比较简单的若干容器</h2>
<h2 id="异常用还是不用这是个问题"> 06 | 异常：用还是不用，这是个问题</h2>

<div id="footer">
    <p class="footer_titleline">忧郁的大能猫的博客</p>
    <p class="footer_subline">Contact: sunxvming@gmail.com</p>
    <p class="footer_subline">声明: 本站如有侵权行为请及时通知至以上邮箱</p>
</div>
</div> <!--wrapper-->
</body>
</html>
