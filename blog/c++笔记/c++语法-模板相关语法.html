<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta name="generator" content="pandoc" />




<link rel="stylesheet" href="../../style.css" type="text/css" />



<script src="https://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
<script>
jQuery(document).ready(function(){
    jQuery('pre').each(function(){
        var el = jQuery(this).find('code');
        var code_block = el.html(); 
 
        if (el.length > 0) { 
            jQuery(this).addClass('prettyprint').html(code_block).attr('style', 'max-height:450px');
        } else { 
            jQuery(this).removeClass().addClass('prettyprint'); 
        }
    });
});
</script>

<script type="text/javascript" src="../../run_prettify.js"></script>

</head>


<body>
<div id="wrapper">

<div id="header">
    <p class="header_titleline">忧郁的大能猫的博客</p>
    <p class="header_subline"><a href="/index.html">首页</a></p>
</div>


 <!--if(title)-->

<p>目录:</p>
<div id="TOC">
<ul>
<li><a href="#stdconditional">std::conditional</a></li>
<li><a href="#enable_if">enable_if</a><ul>
<li><a href="#sfinae">SFINAE</a></li>
<li><a href="#stdenable_if的实现机制如下代码所示">std::enable_if&lt;&gt;的实现机制如下代码所示：</a></li>
<li><a href="#典型应用">典型应用</a></li>
</ul></li>
<li><a href="#可变参数模板">可变参数模板</a></li>
</ul>
</div>
 <!--if(toc)-->

<h2 id="stdconditional">std::conditional</h2>
<pre><code>// 别名
template&lt; bool B, class T, class F &gt;
using conditional_t = typename conditional&lt;B,T,F&gt;::type;




int main() 
{
    typedef std::conditional&lt;true, int, double&gt;::type Type1;
    typedef std::conditional&lt;false, int, double&gt;::type Type2;
    typedef std::conditional&lt;sizeof(int) &gt;= sizeof(double), int, double&gt;::type Type3;
 
    std::cout &lt;&lt; typeid(Type1).name() &lt;&lt; &#39;\n&#39;;
    std::cout &lt;&lt; typeid(Type2).name() &lt;&lt; &#39;\n&#39;;
    std::cout &lt;&lt; typeid(Type3).name() &lt;&lt; &#39;\n&#39;;
}</code></pre>
<h2 id="enable_if">enable_if</h2>
<h3 id="sfinae">SFINAE</h3>
<p>SFINAE是英文Substitution failure is not an error的缩写，意思是匹配失败不是错误 SFINAE 应用最为广泛的场景是C++中的 std::enable_if。 在对一个函数调用进行模板推导时，编译器会尝试推导所有的候选函数（重载函数，模板，但是普通函数的优先级要高），以确保得到一个最完美的匹配。 也就是说在推导的过程中，如果出现了无效的模板参数，则会将该候选函数从重载决议集合中删除，只要最终得到了一个 perfect match ，编译就不会报错。 比如：</p>
<pre><code>long multiply(int i, int j) { return i * j; }
 
template &lt;class T&gt;
typename T::multiplication_result multiply(T t1, T t2)
{
    return t1 * t2;
}
 
int main(void)
{
    multiply(4, 5);
}</code></pre>
<p>main 函数调用 multiply 会使编译器会尽可能去匹配所有候选函数，虽然第一个 multiply 函数明显是较优的匹配，但是为了得到一个最精确的匹配，编译器依然会尝试去匹配剩下的候选函数，此时就会去推导 第二个multiply函数，中间在参数推导的过程中出现了一个无效的类型 int::multiplication_result ，但是因为 SFINAE 原则并不会报错。</p>
<p>比如：</p>
<pre><code>struct Test {
    typedef int foo;
};


template &lt;typename T&gt; 
void f(typename T::foo) {} // Definition #1


template &lt;typename T&gt; 
void f(T) {}               // Definition #2


int main() {
    f&lt;Test&gt;(10); // Call #1.
    f&lt;int&gt;(10);  // Call #2. Without error (even though there is no int::foo) thanks to SFINAE.
}</code></pre>
<p>当调用<code>f&lt;int&gt;(10)</code>时，由于推导模板函数过程中可以找到一个正确的版本（ Definition #2 ），所以即时int::foo（ Definition #1）是一个语法错误，也没有关系。</p>
<h3 id="stdenable_if的实现机制如下代码所示">std::enable_if&lt;&gt;的实现机制如下代码所示：</h3>
<pre><code>template&lt;bool Cond, typename T = void&gt; struct enable_if {};
 
template&lt;typename T&gt; struct enable_if&lt;true, T&gt; { typedef T type; };</code></pre>
<p>基本原理是SFINAE。只有当第一个参数是true的时候才有type，否则就会发生Substitution Failure，这个时候模版实例化就会失败，也就不会产生任何代码。 在 condition 为真的时候，由于偏特化机制，第二个结构体模板明显是一个更好的匹配，所以 std::enable_if&lt;&gt;::type 就是有效的。 当 condition 为假的时候，只有第一个结构体模板能够匹配，所以std::enable_if&lt;&gt;::type 是无效的，会被丢弃，编译器会报错：error: no type named ‘type’ in ‘struct std::enable_if<false, bool>。</p>
<h3 id="典型应用">典型应用</h3>
<pre><code>#include &lt;iostream&gt;
#include &lt;type_traits&gt;
 


template &lt; class T,
           class = typename std::enable_if&lt;std::is_integral&lt;T&gt;::value&gt;::type&gt;
bool is_even (T i) {return !bool(i%2);}
/*
这两种写法也可以 
std::enable_if_t&lt;std::is_integral&lt;T&gt;::value, int&gt;&gt; 

std::enable_if_t&lt;std::is_integral&lt;T&gt;::value&gt;&gt; 
*/
int main() {  
  double i = 1;    // code does not compile if type of i is not integral
  std::cout &lt;&lt; std::boolalpha;
  // 实例化的时候，enable_if发现不是int类型，就会报error: no type named ‘type’ in ‘struct std::enable_if&lt;false, bool&gt;,从而达到限制类型的效果。
  std::cout &lt;&lt; &quot;i is even: &quot; &lt;&lt; is_even(i) &lt;&lt; std::endl;
  return 0;
}</code></pre>
<h2 id="可变参数模板">可变参数模板</h2>
<pre><code>template&lt;typename T&gt;
ostream &amp;print(ostream &amp;os, const T &amp;t)
{
    return os &lt;&lt; t; // no separator after the last element in the pack
}


template &lt;typename T, typename... Args&gt;
ostream &amp;print(ostream &amp;os, const T &amp;t, const Args&amp;... rest)
{
    os &lt;&lt; t &lt;&lt; &quot;, &quot;;           // print the first argument
    return print(os, rest...); // recursive call; print the other arguments
}
 
int main() {
    print(std::cout,&quot;abc&quot;,123,456);
  
    return 0;
}


//C++17版本的
template &lt;typename ...Args&gt;
    constexpr void print(Args&amp;&amp; ...args) {
        // 包扩展，效果是对每个参数都调用前边的语句

        ((std::cout &lt;&lt; args &lt;&lt; &#39;\n&#39;), ...);
        //或者   ( ...,  (std::cout &lt;&lt; args &lt;&lt; &#39;\n&#39;));

    }


// 其他包扩展的例子
template &lt;typename... Args&gt;
ostream &amp;errorMsg(ostream &amp;os, const Args&amp;... rest)
{
    // print(os, debug_rep(a1), debug_rep(a2), ..., debug_rep(an)
    return print(os, debug_rep(rest)...);
}</code></pre>

<div id="footer">
    <p class="footer_titleline">忧郁的大能猫的博客</p>
    <p class="footer_subline">Contact: sunxvming@gmail.com</p>
    <p class="footer_subline">声明: 本站如有侵权行为请及时通知至以上邮箱</p>
</div>
</div> <!--wrapper-->
</body>
</html>
