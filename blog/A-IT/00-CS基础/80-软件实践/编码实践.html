<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta name="generator" content="pandoc" />



<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<link rel="stylesheet" href="../../../.././css/style.css" />




<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Saira+Semi+Condensed%3A400%2C700&ver=4.9.18" type="text/css" />

<script src="https://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
<script>
jQuery(document).ready(function(){
    jQuery('pre').each(function(){
        var el = jQuery(this).find('code');
        var code_block = el.html(); 
 
        if (el.length > 0) { 
            jQuery(this).addClass('prettyprint').html(code_block).attr('style', 'max-height:450px');
        } else { 
            jQuery(this).removeClass().addClass('prettyprint'); 
        }
    });
});
</script>

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js?skin=desert"></script>

</head>


<body>
<div id="wrapper">


<style type="text/css">

#masthead .site-branding {
    margin-bottom: 7px;
}

#masthead .site-branding .site-title {
    font-size: 2.2rem;
    line-height: 1;
    text-transform: uppercase;
    margin: 0;
    margin-bottom: 0.5rem;
}


#masthead .site-description{
	margin:0px;
}




#masthead .site-branding .site-title a {
    display: inline-block;
    position: relative;
    top: -11px;
}

#masthead  a {
    <!-- color: #007bff; -->
    text-decoration: none;
    background-color: transparent;
}



.io-menu-desktop {
    display: block;
    text-align: right;
}
.io-menu-desktop span.io-menu-button-span {
    display: none;
}
.io-menu-desktop ul {
    padding: 0;
    margin: 0;
    list-style: none;
    background: transparent;
    display: block;
}
.io-menu-desktop ul > li {
    margin-right: -4px;
    display: inline-block;
    position: relative;
    height: 30px;
    color: #212529;
    font-size: 12px;
    text-transform: uppercase;
    text-shadow: 0 0 0 rgb(0 0 0 / 0%);
    font-weight: 400;
}
.io-menu-desktop ul > li > a {
    padding: 0;
    line-height: 29px;
    padding-left: 20px;
    padding-right: 20px;
    padding-top: 1px;
    color: #212529;
    font-size: 12px;
    text-transform: uppercase;
    text-shadow: 0 0 0 rgb(0 0 0 / 0%);
    font-weight: 400;
}
.io-menu-desktop a {
    display: block;
    -o-transition: none;
    -moz-transition: none;
    -webkit-transition: none;
    transition: none;
}
.io-menu-desktop > ul > li.current-menu-item > a, .io-menu-desktop > div > ul > li.current-menu-item > a {
    background: rgba(0, 0, 0, 0.01);
}



#colophon {
    margin-top: 70px;
    margin-bottom: 30px;
}
#colophon .site-info {
    text-align: center;
}

</style>


<header id="masthead" class="site-header row">
    <div class="site-branding col-sm-6">
        <span class="site-title" style="font-size: 2.2rem">
            <span>
                <img width="60px" height="60px"
                    src="https://sxm-upload.oss-cn-beijing.aliyuncs.com/imgs/16833443.jpg">
            </span>


            <a href="http://www.sunxvming.com/" rel="home">忧郁的大能猫</a>
        </span>
        <p class="site-description">好奇的探索者，理性的思考者，踏实的行动者。</p>
    </div><!-- .site-branding -->

    <nav id="site-navigation" class="main-navigation col-sm-9">
        <div class="io-menu io-menu-desktop"><span class="io-menu-button io-menu-button-span">≡</span>

            <div class="menu-%e4%b8%bb%e8%8f%9c%e5%8d%95-container">
                <ul id="primary-menu" class="menu">
                    <li id="menu-item-38"
                        class="menu-item menu-item-type-custom menu-item-object-custom current-menu-item current_page_item menu-item-home menu-item-38">
                        <a href="http://www.sunxvming.com">首页</a></li>
                    <li id="menu-item-175"
                        class="menu-item menu-item-type-post_type menu-item-object-page menu-item-175"><a
                            href="http://www.sunxvming.com/">所有文章</a></li>
                    <li id="menu-item-176"
                        class="menu-item menu-item-type-post_type menu-item-object-page menu-item-176"><a
                            href="http://www.sunxvming.com/blog/about-me.html">关于俺</a></li>
                </ul>
            </div>
        </div><!-- .io-menu -->
    </nav><!-- #site-navigation -->
</header>

<div id="header">
<h1 class="title">blog/A-IT/00-CS基础/80-软件实践/编码实践</h1>
</div> <!--id="header"-->
 <!--if(title)-->

<p>Table of Contents:</p>
<div id="TOC">
<ul>
<li><a href="#程序员的心理疾病">程序员的心理疾病</a>
<ul>
<li><a href="#无自知之明">无自知之明</a></li>
<li><a href="#垃圾当宝贝">垃圾当宝贝</a></li>
<li><a href="#以语言取人">以语言取人</a></li>
<li><a href="#分清精髓知识和表面知识不要太拿经验当回事">分清精髓知识和表面知识，不要太拿经验当回事</a></li>
<li><a href="#不要嚷着要别人写测试">不要嚷着要别人写测试</a></li>
</ul></li>
<li><a href="#杂项">杂项</a>
<ul>
<li><a href="#名言">名言</a></li>
<li><a href="#编码实践">编码实践</a></li>
<li><a href="#一个好的后台程序需要具备哪些功能">一个好的后台程序需要具备哪些功能</a></li>
<li><a href="#编程面对的问题">编程面对的问题</a></li>
<li><a href="#软件复杂度">软件复杂度</a></li>
<li><a href="#技术债务">技术债务</a></li>
</ul></li>
<li><a href="#源码阅读">源码阅读</a>
<ul>
<li><a href="#不懂一套源程序的主要原因">不懂一套源程序的主要原因</a></li>
<li><a href="#源码阅读的一些技巧方法">源码阅读的一些技巧、方法</a></li>
<li><a href="#cc">c、c++</a></li>
<li><a href="#其他小经验">其他小经验</a></li>
</ul></li>
<li><a href="#bug">bug</a>
<ul>
<li><a href="#通用">通用</a></li>
<li><a href="#编译问题">编译问题</a></li>
<li><a href="#函数调用错误">函数调用错误</a></li>
<li><a href="#c">c++</a></li>
<li><a href="#项目">项目</a></li>
<li><a href="#web框架常见错误">web框架常见错误</a></li>
<li><a href="#php常见错误">php常见错误</a></li>
</ul></li>
<li><a href="#debug">debug</a>
<ul>
<li><a href="#理解系统">1.理解系统</a></li>
<li><a href="#稳定复现bug">2.稳定复现bug</a></li>
<li><a href="#不要想而要看">3.不要想，而要看</a></li>
<li><a href="#分而治之">4.分而治之</a></li>
<li><a href="#一次只改一个地方">5.一次只改一个地方</a></li>
<li><a href="#保持审计跟踪">6.保持审计跟踪</a></li>
<li><a href="#检查插头">7.检查插头</a></li>
<li><a href="#寻求他人帮助">8.寻求他人帮助</a></li>
<li><a href="#如果你不修复bug它将依然存在">9.如果你不修复bug，它将依然存在</a></li>
</ul></li>
<li><a href="#测试">测试</a></li>
<li><a href="#开发功能的要点">开发功能的要点</a></li>
</ul>
</div>
 <!--if(toc)-->

<h1 id="程序员的心理疾病">程序员的心理疾病</h1>
<h2 id="无自知之明">无自知之明</h2>
<p>由于程序员的工作最近几年比较容易找，工资还不错，所以很多程序员往往只看到自己的肚脐眼，看不到自己在整个社会里的位置其实并不是那么的关键和重要。很多程序员除了自己会的那点东西，几乎对其它领域和事情完全不感兴趣，看不起其他人。<br />
这就是为什么我的前同事 TJ 作为一个资深的天体物理学家，在一个软件公司里面那么卑微。貌似会写点 node.js，iOS 软件的人都可以对他趾高气昂的样子，而其实这些东西的价值哪里可能跟 TJ 知道的物理知识相提并论。很多科学家其实都可以轻而易举的掌握程序员知道的那点东西。</p>
<h2 id="垃圾当宝贝">垃圾当宝贝</h2>
<p>其实软件里面有少数永恒的珍宝，可惜很少有人理解和尊重它们的价值。这在其它的工程领域看来是不可思议的，然而这却是事实。由于没有科学作为理论的基础，没有实验作为检验它们的标准，软件行业的很多东西就像现代艺术一样，丑陋无比的垃圾还能摆在外表堂皇的“现代艺术博物馆”里面，被人当成传世大作一样膜拜。</p>
<h2 id="以语言取人">以语言取人</h2>
<p>你的软件是什么语言写的，告诉别人的时候是千万要小心的，不到万不得已最好不要说。因为十有八九，对方会立即在心里对你的软件的价值做出判断，光凭你用的是什么语言。<br />
在这样一个行业里，你会很难找到一个只把程序语言或者技术当成是工具的人。如果有人问你对某个语言或者技术的评价，是非常尴尬甚至危险的事情，所以最可靠的办法就是不做评论，什么都不要说。</p>
<h2 id="分清精髓知识和表面知识不要太拿经验当回事">分清精髓知识和表面知识，不要太拿经验当回事</h2>
<p>在任何领域，都只有少数知识是精髓的，另外大部分都是表面的，肤浅的，是从精髓知识衍生出来的。精髓知识和表面知识都是有用的，然而它们的分量和重要性却是不一样的。所以必须区分精髓知识和表面知识，不能混为一谈，对待它们的态度应该是不一样的。由于表面知识基本是死的，而且很容易从精髓知识推导衍生出来。我们不应该因为自己知道很多表面知识，就自以为比掌握了精髓知识的人还要强。不应该因为别人不知道某些表面知识，就以为自己高人一等。</p>
<p>IT公司经常有这样的人，以为精通一些看似复杂的命令行，或者某些难用的程序语言就很了不起似的。</p>
<h2 id="不要嚷着要别人写测试">不要嚷着要别人写测试</h2>
<p>在很多程序员的脑子里，所谓的“流程”和“测试”，比真正解决问题的代码还重要。他们跟你说起这些，那真的叫正儿八经，义正言辞啊！所以有时候你很迷惑，这些人除了遵守这些按部就班的规矩，还知道些什么。大概没有能力的人都喜欢追究各种规矩吧，这样可以显得自己“没有功劳有苦劳”。这些人自己写的代码很平庸，不知道如何简单有效地解决困难的问题，却喜欢在别人提交代码让他review的时候叫喊：“测试很重要！覆盖很重要！你要再加一些测试才能通过我的review！”</p>
<h1 id="杂项">杂项</h1>
<p>学习时注意细节：包括推论的关键步骤，单词的拼写，代码的格式，</p>
<h2 id="名言">名言</h2>
<ul>
<li>If it's not tested, it doesn't work.</li>
<li>Just because you wrote it doesn't mean you own it — don't be offended if someone else on your team has to change your code.</li>
<li>Don't reinvent the wheel, library code is there to help.</li>
<li>Code that's hard to understand is hard to maintain.</li>
<li>Code that's hard to maintain is next to useless.</li>
<li>The neater your code layout, the easier it is to read. The easier it is to read, the easier it is to understand and maintain.</li>
<li>Code is not self documenting. Help others by adding comments to guide them. You may understand it now but what about in 5 years time?</li>
<li>Bad Code can and will come back to haunt you.</li>
<li>Magic numbers are bad.</li>
<li>If there is a bug, the user will find it.</li>
<li>It's not the quantity of code that matters, it's the quality. Any idiot can bang out 40kloc but that doesn't make it fit for purpose.</li>
<li>The true cost of poorly written code is in the maintenance.</li>
<li>Bad architecture causes more problems than bad code.</li>
<li>You will spend more time thinking than coding.</li>
<li>The best programmers are always building things.</li>
<li>There's always a better way.</li>
<li>Code reviews by your peers will make all of you better.</li>
<li>Fewer features for better code is always the right answer in the end.</li>
<li>If you want to feel important as a software developer, work at a tech company</li>
</ul>
<h2 id="编码实践">编码实践</h2>
<ul>
<li>"有效的程序员不应该浪费很多时间用于程序调试，他们应该一开始就不要把故障引入。----Dijkstra"</li>
<li>"程序测试是表明存在故障的非常有效的方法，但对于证明没有故障，调试是很无能为力的。-----Dijkstra"</li>
<li>代码应写一点测一点。便于调试。先简单再复杂，循环迭代。</li>
<li>var_dump对调试打印复杂类型很有用。</li>
<li>时刻备份。</li>
<li>建一个专用于测试的文件，小的函数，对象可在此测试，因为在大项目中不好看到其效果。</li>
<li>案头准备几本便签用于记录。a、工作计划  b、关于项目的笔记本 c、编写代码的草稿本 d、关于知识的笔记本</li>
<li>文件的编码要注意</li>
<li>sql语句用之前先试一试，字符型的要加引号，numeric fields should not be enclosed in quotes:</li>
<li>研究源代码时，碰到非常复杂的，可以用简单的代码进行测试。</li>
<li>网上的一些技术文章有的是过时的，想了解最新的就得去官网上看，英文的也要看</li>
<li>有的时候页面改了之后还是没变化，可增加输出强制刷新，添个alert</li>
<li>写前端代码时出现奇怪的现象了就多用几个浏览器试试，可能是浏览器的问题</li>
<li>写代码时可能会配合的画一些流程图之类的图，注意不同图形不同符号要代表不同的含义</li>
<li>代码的边界处很容易出错，要多加注意</li>
<li>php手册中有很多用户的代码的例子，很好，可作为一种代码资源</li>
<li>使用软件一定要查看其版本，以及版本之间的兼容性</li>
<li>编程的一个思路（数据结构加算法）：分析程序需要哪些数据，比如展示给用户的数据，得以让程序运行的数据，标记数据，等。再去想用什么形式结构去储存数据。</li>
<li>用php获得用户ip光用 $_SEVER['REMOTE_ADDR'];可能是不行的。还需考虑其他很多情况。</li>
<li>sql语句在写的时候注意在适当的位置断行，以增加可读性。</li>
<li>phpmyadmin有次变的非常的慢，最后才知道原来是xdebug安装之后才变的这么慢，去掉之后就好了，结论，xdebug很耗性能</li>
<li>看似复杂的东西，若一步一步分析，其实也没那末难，要抓住主要逻辑，细枝末节的可适当忽略</li>
<li>改的代码和显示的程序不一致，代码在怎么改也是没有用的，此种情况出现过好几次，要长记性。此种情况多出现在打开了多了编辑器最后都不知道自己改的是那个脚本程序了。</li>
<li>创建项目时要先设置字符集，这是一个好习惯</li>
<li>工程里要有一个测试的目录</li>
<li>用数字如 1 未使用  2 使用中  3 已使用  数字一不小心就会出错，还是用单词一看意思就明白好</li>
<li>接口要有扩展性，意思是需求变了又需要新的数据，此时接口依然能再添加数据</li>
<li>数据库改动了程序也会出问题，所以大的改动一定要通知其他人</li>
<li>代码中重要的输出可以打印出来</li>
<li>要杜绝出现这种 1  2，等毫无意义的数字，尤其是在判断里if params[:sid] == "all" &amp;&amp; @gm_order.server_all == 0 || params[:sid] != "all" &amp;&amp; @gm_order.server_all == 2</li>
<li>用自己了解的技术+巧妙的方法去解决未知的问题，比用自己不了解的技术（不知道实现原理，难以操控，）要好</li>
<li>废除的功能的代码要及时的删除，或把废弃的代码放到文件的最底部。数据库的废弃字段也要及时清理掉，要不到后期代码会走向无序的状态。这丫的是技术债务</li>
<li>程序的前置检查（包括格式，空，有悖逻辑的等等），这样就可以在程序的源头排除一些不必要的bug，就像在编译时的那样，有错误的编译就不能通过</li>
<li>有边界情况的时候，想到后就处理掉，或用注释记录起来，要不过后就可能忘掉了</li>
<li>程序肯定会用到一些全局变量，对象，这些变量可能是配置，开关，某个全局的功能等等，而且有些十分重要。怎么维护这个全局变量就是一个问题了，最好弄个文档，按类别划分这些全局变量，以便项目参与者能更快速的了解一些全局变量</li>
<li>时刻考虑边界情况和异常情况，比如数组是否越界，被除数是否为0</li>
<li>文档说明相关：应该在服务器的根目录下弄一个文件，文件中放着一个readme文件，文件记录了服务器安装了那些软件，软件的位置，和一些有用的目录的存放的位置</li>
<li>从小事做起，然后再扩展，我一边开发一边学习，同时新掌握的信息还可以用于解决方案中。复杂系统总是源于简单系统的演化</li>
<li>尽早地添加日志记录和错误处理。在开发新系统时，我做的第一件事就是添加日志和错误处理，因为这两者从一开始就非常有用。如果系统不能照常工作，那么你就需要知道程序中发生了什么——这是日志的作用。错误处理也是如此——错误和异常越早处理越好。</li>
</ul>
<h2 id="一个好的后台程序需要具备哪些功能">一个好的后台程序需要具备哪些功能</h2>
<ul>
<li>记录错误，并通知到相关人员</li>
<li>监控</li>
<li>重启</li>
<li>有整个的日志</li>
</ul>
<p>错误的容忍度的处理</p>
<h2 id="编程面对的问题">编程面对的问题</h2>
<p>编程要能通过计算机解决实际问题，比如使用什么数据结构和算法，即<strong>问题模式</strong>。<br />
编程是人，而且是大量人来进行的，所以它还必须解决语言代码模式和复用能力的问题。即软工问题。即<strong>设计模式</strong>。<br />
再者，编程跟语言有关，所以它必须首先解决语言复杂度问题，即语言的语法；比如 OO，即<strong>代码模式</strong>。</p>
<h2 id="软件复杂度">软件复杂度</h2>
<p>对于软件的复杂度，唯一有效的推测方法是依据经验。而且还不是时时都好用。作为一个程序员，我知道，根据我之前开发过的相似的功能特征，我可以估计出现在的这些功能特征各自要多少开发时间。然后，我把总时间加起来，这就得到了完成整个项目需要的大致时间。然而，事实情况中，每个项目在开发过程中都遇到二、三个瓶颈。这些瓶颈会肆意的消耗程序员的大量时间，你在遇到它们之前根本不会有所预见。它们会拖住整个项目，致使工期延后数周甚至数月。<br />
这篇经典论文的核心论述通常被解释为复杂的软件工程问题无法靠简单的答案来解决。<br />
次要和必要复杂度<br />
在该论述当中，讨论到了次要和必要复杂度的差异。所谓次要复杂度是指由人们本身所产生的问题，而这类型的问题是可以被解决的。譬如说，撰写和最佳化组合语言的复杂度就是属于次要的，它可以借由高阶程序语言如Java来取代。必要复杂度则是从软件本身要解决的问题衍生而来，并无法被移除。如果软件需要提供三十个不同的功能，那么这三十个功能都是必要的，这些功能都必须被实作出来。<br />
软件工程面临的问题在于我们已经清除了大部分的次要复杂度，而剩余的（主要复杂度）都无法改变。<br />
在移除次要复杂度中最大的进展也许要算是高阶语言的诞生，像是Fortran和Java。<br />
在欧洲中世纪的传说中，有一种叫"人狼"的妖怪，就是人面狼身。它们会讲人话，专在月圆之夜去袭击人类。而且传说中对"人狼"用一般的枪弹是不起作用的，普通子弹都伤不到也打不死它，只有一种用银子作成的特殊子弹才能把它杀死。Brooks在他最著名的随笔文章《No Silver Bullet》里引用了这个典故 ，说明在软件开发过程里是没有万能的终杀性武器的，只有各种方法综合运用，才是解决之道。而各种声称如何如何神奇的理论或方法，都不是能杀死"软件危机"这头人狼的银弹。他当时大胆声称并预言方法学家们10年之内绝找不到什么极好的的神奇银弹。他的文章发表后，被广泛引用，后来他的随笔结集成书，《人月神话》。从此，在软件界，银弹（Silver Bullet）成了一个通用的比拟流行开来。1975年所出版的《人月神话》—被称为软件工程圣经。</p>
<h2 id="技术债务">技术债务</h2>
<p>僵尸代码就因为各种原因如（有可能是程序库升级，老的接口不再使用。有可能是需求调整）导致的没用的、但却留在程序库中的代码。这样的代码没有任何其它程序会调用它，没有任何函数、对象引用它。<br />
死代码是应该删除的代码。没有用的代码也就是没有人维护的代码。最后将变成没有人知道它是有什么用处的代码。后来的人也开始不敢删除这样的代码，怕万一什么地方需要用到它。于是这样的死代码积累的越来越多。技术债务越来越重。健康的项目慢慢腐烂变质。最终没有人能维护。<br />
死代码应该及时大胆清除。即使错误了也是svn呢</p>
<h1 id="源码阅读">源码阅读</h1>
<h3 id="不懂一套源程序的主要原因">不懂一套源程序的主要原因</h3>
<ul>
<li>程序的业务逻辑不清楚</li>
<li>抽象惯用法</li>
<li>语法的惯用法</li>
<li>你不知道普通的语句是体现什么样的数据结构</li>
<li>你不知道普通的语句是体现什么样的算法</li>
<li>如何向现实问题靠近抽象并设计的</li>
</ul>
<h3 id="源码阅读的一些技巧方法">源码阅读的一些技巧、方法</h3>
<ul>
<li>有文档的先看文档，通过看文档文章了解每个文件是干什么用的</li>
<li>如果是c的项目，可以先看看makefile或cmake文件是咋写的，以及main函数的入口在哪里</li>
<li>先找到整个项目的入口，main函数</li>
<li>总体原则，自上而下的阅读步骤</li>
<li>不知道某个函数是如何被调用的，可以打个断点，然后查看调用堆栈</li>
<li>了解代码文件的结构和用途</li>
<li>刚开始时切记一行一行的读，这样会浪费大量的时间，而且只是看懂一小块的代码，应该抓住主要的点来看，看思路，看总体流程，不要拘泥于细节</li>
<li>if 的各个分支点</li>
<li>所循环的对象是什么</li>
<li>那些代码是处理错误用的，处理的又是什么错误</li>
<li>对一些函数，类，方法名可以望文生义，尽量的去猜他的含义，好的命名就应该这样的，这样可以快速提高阅读速度</li>
<li>抓住代码中的核心的 对象、变量，并跟踪其在代码中的变化</li>
<li>追踪的代码的层数不要太深，有时你只需知道这个黑箱的功能是什么，而不需要知道他的内部结构</li>
<li>追踪的代码时可以配合着程序的打印，这样可以知道代码都执行到哪里，执行了那些函数</li>
<li>断点跟踪也是一个很好的方法</li>
<li>打印关键的变量，数据结构，对象等</li>
<li>看似很长的代码可能其核心的算法和步骤就那么点，只要搞清楚核心的步骤就算读懂了大部分的代码</li>
</ul>
<p>很多人以为看大型项目可以提升自己，而没有看到大型项目不过是几十行核心代码的扩展，很多部分是低水平重复。几十行平庸甚至晦涩的代码，重复一万次，就成了几十万行。看那些低水平重复的部分，是得不到什么提升的。造就我今天的编程能力和洞察力的，不是几百万行的大型项目，而是小到几行，几十行之短的练习。不要小看了这些短小的代码，它们就是编程最精髓的东西。反反复复琢磨这些短小的代码，不断改进和提炼里面的结构，磨砺自己的思维。逐渐的，你的认识水平就超越了这些几百万行，让人头痛的项目。</p>
<h2 id="cc">c、c++</h2>
<ul>
<li>若代码中出现大量的宏定义，多半是用来批量生成格式性代码的，此时只需知道宏的输入和输出是什么就行。可以通过gcc -E预编译的方法查看宏生成的内容是什么</li>
<li>阅读类的时候，先看起继承关系，然后再看起构造函数，一般构造函数中都可以得到计较重要的东西</li>
</ul>
<h2 id="其他小经验">其他小经验</h2>
<p>3个人搭档做一个模块，每天要抽出一点时间来跟其他两位阐述自己的代码，这样可以使这三个人更加了解这个模块，也可以顺便再梳理下自己的思路，及相互监督的作用，以及完成之后可以让任何一个人来维护这个模块</p>
<p>项目是在原来的系统上开发的要问清客户原来的系统的优缺点，因为顾客会在新旧系统之间计较，不爽的地方会即刻发现</p>
<h1 id="bug">bug</h1>
<h2 id="通用">通用</h2>
<ul>
<li>拼写错误<br />
用查找的高亮来检查，静态检查一般也能发现这个错误</li>
<li>数组越界</li>
<li>循环语句没有留意边界条件</li>
<li>条件语句的分支没有做到不重不漏</li>
<li>除0</li>
<li>缓冲区溢出（buffer overflow）</li>
</ul>
<pre><code>void foo(char *str)
{
    char buf[10];
    strcpy(buf, str);
    ......
}</code></pre>
<ul>
<li>悬空指针</li>
<li>内存泄漏</li>
<li>if(x == 3) 写成 if(x = 3)</li>
<li>x = 3; 手抖了写成了 x == 3;</li>
<li>误删文件</li>
<li>不可重入函数的操作，同时修改了全局的变量，本质原因是异步操作，线程不安全</li>
<li>双层循环造成cpu消耗过大</li>
<li>函数参数错误<br />
单位不对：比如秒、毫秒</li>
<li>段错误<br />
每次崩溃都报段错误，而且每次错误的位置又都不太相同，错误又出在系统函数上。那gdb报错的位置不一定是真正出错的位置，可能是别的地方内存溢出了原因，需要具体的来看。</li>
<li>gdb启动和普通启动的表现不一样<br />
比如网络连接的时候</li>
</ul>
<h2 id="编译问题">编译问题</h2>
<p>如：编译的时候编译的是debug版本的，但是依赖的第三方库是release版本的，这种混合使用不同版本的库可能会导致程序闪退或出现各种异常。<br />
原因：<br />
1. <strong>不匹配的库版本</strong>: Release 版本的库和 Debug 版本的库通常是经过不同编译设置生成的，它们可能具有不同的符号、优化方式等。因此，当 debug 版本的程序尝试使用 release 版本的库时，可能会导致不匹配的符号、链接错误或其他不一致性，从而导致程序崩溃。</p>
<ol>
<li><strong>运行时错误</strong>: Debug 版本的程序可能会包含额外的调试信息或检查机制，而 release 版本的库可能没有这些信息或机制。这可能导致在调试信息不匹配的情况下出现未定义的行为，进而导致程序崩溃。</li>
</ol>
<h2 id="函数调用错误">函数调用错误</h2>
<p>fwrite(路径，模式）；w写模式，文件的内容就被删掉,追加得用a模式</p>
<h2 id="c">c++</h2>
<ul>
<li><p>类中的方法找不到符号，看看是不是命名空间有问题，方法实现中是不是忘了加类名</p></li>
<li><p>别在遍历容器的时候进行删除操作，这相当于埋了个不定时炸弹</p></li>
</ul>
<h2 id="项目">项目</h2>
<p>计算向量的垂直向量时，原向量 vector2D(b.x-a.x, b.y-a.y), 少加了括号误写成 vector2D(-b.y-a.y, b.x-a.x,), 应该是vector2D(-(b.y-a.y), b.x-a.x,),</p>
<h2 id="web框架常见错误">web框架常见错误</h2>
<ul>
<li>框架运行报错，查看日志等是否有写权限</li>
<li>图片上传错误，查看上传目录是否有写权限</li>
</ul>
<h2 id="php常见错误">php常见错误</h2>
<p><strong>查看php错误日志</strong><br />
php配置文件、错误日志位置可以从php_info中看到</p>
<p><strong>php本身错误</strong><br />
某些函数找不到，可能是没有安装相应的模块。<br />
安装了相应的模块还是不生效，那就再重启下php-fpm，之后模块就可以找到了。</p>
<p><strong>php数组占用过多内存空间</strong></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode php"><code class="sourceCode php"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">$startMemory</span> = <span class="fu">memory_get_usage</span><span class="ot">();</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="kw">$array</span> = <span class="fu">range</span><span class="ot">(</span><span class="dv">1</span><span class="ot">,</span> <span class="dv">100000</span><span class="ot">);</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="kw">echo</span> <span class="fu">memory_get_usage</span><span class="ot">()</span> - <span class="kw">$startMemory</span><span class="ot">,</span> <span class="st">&#39; bytes&#39;</span><span class="ot">;</span></span></code></pre></div>
<p>How much would you expect it to be? Simple, one integer is 8 bytes and you got 100000 integers, so you obviously will need 800000 bytes. That’s something like 0.76 MBs.<br />
but this gives me 14649024 bytes. Yes, you heard right, that’s 13.97 MB - 18 times more than we estimated.<br />
因为要存其他额外的信息，所以多了很多其他的空间，就是c要实现数组结构要维护其他很多的额外信息</p>
<p><strong>foreach循环后留下悬挂指针</strong><br />
在foreach循环中，如果我们需要更改迭代的元素或是为了提高效率，运用引用是一个好办法：php的引用</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode php"><code class="sourceCode php"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">$arr</span> = <span class="kw">array</span><span class="ot">(</span><span class="dv">1</span><span class="ot">,</span> <span class="dv">2</span><span class="ot">,</span> <span class="dv">3</span><span class="ot">,</span> <span class="dv">4</span><span class="ot">);</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a><span class="kw">foreach</span> <span class="ot">(</span><span class="kw">$arr</span> <span class="kw">as</span> &amp;<span class="kw">$value</span><span class="ot">)</span> {</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a> <span class="kw">$value</span> = <span class="kw">$value</span> * <span class="dv">2</span><span class="ot">;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>}</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a><span class="co">// $arr is now array(2, 4, 6, 8)</span></span></code></pre></div>
<p>这里有个问题很多人会迷糊。循环结束后，<code>$value</code>并未销毁，<code>$value</code>其实是数组中最后一个元素的引用，这样在后续对<code>$value</code>的使用中，如果不知道这一点，会引发一些莫名奇妙的错误:)</p>
<p>避免这种错误最好的办法就是在循环后立即用unset函数销毁变量：</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode php"><code class="sourceCode php"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">$arr</span> = <span class="kw">array</span><span class="ot">(</span><span class="dv">1</span><span class="ot">,</span> <span class="dv">2</span><span class="ot">,</span> <span class="dv">3</span><span class="ot">,</span> <span class="dv">4</span><span class="ot">);</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="kw">foreach</span> <span class="ot">(</span><span class="kw">$arr</span> <span class="kw">as</span> &amp;<span class="kw">$value</span><span class="ot">)</span> {</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>    <span class="kw">$value</span> = <span class="kw">$value</span> * <span class="dv">2</span><span class="ot">;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>}</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a><span class="kw">unset</span><span class="ot">(</span><span class="kw">$value</span><span class="ot">);</span> <span class="co">// $value no longer references $arr[3]</span></span></code></pre></div>
<h1 id="debug">debug</h1>
<ul>
<li>善用assert，这会自动帮你检查一些意外的情况</li>
<li>善于记录和打印日志，在写功能的时候就尽量写全，写清晰，不然运行程序后发现没有再添加就会很影响效率<br />
比如以下的log当只有一个用户登陆问题没问题，但用户多了之后就完全没意思了，需加上更多的信息</li>
</ul>
<pre><code>log(&quot;last login time : %d&quot;, last_login_time);</code></pre>
<ul>
<li>不知道某个函数是如何被调用的，可以打个断点，然后查看调用堆栈</li>
</ul>
<p>查程序崩溃<br />
Qt下程序崩溃，但是没有崩溃时的堆栈<br />
若出现崩溃错误，一定要消灭在萌芽中，不可放任不管，因为在刚发现时，往往知道是修改那个功能出现的崩溃，拖得越久，越难以确定崩溃的范围</p>
<p>查找步骤：<br />
1. 查找稳定复现的方法<br />
2. 在代码中加打印，从大范围，到小范围确定出问题的代码段<br />
3. 锁定可疑的代码，如系统调用，容器越界，容器删除等操作<br />
4. 修改可疑代码，验证是否解决</p>
<h2 id="理解系统">1.理解系统</h2>
<p>即在调试之前，需要先搞明白系统的运作方式。包括并不限于阅读文档，阅读源码，寻找熟悉系统的同事交流。</p>
<p>然而现实中（尤其互联网公司）大多是 band-aid fix：改两行，似乎能 work 了，宣布 fix，几周之后搞出更大的问题——这就是暗坑的来源。</p>
<p>理解了你自己的系统后，还会获得一个额外的好处。当你找到bug时，必须在不破坏其他地方的前提下修复它们。理解系统行为是不破坏系统的第一步。理解了系统之后，你会明白什么是对的，什么是错的——</p>
<h2 id="稳定复现bug">2.稳定复现bug</h2>
<p>为了修复 bug，我们需要找到引发 bug 的条件，确保可以有规律的重现 bug，接下来才是修复：当问题没有修复时，如果你执行 X 操作，失败率为100%；在修复问题后，再执行 X 操作，如果失败率为0，那么你知道bug确实已被修复。<br />
为了有规律的重现 bug，我们应该想办法制造/增加 bug 出现的条件。如果车胎漏气，我们可以把车胎放在肥皂水里，寻找气泡。</p>
<h2 id="不要想而要看">3.不要想，而要看</h2>
<p>如果你不能留意实际情况发生的全过程，那么你极有可能曲解很多问题。你猜测某个地方出了问题，于是修复它，但实际上错误发生在另一个地方。<br />
由于你没有看到一个字节发生了改变，导致用错误的参数调用了一个子例程，或者一个队列溢出，而你却去修复了一个完全没有发生错误的地方。这样，你不仅没有修复问题，而且还可能改变了时序，因此把问题隐藏起来了，这会使你误认为已修复问题。<br />
一定要亲眼看到错误是如何发生的。观察往往比猜测能更快的找到问题：因为猜测虽然看起来是捷径，但这条捷径并不会带你找到问题的根源。</p>
<h2 id="分而治之">4.分而治之</h2>
<p>通过反复地把问题分成好的一半和坏的一半，来缩小搜索范围，然后进一步研究有问题的那一半。</p>
<h2 id="一次只改一个地方">5.一次只改一个地方</h2>
<p>1.这叫控制变量法，每次只控制一个变量才能确定次变量对系统的影响<br />
2.如果你所做的更改没有起到预期的作用，那么就把它改回来。它们可能会产生无法预料的影响。</p>
<h2 id="保持审计跟踪">6.保持审计跟踪</h2>
<p>很多 bug 都可以通过查阅 revision history 或观看 repro video 来解决。</p>
<h2 id="检查插头">7.检查插头</h2>
<p>当电器出现问题的时候，应该问自己一个古老的、看似愚蠢的问题：“插头插上了吗？”虽然这个问题看上去很愚蠢，但它经常发生。<br />
有时错误的原因在于 typo：你以为你在 getItem，但实际在 getItems。这种问题在 dynamic typed language 里面尤其常见。</p>
<h2 id="寻求他人帮助">8.寻求他人帮助</h2>
<p>与其自己与 bug 死扛，不如去寻求同事的帮助：</p>
<p>别人寻求帮助至少有3个原因（还不算把整个问题甩给别人）：获得全新观点、专业知识和经验。而且，人们通常很愿意帮忙，因为这给了他们一个证明自己很聪明的机会。</p>
<p>我们按照自己老一套的思路是很难看清全局的。我们都是普通人，对任何事情都有偏见，包括对bug隐藏在哪里的看法。这些偏见可能导致我们无法看清实际情况。而其他人则会从一个无偏见的角度来看问题（实际上他们只是有另一种不同的偏见），这可能会给我们很大的启发，帮助找到新的方法。</p>
<p>即使无法从他们那里得到帮助，他们也可以安慰你一下，告诉你这个问题真是一个非常棘手的问题，也可以借给你肩膀靠一靠。</p>
<p>无论你想要获得什么样的帮助，在向别人描述问题的时候，一定要记住一件事：报告症状，而不要讲你的理论。之所以要从别人那里获得全新的观点，就是因为你的理论起不到任何作用。如果你找了一个人，把你的理论告诉他，那么也会把他拉到你原来的思维定式中。</p>
<h2 id="如果你不修复bug它将依然存在">9.如果你不修复bug，它将依然存在</h2>
<p>当你认为你已经修复了一个设计问题时，取消这个修复，确定系统再次失败。然后再应用这个修复，再次验证问题已修复。直到你经过从修复到失败，再从失败到修复这个过程之后（只应用和取消修复，而不改变其他地方），才能够证明你确实已经修复了问题。</p>
<h1 id="测试">测试</h1>
<p>一个函数的实现要调用另一个没用完成对函数，可以写一个假的函数来模拟</p>
<p>Error codes should also be accompanied by descriptive error messages. However, only in rare circumstances should the error message try to predict why the error occurred. It should simply relate what happened</p>
<h1 id="开发功能的要点">开发功能的要点</h1>
<p>主要逻辑<br />
疑问处<br />
数据库<br />
程序文件<br />
配置文件<br />
注意点<br />
UI<br />
未完成<br />
已通过<br />
收获<br />
线上出的问题<br />
gm命令<br />
时间富裕的情况下的优化<br />
测试要点</p>

<footer id="colophon" >
		<div class="site-info col">
			Powered by <a href="https://github.com/sunxvming/my-blog">my-blog</a>
			<span class="sep"> | </span>
				<span><a target="_blank" href="http://beian.miit.gov.cn">【京ICP备19018538号】</a></span>
			<span><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11010502037753">【京公网安备 11010502037753号】</a></span>
		</div><!-- .site-info col -->
        <div class="site-info col"> This page is hosted at <a target="_blank" href="https://github.com/sunxvming">Github</a>.To see the source code you can visit the <a target="_blank" href="https://github.com/sunxvming/my-blog">repo</a> and I'd be glad if you like and star it.</div>
</footer>
</div> <!--wrapper-->
</body>
</html>
