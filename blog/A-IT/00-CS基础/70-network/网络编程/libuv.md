Libevent、libev、libuv三个网络库，都是c语言实现的异步事件库

* libevent
名气最大，应用最广泛，历史悠久的跨平台事件库；
* libev
较libevent而言，设计更简练，性能更好，但对Windows支持不够好；
* libuv
开发node的过程中需要一个跨平台的事件库，他们首选了libev，但又要支持Windows，故重新封装了一套，linux下用libev实现，Windows下用IOCP实现；

## Libuv 基础
Libuv是一个高性能的，事件驱动的异步I/O库，它本身是由C语言编写的，具有很高的可移植性。libuv封装了不同平台底层对于异步IO模型的实现，所以它还本身具备着跨平台能力。

### 事件循环(Event loops)
事件驱动编程模型的伪代码如下:
```c
while there are still events to process:
    e = get the next event
    if there is a callback associated with e:
        call the callback
```


适用于事件驱动编程模型的例子如下:
* 文件已经准备好可写入数据.
* 某一 socket 上存在数据可读.
* 定时器已超时.


计算机程序最基本的活动是输入输出的处理, 而不是大量的数值计算, 而使用传统输入输出函数(read, fprintf 等)的问题是它们都是 **阻塞** 的. 将数据写入磁盘或者从网络读取数据都会消耗大量时间, 而阻塞函数直到任务完成后才返回, 在此期间你的程序什么也没有做, 浪费了大量的 CPU 时间. 对于追求高性能的程序而言, 在其他活动或者 I/O 操作在进行尽量让 CPU 不被阻塞.

Libuv 采用另外一种方式处理阻塞任务, 即 **异步** 和 **非阻塞** 方式.大多数现代**操作系统都提供了事件通知功能**, 例如, 调用 read 读取网络套接字时程序会阻塞, 直到发送者最终发送了数据(read 才返回). 但是, 应用程序可以要求操作系统监控套接字, 并在套接字上注册事件通知. 应用程序可以在适当的时候查看它所监视的事件并获取数据(若有). 
整个过程是 **异步** 的, 因为程序在某一时刻关注了它感兴趣的事件, 并在另一个时刻获取(使用)数据, 这也是 **非阻塞** 的, 因为该进程还可以处理另外的任务. 

## 参考链接
- [libuv 中文编程指南(零)前言](https://www.cnblogs.com/haippy/archive/2013/03/17/2963995.html)