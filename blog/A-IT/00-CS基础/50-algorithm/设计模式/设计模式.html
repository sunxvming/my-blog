<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta name="generator" content="pandoc" />



<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<link rel="stylesheet" href="../../../../.././css/style.css" />




<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Saira+Semi+Condensed%3A400%2C700&ver=4.9.18" type="text/css" />

<script src="https://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
<script>
jQuery(document).ready(function(){
    jQuery('pre').each(function(){
        var el = jQuery(this).find('code');
        var code_block = el.html(); 
 
        if (el.length > 0) { 
            jQuery(this).addClass('prettyprint').html(code_block).attr('style', 'max-height:450px');
        } else { 
            jQuery(this).removeClass().addClass('prettyprint'); 
        }
    });
});
</script>

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js?skin=desert"></script>

</head>


<body>
<div id="wrapper">


<style type="text/css">

#masthead .site-branding {
    margin-bottom: 7px;
}

#masthead .site-branding .site-title {
    font-size: 2.2rem;
    line-height: 1;
    text-transform: uppercase;
    margin: 0;
    margin-bottom: 0.5rem;
}


#masthead .site-description{
	margin:0px;
}




#masthead .site-branding .site-title a {
    display: inline-block;
    position: relative;
    top: -11px;
}

#masthead  a {
    <!-- color: #007bff; -->
    text-decoration: none;
    background-color: transparent;
}



.io-menu-desktop {
    display: block;
    text-align: right;
}
.io-menu-desktop span.io-menu-button-span {
    display: none;
}
.io-menu-desktop ul {
    padding: 0;
    margin: 0;
    list-style: none;
    background: transparent;
    display: block;
}
.io-menu-desktop ul > li {
    margin-right: -4px;
    display: inline-block;
    position: relative;
    height: 30px;
    color: #212529;
    font-size: 12px;
    text-transform: uppercase;
    text-shadow: 0 0 0 rgb(0 0 0 / 0%);
    font-weight: 400;
}
.io-menu-desktop ul > li > a {
    padding: 0;
    line-height: 29px;
    padding-left: 20px;
    padding-right: 20px;
    padding-top: 1px;
    color: #212529;
    font-size: 12px;
    text-transform: uppercase;
    text-shadow: 0 0 0 rgb(0 0 0 / 0%);
    font-weight: 400;
}
.io-menu-desktop a {
    display: block;
    -o-transition: none;
    -moz-transition: none;
    -webkit-transition: none;
    transition: none;
}
.io-menu-desktop > ul > li.current-menu-item > a, .io-menu-desktop > div > ul > li.current-menu-item > a {
    background: rgba(0, 0, 0, 0.01);
}



#colophon {
    margin-top: 70px;
    margin-bottom: 30px;
}
#colophon .site-info {
    text-align: center;
}

</style>


<header id="masthead" class="site-header row">
    <div class="site-branding col-sm-6">
        <span class="site-title" style="font-size: 2.2rem">
            <span>
                <img width="60px" height="60px"
                    src="https://sxm-upload.oss-cn-beijing.aliyuncs.com/imgs/16833443.jpg">
            </span>


            <a href="http://www.sunxvming.com/" rel="home">忧郁的大能猫</a>
        </span>
        <p class="site-description">好奇的探索者，理性的思考者，踏实的行动者。</p>
    </div><!-- .site-branding -->

    <nav id="site-navigation" class="main-navigation col-sm-9">
        <div class="io-menu io-menu-desktop"><span class="io-menu-button io-menu-button-span">≡</span>

            <div class="menu-%e4%b8%bb%e8%8f%9c%e5%8d%95-container">
                <ul id="primary-menu" class="menu">
                    <li id="menu-item-38"
                        class="menu-item menu-item-type-custom menu-item-object-custom current-menu-item current_page_item menu-item-home menu-item-38">
                        <a href="http://www.sunxvming.com">首页</a></li>
                    <li id="menu-item-175"
                        class="menu-item menu-item-type-post_type menu-item-object-page menu-item-175"><a
                            href="http://www.sunxvming.com/">所有文章</a></li>
                    <li id="menu-item-176"
                        class="menu-item menu-item-type-post_type menu-item-object-page menu-item-176"><a
                            href="http://www.sunxvming.com/blog/about-me.html">关于俺</a></li>
                </ul>
            </div>
        </div><!-- .io-menu -->
    </nav><!-- #site-navigation -->
</header>

<div id="header">
<h1 class="title">blog/A-IT/00-CS基础/50-algorithm/设计模式/设计模式</h1>
</div> <!--id="header"-->
 <!--if(title)-->

<p>Table of Contents:</p>
<div id="TOC">
<ul>
<li><a href="#软件设计模式概述">软件设计模式概述</a>
<ul>
<li><a href="#软件设计模式的基本要素">软件设计模式的基本要素</a></li>
</ul></li>
<li><a href="#创建型模式">创建型模式</a>
<ul>
<li><a href="#单例模式">单例模式</a>
<ul>
<li><a href="#懒汉式">懒汉式</a></li>
<li><a href="#饿汉式">饿汉式</a></li>
</ul></li>
<li><a href="#工厂模式">工厂模式</a>
<ul>
<li><a href="#简单工厂模式">简单工厂模式</a></li>
<li><a href="#工厂方法模式">工厂方法模式</a></li>
<li><a href="#抽象工厂">抽象工厂</a></li>
</ul></li>
</ul></li>
<li><a href="#模板模式">模板模式</a></li>
<li><a href="#策略模式">策略模式</a></li>
<li><a href="#观察者模式">观察者模式</a></li>
<li><a href="#visitor-模式">Visitor 模式</a></li>
<li><a href="#享元模式">享元模式</a></li>
<li><a href="#代理模式-proxy模式">代理模式 PROXY模式</a></li>
<li><a href="#适配器模式-adapter">适配器模式 Adapter</a></li>
<li><a href="#状态机模式">状态机模式</a></li>
<li><a href="#责任链模式">责任链模式</a></li>
</ul>
</div>
 <!--if(toc)-->

<h2 id="软件设计模式概述">软件设计模式概述</h2>
<p>《设计模式：可复用面向对象软件的基础》（Design Patterns: Elements of Reusable Object-Oriented Software）一书，在本教程中收录了 23 个设计模式，这是设计模式领域里程碑的事件，导致了软件设计模式的突破。这 4 位作者在软件开发领域里也以他们的“四人组”（Gang of Four，GoF）匿名著称。<br />
设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。</p>
<h3 id="软件设计模式的基本要素">软件设计模式的基本要素</h3>
<ol>
<li><p>模式名称</p></li>
<li><p>问题<br />
描述了该模式的应用环境，即何时使用该模式</p></li>
<li><p>解决方案</p></li>
<li><p>效果<br />
描述了模式的应用效果以及使用该模式应该权衡的问题，即模式的优缺点。主要是对时间和空间的衡量，以及该模式对系统的灵活性、扩充性、可移植性的影响，也考虑其实现问题。</p>
<h2 id="gof-的-23-种设计模式的分类和功能">GoF 的 23 种设计模式的分类和功能</h2>
<p>设计模式有两种分类方法，即根据模式的目的来分和根据模式的作用的范围来分。</p></li>
<li><p>根据目的来分<br />
根据模式是用来完成什么工作来划分，这种方式可分为创建型模式、结构型模式和行为型模式 3 种。</p></li>
</ol>
<ul>
<li>创建型模式：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF 中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。</li>
<li>结构型模式：用于描述如何将类或对象按某种布局组成更大的结构，GoF 中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。</li>
<li>行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。GoF 中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。</li>
</ul>
<ol>
<li>根据作用范围来分<br />
根据模式是主要用于类上还是主要用于对象上来分，这种方式可分为类模式和对象模式两种。</li>
</ol>
<ul>
<li><p>类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。GoF中的工厂方法、（类）适配器、模板方法、解释器属于该模式。</p></li>
<li><p>对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。GoF 中除了以上 4 种，其他的都是对象模式。</p>
<h2 id="uml中的类图及类图之间的关系">UML中的类图及类图之间的关系</h2>
<h3 id="统一建模语言简介">统一建模语言简介</h3>
<p>统一建模语言（Unified Modeling Language，UML）是用来设计软件蓝图的可视化建模语言.<br />
UML 从目标系统的不同角度出发，定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图等 9 种图。</p>
<h3 id="类之间的关系">类之间的关系</h3>
<p>在软件系统中，类不是孤立存在的，类与类之间存在各种关系。根据类与类之间的耦合度从弱到强排列</p></li>
</ul>
<ol>
<li><p>依赖关系<br />
依赖（Dependency）关系是一种使用关系，在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。</p></li>
<li><p>关联关系<br />
关联（Association）关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。<br />
在代码中通常将一个类的对象作为另一个类的成员变量来实现关联关系。</p></li>
<li><p>聚合关系<br />
聚合（Aggregation）关系是关联关系的一种，是强关联关系，是整体和部分之间的关系，是 has-a 的关系。<br />
聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。<br />
4.组合关系<br />
组合（Composition）关系也是关联关系的一种，也表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系，是 contains-a 关系。<br />
在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。<br />
5.泛化关系<br />
泛化（Generalization）关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系，是 is-a 的关系。<br />
6.实现关系<br />
实现（Realization）关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。</p>
<h2 id="面向对象设计原则">面向对象设计原则</h2>
<h3 id="开闭原则的定义">1.开闭原则的定义</h3>
<p>软件实体应当对扩展开放，对修改关闭（Software entities should be open for extension，but closed for modification）<br />
这里的软件实体包括以下几个部分：1.项目中划分出的模块 2.类与接口 3.方法<br />
开闭原则的含义是：当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。</p>
<h3 id="里氏替换原则">2.里氏替换原则</h3>
<p>继承必须确保超类所拥有的性质在子类中仍然成立（Inheritance should ensure that any property proved about supertype objects also holds for subtype objects）<br />
里氏替换原则主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。<br />
里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。<br />
里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。</p>
<h3 id="依赖倒置原则">3.依赖倒置原则</h3>
<p>依赖倒置原则的原始定义为：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。其核心思想是：<strong>要面向接口编程，不要面向实现编程</strong><br />
依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。<br />
由于在软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。这里的抽象指的是接口或者抽象类，而细节是指具体的实现类。<br />
依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性，所以我们在实际编程中只要遵循以下4点，就能在项目中满足这个规则。<br />
每个类尽量提供接口或抽象类，或者两者都具备。<br />
变量的声明类型尽量是接口或者是抽象类。<br />
任何类都不应该从具体类派生。<br />
使用继承时尽量遵循里氏替换原则。</p>
<h3 id="单一职责原则">4.单一职责原则</h3>
<p>该原则提出对象不应该承担太多职责，否则类应该被拆分,如果一个对象承担了太多的职责，至少存在以下两个缺点：</p></li>
<li><p>一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；</p></li>
<li><p>当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。<br />
单一职责原则的核心就是控制类的粒度大小、将对象解耦、提高其内聚性。</p>
<h3 id="接口隔离原则的定义">5.接口隔离原则的定义</h3>
<p>接口隔离原则（Interface Segregation Principle，ISP）要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。<br />
要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用</p>
<h3 id="迪米特法则">6.迪米特法则</h3>
<p>迪米特法则又叫作最少知识原则：只与你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。<br />
迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</p>
<h3 id="合成复用原则">7.合成复用原则</h3>
<p>合成复用原则（Composite Reuse Principle，CRP）又叫组合/聚合复用原则（Composition/Aggregate Reuse Principle，CARP）。它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。<br />
如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。</p></li>
</ol>
<h2 id="创建型模式">创建型模式</h2>
<p>创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。</p>
<h3 id="单例模式">单例模式</h3>
<h4 id="懒汉式">懒汉式</h4>
<pre><code>class Singleton
{
public:
    static Singleton* GetInstance()
    {
         if ( inst == NULL )
             inst = new Singleton();
         return inst;
    }
private:
    Singleton(){};
    static Singleton * inst;</code></pre>
<h4 id="饿汉式">饿汉式</h4>
<pre><code>class Singleton
{
private:
    Singleton(){}
    static Singleton * inst;
public:
    static Singleton * GetInstance()
    {
        return inst;
    }
};
Singleton::inst = new Singleton()</code></pre>
<h3 id="工厂模式">工厂模式</h3>
<h4 id="简单工厂模式">简单工厂模式</h4>
<p>缺点是当新增产品的时候就要去修改工厂的类，这就违反了开放封闭原则，(类、模块、函数)可以扩展，但是不可以修改</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
class Product
{
public:
    virtual void show() = 0;
};

class Product_A : public Product
{
public:
    void show()
    {
        cout &lt;&lt; &quot;Product_A&quot; &lt;&lt; endl;
    }
};

class Product_B : public Product
{
public:
    void show()
    {
        cout &lt;&lt; &quot;Product_B&quot; &lt;&lt; endl;
    }
};

class Factory
{
public:
    Product* Create(int i)
    {
        switch (i)
        {
        case 1:
            return new Product_A;
            break;
        case 2:
            return new Product_B;
            break;
        default:
            break;
        }
    }
};
int main()
{
    Factory *factory = new Factory();
    factory-&gt;Create(1)-&gt;show();
    factory-&gt;Create(2)-&gt;show();
    system(&quot;pause&quot;);
    return 0;
}</code></pre>
<h4 id="工厂方法模式">工厂方法模式</h4>
<p>所谓工厂方法模式，是指定义一个用于创建对象的接口，让子类决定实例化哪一个类。打个比方现在有A、B两种产品，那么就开两个工厂。工厂A负责生产A产品，工厂B负责生产B种产品。<br />
工厂方法模式的主要角色如下：<br />
抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。<br />
具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。<br />
抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。<br />
具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</p>
<pre><code>#include &quot;stdafx.h&quot;
#include&lt;iostream&gt;
using namespace std;
class Product
{
public:
    virtual void show() = 0;
};
class Product_A : public Product
{
public:
    void show()
    {
        cout &lt;&lt; &quot;Product_A&quot; &lt;&lt; endl;
    }
};
class Product_B : public Product
{
public:
    void show()
    {
        cout &lt;&lt; &quot;Product_B&quot; &lt;&lt; endl;
    }
};

class Factory
{
public:
    virtual Product* create() = 0;
};
class Factory_A : public Factory
{
public:
    Product* create()
    {
        return new Product_A;
    }
};
class Factory_B : public Factory
{
public:
    Product* create()
    {
        return new Product_B;
    }
};

int main()
{
    Factory_A* productA = new Factory_A();
    Factory_B* productB = new Factory_B();
    productA-&gt;create()-&gt;show();
    productB-&gt;create()-&gt;show();
    system(&quot;pause&quot;);
    return 0;
}</code></pre>
<h4 id="抽象工厂">抽象工厂</h4>
<p>抽象工厂模式的扩展有一定的“开闭原则”倾斜性：<br />
当增加一个新的产品族时只需增加一个新的具体工厂，不需要修改原代码，满足开闭原则。<br />
当产品族中需要增加一个新种类的产品时，则所有的工厂类都需要进行修改，不满足开闭原则。<br />
另一方面，当系统中只存在一个等级结构的产品时，抽象工厂模式将退化到工厂方法模式,其实俩都差不多。</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
//定义抽象类
class product1
{
public:
    virtual void show() = 0;
};
//定义具体类
class product_A1 :public product1
{
public:
    void show(){ cout &lt;&lt; &quot;product A1&quot; &lt;&lt; endl; }
};
class product_B1 :public product1
{
public:
    void show(){ cout &lt;&lt; &quot;product B1&quot; &lt;&lt; endl; }
};

//定义抽象类
class product2
{
public:
    virtual void show() = 0;
};
//定义具体类
class product_A2 :public product2
{
public:
    void show(){ cout &lt;&lt; &quot;product A2&quot; &lt;&lt; endl; }
};
class product_B2 :public product2
{
public:
    void show(){ cout &lt;&lt; &quot;product B2&quot; &lt;&lt; endl; }
};

class Factory
{
public:
    virtual product1 *creat1() = 0;
    virtual product2 *creat2() = 0;
};
class FactoryA
{
public:
    product1 *creat1(){ return new product_A1(); }
    product2 *creat2(){ return new product_A2(); }
};
class FactoryB
{
public:
    product1 *creat1(){ return new product_B1(); }
    product2 *creat2(){ return new product_B2(); }
};
//===================
int main()
{
    FactoryA *factoryA = new FactoryA();
    factoryA-&gt;creat1()-&gt;show();
    factoryA-&gt;creat2()-&gt;show();
    FactoryB *factoryB = new FactoryB();
    factoryB-&gt;creat1()-&gt;show();
    factoryB-&gt;creat2()-&gt;show();
    return 0;
}</code></pre>
<h2 id="模板模式">模板模式</h2>
<p>在日常的开发中，经常遇到的场景是，这样的库对使用者不是很友好，如果多次在不同的地方用到这个库，则需要写好多次重复的模板代码：</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>{</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>    library lib();         <span class="co">// 框架层逻辑</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>    application app();     <span class="co">// 应用层逻辑</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>    lib.step1();</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>    lib.step2();</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a>    <span class="cf">if</span>(app.step3())</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>    {</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a>        lib.step4();</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a>        app.step5();</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a>    }</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true"></a></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true"></a>    <span class="co">// xxx</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true"></a>}</span></code></pre></div>
<p>如果把代码写成下面的样子，看看会不会更好？</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="kw">class</span> library</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>{</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>    <span class="kw">public</span>:</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>        <span class="dt">void</span> step1();</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>        <span class="dt">void</span> step2();</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a>        <span class="dt">void</span> step3();</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>        <span class="co">// 提供给app实现</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>        <span class="kw">virtual</span> <span class="dt">void</span> step3() = <span class="dv">0</span>;</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a>        <span class="kw">virtual</span> <span class="dt">void</span> step5() = <span class="dv">0</span>;</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a>        <span class="co">// 逻辑</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true"></a>        <span class="dt">void</span> run()</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true"></a>        {</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true"></a>            step1();</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true"></a>            step2();</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true"></a></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true"></a>            <span class="cf">if</span>(step3())</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true"></a>            {</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true"></a>                step4();</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true"></a>                step5();</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true"></a>            }</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true"></a>        }</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true"></a>};</span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true"></a></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true"></a><span class="kw">class</span> app : <span class="kw">public</span> library</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true"></a>{</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true"></a>    <span class="kw">public</span>:</span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true"></a>        <span class="dt">void</span> step3()</span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true"></a>        {</span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true"></a>            <span class="co">// dosomething </span></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true"></a>        }</span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true"></a></span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true"></a>        <span class="dt">void</span> step5()</span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true"></a>        {</span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true"></a>            <span class="co">// dosomething</span></span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true"></a>        }</span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true"></a>};</span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true"></a></span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true"></a><span class="dt">int</span> main()</span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true"></a>{</span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true"></a>    app myApp; <span class="co">// 直接声明一个派生类对象</span></span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true"></a>    library &amp;lib = myApp; <span class="co">// 使用基类引用来实现多态</span></span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true"></a>    lib.run();</span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true"></a>}</span></code></pre></div>
<p>对比一下，这样的好处是：<br />
lib层面提供抽象的接口，step3(), step5()，继承的app类可以提供自己的实现。这样对于频繁的变化的app类，修改自己实现的step3，step5函数即可。<br />
这样可能更加符合基本的设计原则，开放封闭原则 和 依赖倒置原则（依赖于抽象而不是依赖于具体）。<br />
实际上，在现在的各种框架里面都可以看到这样的影子。lib层面在开发的层面上，已经提供了相关的逻辑的接口，app层面只需要继承这个接口，实现里面的逻辑即可。</p>
<h2 id="策略模式">策略模式</h2>
<p>策略模式使用的一个常见的场景：</p>
<p>如果你的代码里面有大量的if-else, switch-case, 那么可能是一个需要考虑策略模式了。</p>
<pre><code>int main()
{
    if (type == &quot;中国&quot;)
    {
        // 使用中国的方式计算税务
    }
    else if (type == &quot;美国&quot;)
    {
        // 使用美国的方式计算税务
    }
    else if (type == &quot;xxx&quot;)
    {
        // 其他xxx
    }
    else
    {
        // 其他
    }
}</code></pre>
<p>这是一种看起来具有 “坏味道”的代码。</p>
<p>如果把代码写成下面的样子，看看会不会更好？</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;memory&gt;

// 抽象税务策略基类
class TaxStrategy {
public:
    virtual double calculateTax(double income) = 0;
};

// 中国税务策略
class ChinaTaxStrategy : public TaxStrategy {
public:
    double calculateTax(double income) override {
        // 使用中国的税务计算方式
        return income * 0.2; // 简化的计算方式
    }
};

// 美国税务策略
class USATaxStrategy : public TaxStrategy {
public:
    double calculateTax(double income) override {
        // 使用美国的税务计算方式
        return income * 0.3; // 简化的计算方式
    }
};

// 客户端代码
int main() {
    std::string country;
    std::cout &lt;&lt; &quot;Enter your country (China/USA): &quot;;
    std::cin &gt;&gt; country;

    std::unique_ptr&lt;TaxStrategy&gt; taxStrategy;

    if (country == &quot;China&quot;) {
        taxStrategy = std::make_unique&lt;ChinaTaxStrategy&gt;();
    } else if (country == &quot;USA&quot;) {
        taxStrategy = std::make_unique&lt;USATaxStrategy&gt;();
    } else {
        std::cout &lt;&lt; &quot;Invalid country&quot; &lt;&lt; std::endl;
        return 1;
    }

    double income;
    std::cout &lt;&lt; &quot;Enter your income: &quot;;
    std::cin &gt;&gt; income;

    double tax = taxStrategy-&gt;calculateTax(income);
    std::cout &lt;&lt; &quot;Tax to be paid: &quot; &lt;&lt; tax &lt;&lt; std::endl;

    return 0;
}</code></pre>
<p>对比一下，这种模式的好处显而易见，通过使用多态的方式来控制“变化”。将变化控制在多态的函数里面。这是典型的开放封闭原则和依赖抽象的原则。</p>
<p>如果有一天一个人跳出来多，我还要新家几个类型，那对于这个模式来说，只需要新加一个class 继承一把，把逻辑写进行就可以。</p>
<h2 id="观察者模式">观察者模式</h2>
<p>观察者模式是一个非常经典的模式。在大量的软件中都会使用。这个就不举例子了，直接写这个模式的demo了。</p>
<pre><code>class SUBJECT
{
    vector&lt;OBSERVER *&gt; observer_vector;
    public:
        void add_ob();
        void rm_ob();

        void update()
        {
            for (xxx)
            {
                ob-&gt;notify();
            }
        }
};

class OBSERVER
{
    public:
        vitual void notify () = 0;
};

class OBSERVER_V1: public OBSERVER
{
    public:
        void notify ()
        {
            // do something
        }
};</code></pre>
<p>不同类型的observer可以继承基类observer，实现自己不同的notify函数。</p>
<h2 id="visitor-模式">Visitor 模式</h2>
<p>Visitor 模式是一种设计模式，它允许你在不改变被访问元素的类的前提下，定义对这些元素进行操作的新操作。它将<strong>操作</strong>与<strong>元素的结构</strong>分离开来，使得<strong>添加新的操作</strong>更加容易，同时也支持在元素结构中添加新的元素类型。<br />
其实就是访问者实现 <code>visit()</code> 方法，被访问者实现 <code>accept()</code> 方法,双方通过这个约定的接口来进行交互</p>
<p>在 C++ 中实现 Visitor 模式，通常包括两个关键的部分：元素类和 Visitor 类。这里我举个简单的例子来说明：</p>
<p>假设有一个图形类层次结构，包括不同类型的图形：圆形、矩形和三角形。我们希望对这些图形进行不同的操作，比如计算面积、计算周长等。我们可以使用 Visitor 模式来实现这个场景。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="co">//===================被访问者===================</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a><span class="co">// Forward declaration of Visitor</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a><span class="kw">class</span> Visitor;</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a><span class="co">// Base class for all shapes</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a><span class="kw">class</span> Shape {</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a>    <span class="kw">virtual</span> <span class="dt">void</span> accept(Visitor&amp; visitor) = <span class="dv">0</span>;</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true"></a>};</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true"></a><span class="co">// Concrete Circle class</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true"></a><span class="kw">class</span> Circle : <span class="kw">public</span> Shape {</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true"></a>    <span class="dt">void</span> accept(Visitor&amp; visitor) <span class="kw">override</span> {</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true"></a>        visitor.visitCircle(*<span class="kw">this</span>);</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true"></a>    }</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true"></a></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true"></a>    <span class="co">// Other circle-specific methods and members</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true"></a>};</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true"></a></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true"></a><span class="co">// Concrete Rectangle class</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true"></a><span class="kw">class</span> Rectangle : <span class="kw">public</span> Shape {</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true"></a>    <span class="dt">void</span> accept(Visitor&amp; visitor) <span class="kw">override</span> {</span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true"></a>        visitor.visitRectangle(*<span class="kw">this</span>);</span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true"></a>    }</span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true"></a></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true"></a>    <span class="co">// Other rectangle-specific methods and members</span></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true"></a>};</span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true"></a></span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true"></a><span class="co">//===================访问者===================</span></span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true"></a><span class="co">// Visitor interface</span></span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true"></a><span class="kw">class</span> Visitor {</span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true"></a>    <span class="kw">virtual</span> <span class="dt">void</span> visitCircle(Circle&amp; circle) = <span class="dv">0</span>;</span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true"></a>    <span class="kw">virtual</span> <span class="dt">void</span> visitRectangle(Rectangle&amp; rectangle) = <span class="dv">0</span>;</span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true"></a>};</span>
<span id="cb11-38"><a href="#cb11-38" aria-hidden="true"></a></span>
<span id="cb11-39"><a href="#cb11-39" aria-hidden="true"></a><span class="co">// Concrete visitor implementing operations on shapes</span></span>
<span id="cb11-40"><a href="#cb11-40" aria-hidden="true"></a><span class="kw">class</span> AreaCalculator : <span class="kw">public</span> Visitor {</span>
<span id="cb11-41"><a href="#cb11-41" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb11-42"><a href="#cb11-42" aria-hidden="true"></a>    <span class="dt">void</span> visitCircle(Circle&amp; circle) <span class="kw">override</span> {</span>
<span id="cb11-43"><a href="#cb11-43" aria-hidden="true"></a>        <span class="co">// Calculate and display area of the circle</span></span>
<span id="cb11-44"><a href="#cb11-44" aria-hidden="true"></a>        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Calculating area of circle...&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb11-45"><a href="#cb11-45" aria-hidden="true"></a>        <span class="co">// Perform area calculation logic here</span></span>
<span id="cb11-46"><a href="#cb11-46" aria-hidden="true"></a>    }</span>
<span id="cb11-47"><a href="#cb11-47" aria-hidden="true"></a></span>
<span id="cb11-48"><a href="#cb11-48" aria-hidden="true"></a>    <span class="dt">void</span> visitRectangle(Rectangle&amp; rectangle) <span class="kw">override</span> {</span>
<span id="cb11-49"><a href="#cb11-49" aria-hidden="true"></a>        <span class="co">// Calculate and display area of the rectangle</span></span>
<span id="cb11-50"><a href="#cb11-50" aria-hidden="true"></a>        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Calculating area of rectangle...&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb11-51"><a href="#cb11-51" aria-hidden="true"></a>        <span class="co">// Perform area calculation logic here</span></span>
<span id="cb11-52"><a href="#cb11-52" aria-hidden="true"></a>    }</span>
<span id="cb11-53"><a href="#cb11-53" aria-hidden="true"></a>};</span>
<span id="cb11-54"><a href="#cb11-54" aria-hidden="true"></a></span>
<span id="cb11-55"><a href="#cb11-55" aria-hidden="true"></a><span class="kw">class</span> PerimeterCalculator : <span class="kw">public</span> Visitor {</span>
<span id="cb11-56"><a href="#cb11-56" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb11-57"><a href="#cb11-57" aria-hidden="true"></a>    <span class="dt">void</span> visitCircle(Circle&amp; circle) <span class="kw">override</span> {</span>
<span id="cb11-58"><a href="#cb11-58" aria-hidden="true"></a>        <span class="co">// Calculate and display perimeter of the circle</span></span>
<span id="cb11-59"><a href="#cb11-59" aria-hidden="true"></a>        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Calculating perimeter of circle...&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb11-60"><a href="#cb11-60" aria-hidden="true"></a>        <span class="co">// Perform perimeter calculation logic here</span></span>
<span id="cb11-61"><a href="#cb11-61" aria-hidden="true"></a>    }</span>
<span id="cb11-62"><a href="#cb11-62" aria-hidden="true"></a></span>
<span id="cb11-63"><a href="#cb11-63" aria-hidden="true"></a>    <span class="dt">void</span> visitRectangle(Rectangle&amp; rectangle) <span class="kw">override</span> {</span>
<span id="cb11-64"><a href="#cb11-64" aria-hidden="true"></a>        <span class="co">// Calculate and display perimeter of the rectangle</span></span>
<span id="cb11-65"><a href="#cb11-65" aria-hidden="true"></a>        <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Calculating perimeter of rectangle...&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb11-66"><a href="#cb11-66" aria-hidden="true"></a>        <span class="co">// Perform perimeter calculation logic here</span></span>
<span id="cb11-67"><a href="#cb11-67" aria-hidden="true"></a>    }</span>
<span id="cb11-68"><a href="#cb11-68" aria-hidden="true"></a>};</span>
<span id="cb11-69"><a href="#cb11-69" aria-hidden="true"></a></span>
<span id="cb11-70"><a href="#cb11-70" aria-hidden="true"></a><span class="co">//===========</span></span>
<span id="cb11-71"><a href="#cb11-71" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb11-72"><a href="#cb11-72" aria-hidden="true"></a>    Circle circle;</span>
<span id="cb11-73"><a href="#cb11-73" aria-hidden="true"></a>    Rectangle rectangle;</span>
<span id="cb11-74"><a href="#cb11-74" aria-hidden="true"></a></span>
<span id="cb11-75"><a href="#cb11-75" aria-hidden="true"></a>    AreaCalculator areaCalc;</span>
<span id="cb11-76"><a href="#cb11-76" aria-hidden="true"></a>    PerimeterCalculator perimeterCalc;</span>
<span id="cb11-77"><a href="#cb11-77" aria-hidden="true"></a></span>
<span id="cb11-78"><a href="#cb11-78" aria-hidden="true"></a>    circle.accept(areaCalc); <span class="co">// Calculate area of circle</span></span>
<span id="cb11-79"><a href="#cb11-79" aria-hidden="true"></a>    rectangle.accept(areaCalc); <span class="co">// Calculate area of rectangle</span></span>
<span id="cb11-80"><a href="#cb11-80" aria-hidden="true"></a></span>
<span id="cb11-81"><a href="#cb11-81" aria-hidden="true"></a>    circle.accept(perimeterCalc); <span class="co">// Calculate perimeter of circle</span></span>
<span id="cb11-82"><a href="#cb11-82" aria-hidden="true"></a>    rectangle.accept(perimeterCalc); <span class="co">// Calculate perimeter of rectangle</span></span>
<span id="cb11-83"><a href="#cb11-83" aria-hidden="true"></a></span>
<span id="cb11-84"><a href="#cb11-84" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb11-85"><a href="#cb11-85" aria-hidden="true"></a>}</span></code></pre></div>
<p>在这个示例中，我们定义了图形类层次结构和一个 Visitor 类（<code>ShapeVisitor</code>）。每个图形类（<code>Circle</code>、<code>Rectangle</code>、<code>Triangle</code>）都实现了 <code>accept()</code> 方法，该方法接受一个 Visitor，并根据当前对象的类型调用 Visitor 的相应方法。<code>ShapeVisitor</code> 包含了不同图形类型的 <code>visit()</code> 方法，用于执行特定于每种图形的操作。在 <code>main()</code> 中，我们创建了不同类型的图形对象，并将一个具体的 Visitor（<code>AreaVisitor</code>）传递给它们，以便进行特定的操作。</p>
<p>这个示例演示了如何使用 Visitor 模式来对不同类型的对象执行不同的操作，而不需要修改图形类的结构。</p>
<p><strong>Visitor 模式</strong>主要用于在不改变数据结构的前提下定义对数据结构中各种元素的新操作。它使得可以在不改变元素类的情况下，向现有的类层次结构中添加新的操作，这些操作可以通过 Visitor 接口的实现类来执行。这种模式强调的是对数据结构的操作和行为的分离，使得能够轻松添加新的操作而不用修改元素类。</p>
<p><strong>观察者模式</strong>用于定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并自动更新。在这种模式下，有两类角色：观察者（订阅者）和被观察者（发布者）。被观察者维护着观察者列表，并在状态变化时通知观察者。</p>
<h2 id="享元模式">享元模式</h2>
<hr />
<p>享元模式的思路常见。就是当有可能重复创建对象的时候，对相同或相似对象的重用。</p>
<p>比如：</p>
<pre><code>int create_obj(int key)
{
    if (_map.find(key) == _map.end())
    {
        // 创建对象
        // 插入map
    }
    else
    {
        // 直接返回对象
    }
}</code></pre>
<p>cpp文件</p>
<pre><code>FLYWEIGHT_OBJ* FLYWEIGHT::build_obj(int key)
{
    if (_map.find(key) == _map.end())
    {
        FLYWEIGHT_OBJ * obj = new FLYWEIGHT_OBJ();
        _map[key] = obj;
        return obj;
    }
    else
    {
        return _map[key];
    }
}

int FLYWEIGHT::clear()
{
    map&lt;int, FLYWEIGHT_OBJ *&gt;::iterator iter = _map.begin();
    for (; iter != _map.end(); iter++)
    {
        FLYWEIGHT_OBJ * obj = iter-&gt;second;
        delete obj;
    }
    return 0;
}</code></pre>
<p>hpp文件</p>
<pre><code>#ifndef __FLY_WEIGHT_H__
#define __FLY_WEIGHT_H__

#include &lt;iostream&gt;
#include &lt;map&gt;

using namespace std;

class FLYWEIGHT_OBJ
{
    public:
        FLYWEIGHT_OBJ():_data(0) {cout &lt;&lt; &quot;create obj&quot; &lt;&lt;endl;}
    private:
        int _data;
};

class FLYWEIGHT
{
    public:
        FLYWEIGHT_OBJ * build_obj(int key);
        int clear();

    private:
        std::map&lt;int, FLYWEIGHT_OBJ *&gt; _map;
};

#endif</code></pre>
<h2 id="代理模式-proxy模式">代理模式 PROXY模式</h2>
<p>proxy最常见的使用场景是，当开发的时候，看到一坨像shit一样的老代码，里面有一个函数func，需要调整or修改里面的部分逻辑。但是这个函数有无数个被引用的地方。直接改动func里面的逻辑，危险并且进一步使shit上再加shit。</p>
<p>因此，可以不去修改func内部的逻辑。可以重新写一个PROXY类继承原来的类，重新实现里面的逻辑。</p>
<pre><code>class OLD_CLASS
{
    int func()
    {
        // shit
    }
};

class PROXY_SHIT : public OLD_CLASS
{
    int proy_func()
    {
        pre_invoke();

        // invoke shit
        old_class-&gt;func();

        post_invoke();
    }

    private:
        OLD_CLASS * old_class;
}
</code></pre>
<h2 id="适配器模式-adapter">适配器模式 Adapter</h2>
<p>使用的场景：</p>
<p>将一个类的接口转换为 用户希望的接口。可以是原本不兼容的接口 放到一起来使用。</p>
<p>举个栗子</p>
<pre><code>// 开发的时候看到一个接口
int func(OLD_CLASS * a)
{
    a-&gt;dosomething();
}

// 但是手上有的对象是B * b
int foo()
{
    NEW_CLASS b;
    func(&amp;b);  // complier error 
}</code></pre>
<p>如果让类型B转换为类型A, 适配器翻译的很准确，就是一个转换的插座。解决不同接口的类型的问题。</p>
<pre><code>class OLD_CLASS
{
    public:
        virtual void dosomething() {cout&lt;&lt;&quot;do something OLD_CLASS&quot;&lt;&lt;endl; }
    private:
        int _data;
};

class NEW_CLASS
{
    public:
        void dosomething() {cout&lt;&lt;&quot;do something NEW_CLASS&quot;&lt;&lt;endl; }
    private:
        int _data;
};

class Adapter : public OLD_CLASS
{
    public:
        Adapter(NEW_CLASS * new_obj):_new_obj(new_obj) {}

        void dosomething() 
        {
            _new_obj-&gt;dosomething();
        }

    private:
        NEW_CLASS * _new_obj;
};</code></pre>
<pre><code>int func(OLD_CLASS * old)
{
    old-&gt;dosomething();
    return 0;
}

int adapter_demo(NEW_CLASS * new_obj)
{
    // 比如说直接调用因为参数不对而报错
    // func(new)

    Adapter adapter(new_obj);
    adapter.dosomething();

    return 0;
}</code></pre>
<h2 id="状态机模式">状态机模式</h2>
<p>状态机模式可以被用在 软件设计中维护复杂的异步逻辑。</p>
<pre><code>class STATE_MACHINE
{
    int msg;
    int state;
    int next_stat;
};</code></pre>
<p>基本的思路是维护一张函数表，在当前的state下，收到什么样的消息（或超时），执行什么样的逻辑，进入的下一个状态是什么。</p>
<h2 id="责任链模式">责任链模式</h2>
<p>责任链模式可以用于的场景是：</p>
<p>对于一个对象req，可以定义一系列的class（责任链）来处理它。感觉对于一个http的请求，或者是一个客户端上行来的请求，可以使用这种模式，来定义一条流水线（责任链）进行处理。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

enum class RequestType
{
    REQ_HANDLER1,
    REQ_HANDLER2,
    REQ_HANDLER3
};

class Reqest
{
    string description;
    RequestType reqType;
public:
    Reqest(const string &amp; desc, RequestType type) : description(desc), reqType(type) {}
    RequestType getReqType() const { return reqType; }
    const string&amp; getDescription() const { return description; }
};

class ChainHandler{
    
    ChainHandler *nextChain;
    void sendReqestToNextHandler(const Reqest &amp; req)
    {
        if (nextChain != nullptr)
            nextChain-&gt;handle(req);
    }
protected:
    virtual bool canHandleRequest(const Reqest &amp; req) = 0;
    virtual void processRequest(const Reqest &amp; req) = 0;
public:
    ChainHandler() { nextChain = nullptr; }
    void setNextChain(ChainHandler *next) { nextChain = next; }
    
   
    void handle(const Reqest &amp; req)
    {
        if (canHandleRequest(req))
            processRequest(req);
        else
            sendReqestToNextHandler(req);
    }
};


class Handler1 : public ChainHandler{
protected:
    bool canHandleRequest(const Reqest &amp; req) override
    {
        return req.getReqType() == RequestType::REQ_HANDLER1;
    }
    void processRequest(const Reqest &amp; req) override
    {
        cout &lt;&lt; &quot;Handler1 is handle reqest: &quot; &lt;&lt; req.getDescription() &lt;&lt; endl;
    }
};
        
class Handler2 : public ChainHandler{
protected:
    bool canHandleRequest(const Reqest &amp; req) override
    {
        return req.getReqType() == RequestType::REQ_HANDLER2;
    }
    void processRequest(const Reqest &amp; req) override
    {
        cout &lt;&lt; &quot;Handler2 is handle reqest: &quot; &lt;&lt; req.getDescription() &lt;&lt; endl;
    }
};

class Handler3 : public ChainHandler{
protected:
    bool canHandleRequest(const Reqest &amp; req) override
    {
        return req.getReqType() == RequestType::REQ_HANDLER3;
    }
    void processRequest(const Reqest &amp; req) override
    {
        cout &lt;&lt; &quot;Handler3 is handle reqest: &quot; &lt;&lt; req.getDescription() &lt;&lt; endl;
    }
};

int main(){
    Handler1 h1;
    Handler2 h2;
    Handler3 h3;
    h1.setNextChain(&amp;h2);
    h2.setNextChain(&amp;h3);
    
    Reqest req(&quot;process task ... &quot;, RequestType::REQ_HANDLER3);
    h1.handle(req);
    return 0;
}</code></pre>

<footer id="colophon" >
		<div class="site-info col">
			Powered by <a href="https://github.com/sunxvming/my-blog">my-blog</a>
			<span class="sep"> | </span>
				<span><a target="_blank" href="http://beian.miit.gov.cn">【京ICP备19018538号】</a></span>
			<span><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11010502037753">【京公网安备 11010502037753号】</a></span>
		</div><!-- .site-info col -->
        <div class="site-info col"> This page is hosted at <a target="_blank" href="https://github.com/sunxvming">Github</a>.To see the source code you can visit the <a target="_blank" href="https://github.com/sunxvming/my-blog">repo</a> and I'd be glad if you like and star it.</div>
</footer>
</div> <!--wrapper-->
</body>
</html>
