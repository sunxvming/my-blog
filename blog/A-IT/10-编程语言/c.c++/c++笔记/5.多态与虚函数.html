<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta name="generator" content="pandoc" />



<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<link rel="stylesheet" href="../../../../.././css/style.css" />




<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Saira+Semi+Condensed%3A400%2C700&ver=4.9.18" type="text/css" />

<script src="https://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
<script>
jQuery(document).ready(function(){
    jQuery('pre').each(function(){
        var el = jQuery(this).find('code');
        var code_block = el.html(); 
 
        if (el.length > 0) { 
            jQuery(this).addClass('prettyprint').html(code_block).attr('style', 'max-height:450px');
        } else { 
            jQuery(this).removeClass().addClass('prettyprint'); 
        }
    });
});
</script>

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js?skin=desert"></script>

</head>


<body>
<div id="wrapper">


<style type="text/css">

#masthead .site-branding {
    margin-bottom: 7px;
}

#masthead .site-branding .site-title {
    font-size: 2.2rem;
    line-height: 1;
    text-transform: uppercase;
    margin: 0;
    margin-bottom: 0.5rem;
}


#masthead .site-description{
	margin:0px;
}




#masthead .site-branding .site-title a {
    display: inline-block;
    position: relative;
    top: -11px;
}

#masthead  a {
    <!-- color: #007bff; -->
    text-decoration: none;
    background-color: transparent;
}



.io-menu-desktop {
    display: block;
    text-align: right;
}
.io-menu-desktop span.io-menu-button-span {
    display: none;
}
.io-menu-desktop ul {
    padding: 0;
    margin: 0;
    list-style: none;
    background: transparent;
    display: block;
}
.io-menu-desktop ul > li {
    margin-right: -4px;
    display: inline-block;
    position: relative;
    height: 30px;
    color: #212529;
    font-size: 12px;
    text-transform: uppercase;
    text-shadow: 0 0 0 rgb(0 0 0 / 0%);
    font-weight: 400;
}
.io-menu-desktop ul > li > a {
    padding: 0;
    line-height: 29px;
    padding-left: 20px;
    padding-right: 20px;
    padding-top: 1px;
    color: #212529;
    font-size: 12px;
    text-transform: uppercase;
    text-shadow: 0 0 0 rgb(0 0 0 / 0%);
    font-weight: 400;
}
.io-menu-desktop a {
    display: block;
    -o-transition: none;
    -moz-transition: none;
    -webkit-transition: none;
    transition: none;
}
.io-menu-desktop > ul > li.current-menu-item > a, .io-menu-desktop > div > ul > li.current-menu-item > a {
    background: rgba(0, 0, 0, 0.01);
}



#colophon {
    margin-top: 70px;
    margin-bottom: 30px;
}
#colophon .site-info {
    text-align: center;
}

</style>


<header id="masthead" class="site-header row">
    <div class="site-branding col-sm-6">
        <span class="site-title" style="font-size: 2.2rem">
            <span>
                <img width="60px" height="60px"
                    src="https://sxm-upload.oss-cn-beijing.aliyuncs.com/imgs/16833443.jpg">
            </span>


            <a href="http://www.sunxvming.com/" rel="home">忧郁的大能猫</a>
        </span>
        <p class="site-description">好奇的探索者，理性的思考者，踏实的行动者。</p>
    </div><!-- .site-branding -->

    <nav id="site-navigation" class="main-navigation col-sm-9">
        <div class="io-menu io-menu-desktop"><span class="io-menu-button io-menu-button-span">≡</span>

            <div class="menu-%e4%b8%bb%e8%8f%9c%e5%8d%95-container">
                <ul id="primary-menu" class="menu">
                    <li id="menu-item-38"
                        class="menu-item menu-item-type-custom menu-item-object-custom current-menu-item current_page_item menu-item-home menu-item-38">
                        <a href="http://www.sunxvming.com">首页</a></li>
                    <li id="menu-item-175"
                        class="menu-item menu-item-type-post_type menu-item-object-page menu-item-175"><a
                            href="http://www.sunxvming.com/">所有文章</a></li>
                    <li id="menu-item-176"
                        class="menu-item menu-item-type-post_type menu-item-object-page menu-item-176"><a
                            href="http://www.sunxvming.com/blog/about-me.html">关于俺</a></li>
                </ul>
            </div>
        </div><!-- .io-menu -->
    </nav><!-- #site-navigation -->
</header>

<div id="header">
<h1 class="title">blog/A-IT/10-编程语言/c.c++/c++笔记/5.多态与虚函数</h1>
</div> <!--id="header"-->
 <!--if(title)-->

<p>Table of Contents:</p>
<div id="TOC">
<ul>
<li><a href="#多态和虚函数快速入门教程">多态和虚函数快速入门教程</a>
<ul>
<li><a href="#借助引用也可以实现多态">借助引用也可以实现多态</a></li>
<li><a href="#多态的用途目的">多态的用途，目的</a></li>
<li><a href="#缺点">缺点</a></li>
</ul></li>
<li><a href="#虚函数注意事项以及构成多态的条件">虚函数注意事项以及构成多态的条件</a></li>
<li><a href="#虚析构函数的必要性">虚析构函数的必要性</a></li>
<li><a href="#纯虚函数和抽象类详解">纯虚函数和抽象类详解</a></li>
<li><a href="#虚函数表精讲教程直戳多态的实现机制">虚函数表精讲教程，直戳多态的实现机制</a></li>
<li><a href="#typeid运算符获取类型信息">typeid运算符：获取类型信息</a></li>
<li><a href="#rtti机制运行时类型识别机制">RTTI机制（运行时类型识别机制）</a></li>
<li><a href="#c静态绑定和动态绑定彻底理解多态绑定的是地址">C++静态绑定和动态绑定，彻底理解多态(绑定的是地址)</a>
<ul>
<li><a href="#函数绑定">函数绑定</a></li>
</ul></li>
<li><a href="#rtti机制下的对象内存模型">RTTI机制下的对象内存模型</a></li>
</ul>
</div>
 <!--if(toc)-->

<h2 id="多态和虚函数快速入门教程">多态和虚函数快速入门教程</h2>
<p><strong>基类指针</strong>可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，我们将这种现象称为多态（Polymorphism）</p>
<p>默认情况通过<strong>基类指针</strong>只能访问派生类的<strong>成员变量</strong>，但是<strong>不能</strong>访问派生类的<strong>成员函数</strong>。<br />
为了消除这种尴尬，让基类指针能够访问派生类的成员函数，C++ 增加了虚函数（Virtual Function）<br />
C++中虚函数的<strong>唯一</strong>用处就是<strong>构成多态</strong><br />
C++提供多态的目的是：可以通过基类指针对所有派生类（包括直接派生和间接派生）的成员变量和成员函数进行“全方位”的访问，<strong>尤其是成员函数</strong>。如果没有多态，我们只能访问成员变量。</p>
<p>例子：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>People *p = new People(<span class="st">&quot;王志刚&quot;</span>, <span class="dv">23</span>);</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>p -&gt; display();</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>p = new Teacher(<span class="st">&quot;赵宏佳&quot;</span>, <span class="dv">45</span>, <span class="dv">8200</span>);</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>p -&gt; display();</span></code></pre></div>
<p>实现的三个条件：<br />
1.有继承、2.有virtual重写、3.有父类指针（或引用）指向子类对象。<br />
virtual关键字告诉编译器这个函数要支持多态；不要根据<strong>指针类型</strong>判断如何调用；而是要根据<strong>运行时指针所指向的实际对象类型</strong>来判断如何调用</p>
<p>实现的基础：1.动态绑定 2.函数指针</p>
<h3 id="借助引用也可以实现多态">借助引用也可以实现多态</h3>
<p>不过引用不像指针灵活，指针可以随时改变指向，而引用只能<strong>指代固定的对象</strong>，在多态性方面缺乏表现力</p>
<h3 id="多态的用途目的">多态的用途，目的</h3>
<ul>
<li>只需要一个指针变量 p 就可以调用所有派生类的虚函数，典型的例子是游戏循环中基类调用所有派生类的update方法</li>
<li>动态绑定能通过使旧的代码调用新的代码来提高重用,旧调新，向后扩展的作用，写框架一般都会用到</li>
<li>框架代码一般会用多态，让调用代码去继承某个类，让后框架代码调用用户的代码。</li>
</ul>
<h3 id="缺点">缺点</h3>
<p>通过<strong>虚函数表</strong>指针VPTR调用重写函数是在程序运行时进行的，因此需要通过<strong>寻址操作才能确定真正应该调用的函数</strong>。而普通成员函数是在编译时就确定了调用的函数。在效率上，虚函数的效率要低很多。出于效率考虑，没有必要将所有成员函数都声明为虚函数</p>
<h2 id="虚函数注意事项以及构成多态的条件">虚函数注意事项以及构成多态的条件</h2>
<p>什么时候声明虚函数<br />
1. 首先看成员函数所在的类是否会作为基类。<br />
2. 然后看成员函数在类的继承后有无可能被更改功能，<br />
3. 如果希望更改其功能的，一般应该将它声明为虚函数。<br />
4. 如果成员函数在类被继承后功能<strong>不需修改</strong>，或<strong>派生类用不到该函数</strong>，则不要把它声明为虚函数。</p>
<h2 id="虚析构函数的必要性">虚析构函数的必要性</h2>
<p>将基类的析构函数声明为虚函数后，派生类的析构函数也会<strong>自动成为虚函数</strong>。<br />
如果一个类是最终的类，那就没必要再声明为虚函数了</p>
<ol>
<li><p>构造函数为什么不能是虚函数？<br />
C++ 中的构造函数用于在创建对象时进行初始化工作，在执行构造函数之前对象尚未创建完成，虚函数表尚不存在，也没有指向虚函数表的指针，所以此时<strong>无法查询虚函数表</strong>，也就不知道要调用哪一个构造函数。</p></li>
<li><p>析构造函数为什么要是虚函数？<br />
因为如果不是虚析构函数，那么会调用基类的析构函数，而不会调用派生类的析构函数，从而就会有内存泄漏的情况。</p></li>
<li><p>为什么delete的时，会同时调用派生类和基类的析构函数呢？<br />
虚析构函数会根据指针指向的类型调用<strong>派生类的析构函数</strong>，而在执行派生类的析构函数的过程中，又会调用基类的析构函数。派生类析构函数始终会调用基类的析构函数，并且这个<strong>过程是隐式完成的</strong>。<br />
在派生类的析构函数中不用显式地调用基类的析构函数，因为每个类只有一个析构函数，编译器知道如何选择，无需程序员干涉。</p></li>
</ol>
<h2 id="纯虚函数和抽象类详解">纯虚函数和抽象类详解</h2>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>virtual 返回值类型 函数名 (函数参数) = <span class="dv">0</span>;</span></code></pre></div>
<p>包含大于等于一个纯虚函数的类称为<strong>抽象类（Abstract Class）</strong>。之所以说它抽象，是因为它<strong>无法实例化</strong>，也就是无法创建对象。原因很明显，纯虚函数<strong>没有函数体，不是完整的函数</strong>，无法调用。</p>
<p>抽象类通常是作为<strong>基类</strong>，让派生类去实现纯虚函数。派生类必须实现纯虚函数才能被实例化。<br />
1）<strong>有一个纯虚函数就可以使类成为抽象基类</strong>，但是抽象基类中除了包含纯虚函数外，还可以包含其它的成员函数（虚函数或普通函数）和成员变量<br />
2) 只有类中的虚函数才能被声明为纯虚函数，普通成员函数和顶层函数均不能声明为纯虚函数</p>
<h2 id="虚函数表精讲教程直戳多态的实现机制">虚函数表精讲教程，直戳多态的实现机制</h2>
<ul>
<li><strong>如果一个类包含了虚函数，那么在创建该类的对象时就会额外地增加一个数组，数组中的每一个元素都是虚函数的入口地址</strong>。不过数组和对象是<strong>分开存储的</strong>，为了将对象和数组关联起来，编译器还要在对象中安插一个指针，指向数组的起始位置。这里的数组就是虚函数表（Virtual function table），简写为<code>vtable</code></li>
<li>在对象的开头位置有一个指针 <code>vfptr</code>，指向虚函数表，并且这个指针始终位于<strong>对象的开头位置</strong>。</li>
<li>仔细观察虚函数表，可以发现基类的虚函数在 vtable 中的索引（下标）是固定的，不会随着继承层次的增加而改变，派生类新增的虚函数放在 vtable 的最后。如果派生类<strong>有同名的虚函数遮蔽（覆盖）了基类的虚函数</strong>，那么将使用派生类的虚函数<strong>替换</strong>基类的虚函数(<strong>这就是多态的原因</strong>)。</li>
</ul>
<p><img src="https://sxm-upload.oss-cn-beijing.aliyuncs.com/imgs/27b003e2-81ea-4aaa-afb9-1cceb27047b7.png" /></p>
<h2 id="typeid运算符获取类型信息">typeid运算符：获取类型信息</h2>
<p><code>typeid</code> 运算符用来获取一个表达式的类型信息。类型信息对于编程语言非常重要，它描述了数据的各种属性：<br />
* 对于基本类型（int、float 等C++内置类型）的数据，类型信息所包含的内容比较简单，主要是指数据的类型。<br />
* 对于类类型的数据（也就是对象），类型信息是指<strong>对象所属的类、所包含的成员、所在的继承关系</strong>等。</p>
<p>类型信息是创建数据的模板，数据占用多大内存、能进行什么样的操作、该如何操作等，这些都由它的<strong>类型信息</strong>决定。</p>
<p>可以发现，不像 Java、C# 等动态性较强的语言，<strong>C++ 能获取到的类型信息非常有限</strong>，也没有统一的标准，各个编译器可能会有不同的实现细节。<br />
通常情况下，<code>type_info</code> 类型提供以下信息：<br />
1. <strong><code>name</code> 函数：</strong> 返回一个指向包含类型名称的 C 字符串的指针。这个名称可能是编译器特定的，通常会包含类型的限定名。<br />
2. <strong>比较操作：</strong> <code>type_info</code> 对象可以用于比较两个类型是否相同。</p>
<p><code>typeid</code> 返回 <strong>type_info</strong> 对象的<strong>引用</strong>，而表达式<code>typeid(a) == typeid(b)</code>的结果为 true，<br />
一个类型不管使用了多少次，<strong>编译器都只为它创建一个对象</strong>，所有 typeid 都返回这个对象的引用。</p>
<p><strong>何时创建type_info对象</strong>？<br />
1. 为了减小编译后文件的体积，编译器不会为所有的类型创建 type_info 对象，<strong>只会为使用了 typeid 运算符的类型创建</strong>。<br />
2. 不过有一种特殊情况，就是<strong>带虚函数</strong>的类（包括继承来的），不管有没有使用 typeid 运算符，编译器都会为带虚函数的类创建 type_info 对象</p>
<p>C++ 标准规定，type_info 类至少要有如下所示的 4 个 public 属性的成员函数，其他的扩展函数编译器开发者可以自由发挥，不做限制。<br />
1) 原型：const char* name() const;<br />
2) 原型：bool before (const type_info&amp; rhs) const;<br />
3) 原型：bool operator== (const type_info&amp; rhs) const;<br />
4) 原型：bool operator!= (const type_info&amp; rhs) const;</p>
<h2 id="rtti机制运行时类型识别机制">RTTI机制（运行时类型识别机制）</h2>
<p>RTTI（Run-Time Type Identification，RTTI）</p>
<p>一般情况下，在编译期间就能确定一个表达式的类型，但是<strong>当存在多态时，有些表达式的类型在编译期间就无法确定了</strong>，必须等到程序运行后根据实际的环境来确定。<strong>实现原理</strong>就是在虚函数表中添加了一个指向type_info的指针。<strong>相同类型的对象会指向同一个type_info对象。</strong><br />
比如：一个基类对象有两个赋值的分支<br />
在编译期间确定的情况下，有一个对象的方法调用是直接就load相应的代码段了，如果是虚函数的话，需要在运行是<strong>确定其类型</strong>，然后通过虚函数指针找到虚函数表然后再找到对应的方法。<br />
带有虚函数的对象模型：<br />
<img src="https://sxm-upload.oss-cn-beijing.aliyuncs.com/imgs/e1db42a8-f727-43e5-8bba-ca507aa05efb.png" /><br />
编译器会在虚函数表 vftable 的开头插入一个指针，指向当前类对应的 <code>type_info</code> 对象。当程序在<strong>运行阶段获取类型信息时（调用typeid）</strong>，可以通过对象指针 p 找到虚函数表指针 vfptr，再通过 vfptr 找到 type_info 对象的指针，进而取得类型信息。下面的代码演示了这种转换过程：<code>**(p-&gt;vfptr - 1)</code><br />
例子：</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="co">//基类</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>class People{</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>public:</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>    virtual <span class="dt">void</span> func(){ }</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>};</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a><span class="co">//派生类</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>class Student: public People{ };</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a><span class="dt">int</span> main(){</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>    People *p;</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a>    <span class="dt">int</span> n;</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a>  </span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true"></a>    cin&gt;&gt;n;</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true"></a>    <span class="cf">if</span>(n &lt;= <span class="dv">100</span>){</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true"></a>        p = new People();</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true"></a>    }<span class="cf">else</span>{</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true"></a>        p = new Student();</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true"></a>    }</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true"></a>    <span class="co">//根据不同的类型进行不同的操作</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true"></a>    <span class="cf">if</span>(typeid(*p) == typeid(People)){</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true"></a>        cout&lt;&lt;<span class="st">&quot;I am human.&quot;</span>&lt;&lt;endl;</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true"></a>    }<span class="cf">else</span>{</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true"></a>        cout&lt;&lt;<span class="st">&quot;I am a student.&quot;</span>&lt;&lt;endl;</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true"></a>    }</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true"></a>}</span></code></pre></div>
<h2 id="c静态绑定和动态绑定彻底理解多态绑定的是地址">C++静态绑定和动态绑定，彻底理解多态(绑定的是地址)</h2>
<p>C/C++ 用变量来存储数据，用函数来定义一段可以重复使用的代码，它们最终都要放到内存中才能供 CPU 使用。CPU 通过地址来取得内存中的代码和数据，程序在执行过程中会告知 CPU 要执行的代码以及要读写的数据的地址。</p>
<p>CPU 访问内存时需要的是地址，而不是变量名和函数名！变量名和函数名只是地址的一种<strong>助记符</strong>，当源文件被编译和链接成可执行程序后，它们都会被<strong>替换成地址</strong>。编译和链接过程的一项重要任务就是找到这些名称所对应的地址。<br />
我们不妨将变量名和函数名统称为<strong>符号</strong>（Symbol），找到符号对应的地址的过程叫做<strong>符号绑定</strong>。</p>
<h3 id="函数绑定">函数绑定</h3>
<p>找到函数名对应的地址，然后将函数调用处用该地址替换，这称为函数绑定。<br />
* 静态绑定（Static binding）：一般情况下，在编译期间（包括链接期间）就能找到函数名对应的地址，完成函数的绑定，程序运行后直接使用这个地址即可。<br />
* 动态绑定（dynamic binding）：但是有时候在编译期间想尽所有办法都不能确定使用哪个函数，必须要等到程序运行后根据具体的环境或者用户操作才能决定。</p>
<p>C++ 是一门静态性的语言，会尽力在编译期间找到函数的地址，以提高程序的运行效率，但是有时候实在没办法，只能等到程序运行后再执行一段代码（很少的代码）才能找到函数的地址。</p>
<p>上节我们讲到，通过p -&gt; display();语句调用 display() 函数时会转换为下面的表达式：<br />
<code>( *( *(p+0) + 0 ) )(p);</code><br />
这里的 p 有可能指向 People 类的对象，也可能指向 Student 或 Senior 类的对象，编译器不能提前假设 p 指向哪个对象，也就不能确定调用哪个函数，所以编译器干脆不管了，p 爱指向哪个对象就指向哪个对象，等到程序运行后执行一下这个表达式自然就知道了。</p>
<p>这就是动态绑定的本质：<strong>编译器在编译期间不能确定指针指向哪个对象，只能等到程序运行后根据具体的情况再决定(虚函数表来决定调用那一个)</strong></p>
<h2 id="rtti机制下的对象内存模型">RTTI机制下的对象内存模型</h2>
<p>在 C++ 中，除了 <code>typeid</code> 运算符，<code>dynamic_cast</code> 运算符和异常处理也依赖于 RTTI 机制，并且要能够通过派生类获取基类的信息，或者说要能够判断一个类是否是另一个类的基类，这样上节讲到的内存模型就不够用了，我们必须要在<strong>基类和派生类之间再增加一条绳索，把它们连接起来，形成一条通路</strong>，我们称此为<strong>继承链</strong>（Inheritance Chain）。</p>
<p>将基类和派生类连接起来很容易，只需要在基类对象中增加一个指向派生类对象的指针，然而考虑到多继承、降低内存使用等诸多方面的因素，真正的对象内存模型比上节讲到的要复杂很多，并且不同的编译器有不同的实现（C++ 标准并没有对对象内存模型的细节做出规定）。</p>
<p>typeid 经过固定次数的间接转换返回 type_info 对象，间接次数不会随着继承层次的增加而增加，对效率的影响很小，读者可以放心使用。而 dynamic_cast 运算符和异常处理不仅要经过数次间接转换，还要遍历继承链，如果继承层次较深，那么它们的性能堪忧，读者应当谨慎使用！</p>
<ul>
<li><p>静态语言（Static Language）<br />
编译期间确定类型的。在 C/C++ 中，变量、函数参数、函数返回值等在定义时都必须显式地指明类型，并且一旦指明类型后就不能再更改了，所以大部分表达式的类型都能够精确的推测出来，编译器在编译期间就能够搞定这些事情，这样的编程语言称为静态语言。除了 C/C++，典型的静态语言还有 Java、C#、Haskell、Scala 等。<br />
静态语言在定义变量时通常需要显式地指明类型，并且在编译期间会拼尽全力来确定表达式的类型信息，只有在万不得已时才让程序等到运行后动态地获取类型信息（例如多态），这样做可以提高程序运行效率，降低内存消耗。</p></li>
<li><p>动态语言（Dynamic Language）<br />
运行期间确定类型的。动态语言在定义变量时往往<strong>不需要指明类型</strong>，并且变量的类型可以随时改变（赋给它不同类型的数据），编译器在编译期间也不容易确定表达式的类型信息，只能等到程序运行后**再动态地获取类型信息。典型的动态语言有 JavaScript、Python、PHP、Perl、Ruby 等。</p></li>
</ul>

<footer id="colophon" >
		<div class="site-info col">
			Powered by <a href="https://github.com/sunxvming/my-blog">my-blog</a>
			<span class="sep"> | </span>
				<span><a target="_blank" href="http://beian.miit.gov.cn">【京ICP备19018538号】</a></span>
			<span><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11010502037753">【京公网安备 11010502037753号】</a></span>
		</div><!-- .site-info col -->
        <div class="site-info col"> This page is hosted at <a target="_blank" href="https://github.com/sunxvming">Github</a>.To see the source code you can visit the <a target="_blank" href="https://github.com/sunxvming/my-blog">repo</a> and I'd be glad if you like and star it.</div>
</footer>
</div> <!--wrapper-->
</body>
</html>
