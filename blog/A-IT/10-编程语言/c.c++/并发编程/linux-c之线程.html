<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta name="generator" content="pandoc" />



<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<link rel="stylesheet" href="../../../../.././css/style.css" />




<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Saira+Semi+Condensed%3A400%2C700&ver=4.9.18" type="text/css" />

<script src="https://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
<script>
jQuery(document).ready(function(){
    jQuery('pre').each(function(){
        var el = jQuery(this).find('code');
        var code_block = el.html(); 
 
        if (el.length > 0) { 
            jQuery(this).addClass('prettyprint').html(code_block).attr('style', 'max-height:450px');
        } else { 
            jQuery(this).removeClass().addClass('prettyprint'); 
        }
    });
});
</script>

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js?skin=desert"></script>

</head>


<body>
<div id="wrapper">


<style type="text/css">

#masthead .site-branding {
    margin-bottom: 7px;
}

#masthead .site-branding .site-title {
    font-size: 2.2rem;
    line-height: 1;
    text-transform: uppercase;
    margin: 0;
    margin-bottom: 0.5rem;
}


#masthead .site-description{
	margin:0px;
}




#masthead .site-branding .site-title a {
    display: inline-block;
    position: relative;
    top: -11px;
}

#masthead  a {
    <!-- color: #007bff; -->
    text-decoration: none;
    background-color: transparent;
}



.io-menu-desktop {
    display: block;
    text-align: right;
}
.io-menu-desktop span.io-menu-button-span {
    display: none;
}
.io-menu-desktop ul {
    padding: 0;
    margin: 0;
    list-style: none;
    background: transparent;
    display: block;
}
.io-menu-desktop ul > li {
    margin-right: -4px;
    display: inline-block;
    position: relative;
    height: 30px;
    color: #212529;
    font-size: 12px;
    text-transform: uppercase;
    text-shadow: 0 0 0 rgb(0 0 0 / 0%);
    font-weight: 400;
}
.io-menu-desktop ul > li > a {
    padding: 0;
    line-height: 29px;
    padding-left: 20px;
    padding-right: 20px;
    padding-top: 1px;
    color: #212529;
    font-size: 12px;
    text-transform: uppercase;
    text-shadow: 0 0 0 rgb(0 0 0 / 0%);
    font-weight: 400;
}
.io-menu-desktop a {
    display: block;
    -o-transition: none;
    -moz-transition: none;
    -webkit-transition: none;
    transition: none;
}
.io-menu-desktop > ul > li.current-menu-item > a, .io-menu-desktop > div > ul > li.current-menu-item > a {
    background: rgba(0, 0, 0, 0.01);
}



#colophon {
    margin-top: 70px;
    margin-bottom: 30px;
}
#colophon .site-info {
    text-align: center;
}

</style>


<header id="masthead" class="site-header row">
    <div class="site-branding col-sm-6">
        <span class="site-title" style="font-size: 2.2rem">
            <span>
                <img width="60px" height="60px"
                    src="https://sxm-upload.oss-cn-beijing.aliyuncs.com/imgs/16833443.jpg">
            </span>


            <a href="http://www.sunxvming.com/" rel="home">忧郁的大能猫</a>
        </span>
        <p class="site-description">好奇的探索者，理性的思考者，踏实的行动者。</p>
    </div><!-- .site-branding -->

    <nav id="site-navigation" class="main-navigation col-sm-9">
        <div class="io-menu io-menu-desktop"><span class="io-menu-button io-menu-button-span">≡</span>

            <div class="menu-%e4%b8%bb%e8%8f%9c%e5%8d%95-container">
                <ul id="primary-menu" class="menu">
                    <li id="menu-item-38"
                        class="menu-item menu-item-type-custom menu-item-object-custom current-menu-item current_page_item menu-item-home menu-item-38">
                        <a href="http://www.sunxvming.com">首页</a></li>
                    <li id="menu-item-175"
                        class="menu-item menu-item-type-post_type menu-item-object-page menu-item-175"><a
                            href="http://www.sunxvming.com/">所有文章</a></li>
                    <li id="menu-item-176"
                        class="menu-item menu-item-type-post_type menu-item-object-page menu-item-176"><a
                            href="http://www.sunxvming.com/blog/about-me.html">关于俺</a></li>
                </ul>
            </div>
        </div><!-- .io-menu -->
    </nav><!-- #site-navigation -->
</header>

<div id="header">
<h1 class="title">blog/A-IT/10-编程语言/c.c++/并发编程/linux-c之线程</h1>
</div> <!--id="header"-->
 <!--if(title)-->

<p>Table of Contents:</p>
<div id="TOC">
<ul>
<li><a href="#进程缺点">进程缺点</a></li>
<li><a href="#线程概念">线程概念</a></li>
<li><a href="#线程的内存布局">线程的内存布局</a></li>
<li><a href="#常见问题">常见问题</a>
<ul>
<li><a href="#主线程退出支线程也将退出吗">主线程退出，支线程也将退出吗</a></li>
</ul></li>
<li><a href="#某个线程崩溃会导致进程退出吗">某个线程崩溃，会导致进程退出吗</a></li>
<li><a href="#线程控制">线程控制</a>
<ul>
<li><a href="#创建线程">创建线程</a></li>
<li><a href="#设置线程属性">设置线程属性</a></li>
<li><a href="#分离线程pthread_detach">分离线程pthread_detach()</a></li>
<li><a href="#线程比较">线程比较</a></li>
<li><a href="#终止线程和join">终止线程和join</a></li>
</ul></li>
<li><a href="#工作worker线程模型">工作（Worker）线程模型</a></li>
<li><a href="#线程安全问题">线程安全问题</a></li>
<li><a href="#线程间同步">线程间同步</a>
<ul>
<li><a href="#mutex锁">mutex(锁)</a>
<ul>
<li><a href="#死锁">死锁</a></li>
</ul></li>
<li><a href="#条件变量condition-variable">条件变量(Condition Variable)</a></li>
<li><a href="#semaphore信号量">Semaphore(信号量)</a>
<ul>
<li><a href="#场景一">场景一：</a></li>
<li><a href="#被抛弃的信号量">被”抛弃”的信号量</a></li>
</ul></li>
<li><a href="#读写锁read-write-lock">读写锁(read-write-lock)</a></li>
</ul></li>
</ul>
</div>
 <!--if(toc)-->

<h2 id="进程缺点">进程缺点</h2>
<ul>
<li>创建进程的过程会带来一定的开销 ，要复制整个内存区域</li>
<li>若进程比较多，线程的上下文切换将是很大的开销</li>
<li>进程间数据交换、通信比较麻烦</li>
</ul>
<h2 id="线程概念">线程概念</h2>
<p>线程是允许应用程序<strong>并发执行多个任务</strong>的一种机制。<br />
为了保持多进程的优点，同时在一定程度上克服其缺点，引入的线程（Thread）的概念。这是为了将进程的各种劣势降至最低程度（不是直接消除）而设立的一种「轻量级进程」。</p>
<p>由于同一进程的多个线程<strong>共享同一地址空间(数据区、代码区、堆区)</strong>，因此Text Segment、Data Segment都是共享的</p>
<p>如果定义一个函数，在各线程中都可以调用，如果定义一个全局变量，在各线程中都可以访问到，除此之外，各线程还共享以下进程资源和环境：<br />
* 文件描述符表<br />
* 每种信号的处理方式（ SIG_IGN 、 SIG_DFL 或者自定义的信号处理函数）<br />
* 当前工作目录<br />
* 用户id和组id</p>
<p>但有些资源是每个线程各有一份的：<br />
* 线程id<br />
* 上下文，包括各种寄存器的值、程序计数器和栈指针<br />
* 栈空间<br />
* errno 变量<br />
* 信号屏蔽字<br />
* 调度优先级</p>
<h2 id="线程的内存布局">线程的内存布局</h2>
<p><img src="https://sxm-upload.oss-cn-beijing.aliyuncs.com/imgs/7245061e-e30f-4e07-ba23-adc137072761.png" /></p>
<p>虚拟内存中的整体布局：<br />
1. <strong>代码段</strong>：所有线程共享相同的代码段，这包括程序的可执行指令和常量数据。这意味着多个线程执行相同的代码，无需每个线程都有自己的代码段。<br />
2. <strong>数据段</strong>：线程共享全局变量、静态变量和初始化的全局数据。这些数据位于进程的数据段，所有线程都可以访问和修改这些共享数据。<br />
3. <strong>堆</strong>：多个线程共享进程的堆空间。堆是用于动态内存分配的区域，因此在多线程环境中需要考虑线程安全性来避免竞争条件。<br />
4. <strong>栈</strong>：每个线程都有自己的栈空间，用于存储局部变量和函数调用的上下文信息。每个线程的栈是线程<strong>私有的</strong>，不会被其他线程访问。<br />
5. <strong>文件描述符表</strong>：在多线程进程中，所有线程共享同一个文件描述符表。这意味着在一个线程中打开的文件，其他线程也可以访问。<br />
6. <strong>线程特定数据</strong>：每个线程可以拥有自己的线程特定数据，这是一种在线程中存储特定于该线程的数据的机制。线程特定数据对于每个线程都是私有的，不会被其他线程访问。比如：<code>thread_local</code></p>
<p>多个栈区的布局：<br />
1. <strong>栈空间大小的设定</strong>：<br />
- 在创建线程时，操作系统会为每个线程分配栈空间。栈空间的大小通常是固定的，由操作系统或应用程序设置。<br />
- 栈空间大小一般在编译或运行时指定，可以通过设置线程属性来定义。<br />
2. <strong>栈空间的分配</strong>：<br />
- 在线程创建时，操作系统会为该线程分配一块连续的虚拟内存区域作为栈空间。<br />
- 栈空间通常位于进程的虚拟地址空间的高地址部分。<br />
3. <strong>线程栈顶指针的设置</strong>：<br />
- 操作系统会设置线程的栈顶指针（Stack Pointer，SP），指向栈的当前位置。每当线程进行函数调用或局部变量分配时，栈顶指针会相应地调整。<br />
- 在函数调用时，栈顶指针会向低地址方向移动，为函数的局部变量分配空间。函数返回时，栈顶指针会向高地址方向移动，回收局部变量的空间。<br />
4. <strong>线程栈底指针的设置</strong>：<br />
- 操作系统会设置线程的栈底指针，指向栈的底部。栈底指针一般是一个固定值，表示栈的起始位置。<br />
- 在函数调用或局部变量分配时，栈底指针通常保持不变。<br />
5. <strong>栈空间的回收</strong>：<br />
- 当线程结束时，操作系统会回收该线程的栈空间，并将该空间标记为可重用。这样，线程的栈内存可以被重新利用，或者在不需要时可以释放。</p>
<h2 id="常见问题">常见问题</h2>
<h3 id="主线程退出支线程也将退出吗">主线程退出，支线程也将退出吗</h3>
<p>在 Windows 系统中，如果主线程结束而子线程没有结束，通常情况下，整个程序会继续运行直到所有线程都结束。<br />
在linux下也是一样的。</p>
<p>需要注意的是，程序的行为可能取决于线程的类型（守护线程或非守护线程）、线程的状态、程序的逻辑结构以及操作系统的实际行为。通常情况下，为了确保程序在主线程结束后不会提前退出，可以考虑等待其他线程结束再退出主线程，以保证程序正常运行完毕。</p>
<h2 id="某个线程崩溃会导致进程退出吗">某个线程崩溃，会导致进程退出吗</h2>
<p>还有一种问法是：进程中的某个线程崩溃，是否会对其他线程造成影响？</p>
<p>一般来说，每个线程都是独立执行的单位，都有自己的上下文堆栈，一个线程崩溃不会对其他线程造成影响。但是在通常情况下，一个线程崩溃也<strong>会导致整个进程退出</strong>。例如在Linux操作系统中可能会产生一个Segment Fault错误，这个错误会产生一个信号，操作系统对这个信号的默认处理就是结束进程，这样整个进程都被销毁，在这个进程中存在的其他线程自然也就不存在了。</p>
<h2 id="线程控制">线程控制</h2>
<p>我们将要学习的线程库函数是由POSIX标准定义的，称为POSIX thread 或者 <code>pthread</code>。<br />
在Linux上线程函数位于 libpthread <strong>共享库中</strong>，因此在编译时要加上 -lpthread 选项</p>
<p>线程的状态:</p>
<blockquote>
<p>new--&gt;runnable(on run queue)--&gt;running--&gt;blocked--&gt;running--&gt;dead</p>
</blockquote>
<h3 id="创建线程">创建线程</h3>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;pthread.h&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>int pthread_create(pthread_t *restrict thread,</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>const pthread_attr_t *restrict attr,</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>void *(*start_routine)(<span class="dt">void</span>*), void *restrict arg);</span></code></pre></div>
<p>返回值：成功返回0，失败返回错误号。</p>
<h3 id="设置线程属性">设置线程属性</h3>
<p>可以使用pthread_attr_t结构修改线程默认属性，并把这些属性与创建的线程联系起来<br />
可以使用pthread_attr_init函数初始化pthread_attr_t结构。<br />
调用pthread_attr_init以后，pthread_arrt_t的结构所包含的内容就是操作系统实现支持线程所有属性的默认值。如果要修改其中个别属性的值，需要调用其他函数。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>int pthread_attr_destroy(pthread_attr_t *attr);</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>int pthread_attr_init(pthread_attr_t *attr);</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);</span></code></pre></div>
<p>函数pthread_attr_init初始化attr结构。<br />
函数pthread_attr_destroy释放attr内存空间。<br />
pthread_attr_t的结构对于应用程序来讲是不透明的，应用程序不需要了解有关结构的内部组成。<br />
以前介绍了pthread_detach函数的概念，可以通过<code>pthread_attr_t</code>在创建线程的时候就指定线程属性为<code>detach</code>，而不用创建以后再去修改线程属性。</p>
<h3 id="分离线程pthread_detach">分离线程pthread_detach()</h3>
<p>函数原型：<br />
<code>int pthread_detach(pthread_t tid);</code><br />
使用方法：<br />
1. <strong>子线程</strong>中加入代码 pthread_detach(pthread_self()) pthread_self() 获取当前的线程号<br />
2. 父线程调用 pthread_detach(thread_id)（非阻塞，可立即返回）</p>
<p>一旦线程成为可分离线程之后,如果其他线程调用pthread_join失败，返回EINVAL<br />
可分离线程的使用场景<br />
1、主线程不需要等待子线程<br />
2、主线程不关心子线程的返回码</p>
<h3 id="线程比较">线程比较</h3>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>int pthread_equal(pthread_t th1,pthread_t th2);</span></code></pre></div>
<p>pthread_equal函数比较th1与th2是否为同一个线程，由于不可以将pthread数据类型认为是整数，所以也不能用比较整数的方式比较pthread_t</p>
<h3 id="终止线程和join">终止线程和join</h3>
<p>如果需要只终止某个线程而不终止整个进程，可以有三种方法：<br />
* 从线程函数 return 。这种方法对主线程不适用，从 main 函数 return 相当于调用 exit 。<br />
* 一个线程可以调用 pthread_cancel 终止同一进程中的另一个线程。<br />
* 线程可以调用 pthread_exit 终止自己</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>void pthread_exit(void *value_ptr);</span></code></pre></div>
<p>value_ptr 是 void * 类型，和线程函数返回值的用法一样，其它线程可以调用 pthread_join 获得这个指针，其实相对于一个线程结束的状态值。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>int pthread_join(pthread_t thread, void **value_ptr);</span></code></pre></div>
<p>一个线程所使用的内存资源在应用 pthread_join 调用之前不会被重新分配，所以对于每个线程必须调用一次pthread_join函数。<strong>pthread_join会释放线程资源</strong>.<br />
调用该函数的线程将<strong>挂起</strong>等待，直到id为 thread 的线程终止。<br />
thread 线程以不同的方法终止，通过 pthread_join 得到的终止状态是不同的，总结如下：<br />
* 如果 thread 线程通过 return 返回， value_ptr 所指向的单元里存放的是 thread 线程函数的返回值。<br />
* 如果 thread 线程被别的线程调用 pthread_cancel 异常终止掉， value_ptr 所指向的单元里存放的是常数 PTHREAD_CANCELED 。<br />
* 如果 thread 线程是自己调用 pthread_exit 终止的， value_ptr 所指向的单元存放的是传给 pthread_exit 的参数。<br />
 例子：</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;pthread.h&gt;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>void *thr_fn1(void *arg)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>{</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>    printf(<span class="st">&quot;thread 1 returning</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>    return (void *)<span class="dv">1</span>;</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a>}</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>void *thr_fn2(void *arg)</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a>{</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a>    printf(<span class="st">&quot;thread 2 exiting</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a>    pthread_exit((void *)<span class="dv">2</span>);</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true"></a>}</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true"></a>void *thr_fn3(void *arg)</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true"></a>{</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true"></a>    while(<span class="dv">1</span>) {</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true"></a>        printf(<span class="st">&quot;thread 3 writing</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true"></a>        sleep(<span class="dv">1</span>);</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true"></a>    }</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true"></a>}</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true"></a>int main(<span class="dt">void</span>)</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true"></a>{</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true"></a>    pthread_t tid;</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true"></a>    void *tret;</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true"></a>    pthread_create(&amp;tid, NULL, thr_fn1, NULL);</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true"></a>    pthread_join(tid, &amp;tret);</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true"></a>    printf(<span class="st">&quot;thread 1 exit code %d</span><span class="sc">\n</span><span class="st">&quot;</span>, (<span class="dt">int</span>)tret);</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true"></a>    pthread_create(&amp;tid, NULL, thr_fn2, NULL);</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true"></a>    pthread_join(tid, &amp;tret);</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true"></a>    printf(<span class="st">&quot;thread 2 exit code %d</span><span class="sc">\n</span><span class="st">&quot;</span>, (<span class="dt">int</span>)tret);</span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true"></a>    pthread_create(&amp;tid, NULL, thr_fn3, NULL);</span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true"></a>    sleep(<span class="dv">3</span>);</span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true"></a>    pthread_cancel(tid);</span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true"></a>    pthread_join(tid, &amp;tret);</span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true"></a>    printf(<span class="st">&quot;thread 3 exit code %d</span><span class="sc">\n</span><span class="st">&quot;</span>, (<span class="dt">int</span>)tret);</span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true"></a>    return <span class="dv">0</span>;</span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true"></a>}</span></code></pre></div>
<h2 id="工作worker线程模型">工作（Worker）线程模型</h2>
<p>下面的示例是计算从 1 到 10 的和，创建两个线程，其中一个线程计算 1 到 5 的和，另一个线程计算 6 到 10 的和，main 函数只负责输出运算结果。这种方式的线程模型称为「工作线程」</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;pthread.h&gt;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>void *thread_summation(void *arg);</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>int sum = <span class="dv">0</span>;</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>int main(int argc, char *argv[])</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a>{</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a>    pthread_t id_t1, id_t2;</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>    int range1[] = {<span class="dv">1</span>, <span class="dv">5</span>};</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>    int range2[] = {<span class="dv">6</span>, <span class="dv">10</span>};</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a>    pthread_create(&amp;id_t1, NULL, thread_summation, (void *)range1);</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a>    pthread_create(&amp;id_t2, NULL, thread_summation, (void *)range2);</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a>    pthread_join(id_t1, NULL);</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true"></a>    pthread_join(id_t2, NULL);</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true"></a>    printf(<span class="st">&quot;result: %d </span><span class="sc">\n</span><span class="st">&quot;</span>, sum);</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true"></a>    return <span class="dv">0</span>;</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true"></a>}</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true"></a>void *thread_summation(void *arg)</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true"></a>{</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true"></a>    int start = ((int *)arg)[<span class="dv">0</span>];</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true"></a>    int end = ((int *)arg)[<span class="dv">1</span>];</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true"></a>    while (start &lt;= end)</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true"></a>    {</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true"></a>        sum += start;</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true"></a>        start++;</span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true"></a>    }</span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true"></a>    return NULL;</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true"></a>}</span></code></pre></div>
<h2 id="线程安全问题">线程安全问题</h2>
<p>线程安全函数被多个线程同时调用也不会发生问题。反之，非线程安全函数被同时调用时会引发问题。<br />
幸运的是，大多数标准函数都是线程安全函数。操作系统在定义非线程安全函数的同时，提供了具有相同功能的线程安全的函数。比如，</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>struct hostent *gethostbyname(const char *hostname);</span></code></pre></div>
<p>同时，也提供了同一功能的安全函数：</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a>struct hostent *gethostbyname_r(const char *name,</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>                                struct hostent *result,</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>                                char *buffer,</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>                                int intbuflen,</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>                                int *h_errnop);</span></code></pre></div>
<p>线程安全函数结尾通常是 <code>_r</code> 。但是使用线程安全函数会给程序员带来额外的负担，可以通过以下方法自动将 gethostbyname 函数调用改为 gethostbyname_r 函数调用。<br />
声明头文件前定义 <code>_REENTRANT</code> 宏。<br />
无需特意更改源代码加，可以在编译的时候指定编译参数定义宏。</p>
<pre><code>gcc -D_REENTRANT mythread.c -o mthread -lpthread</code></pre>
<h2 id="线程间同步">线程间同步</h2>
<h3 id="mutex锁">mutex(锁)</h3>
<p><strong>做互斥用</strong><br />
多个线程同时访问共享数据时可能会冲突，这跟前面讲信号时所说的<strong>可重入性</strong>是同样的问题。<br />
对于多线程的程序，访问冲突的问题是很普遍的，解决的办法是引入互斥锁（Mutex，Mutual<br />
Exclusive Lock），获得锁的线程可以完成“读-修改-写”的操作，然后释放锁给其它线程，没有<br />
获得锁的线程只能等待而不能访问共享数据，这样“<strong>读-修改-写</strong>”三步操作组成一个原子操作，要<br />
么都执行，要么都不执行，不会执行到中间被打断，也不会在其它处理器上并行做这个操作。</p>
<p>Mutex用 pthread_mutex_t 类型的变量表示，可以这样初始化和销毁：</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;pthread.h&gt;</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>int pthread_mutex_destroy(pthread_mutex_t *mutex);</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>int pthread_mutex_init(pthread_mutex_t *restrict mutex,</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>const pthread_mutexattr_t *restrict attr);</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</span></code></pre></div>
<p>Mutex的加锁和解锁函数：</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;pthread.h&gt;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>int pthread_mutex_lock(pthread_mutex_t *mutex);</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>int pthread_mutex_trylock(pthread_mutex_t *mutex);</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>int pthread_mutex_unlock(pthread_mutex_t *mutex);</span></code></pre></div>
<p>返回值：成功返回0，失败返回错误号。<br />
一个线程可以调用pthread_mutex_lock获得Mutex，如果这时另一个线程已经调<br />
用pthread_mutex_lock获得了该Mutex，则当前线程需要挂起等待，直到另一个线程调<br />
用pthread_mutex_unlock释放Mutex，当前线程被唤醒，才能获得该Mutex并继续执行。<br />
如果一个线程既想获得锁，又不想<strong>挂起等待</strong>，可以调用pthread_mutex_trylock，如果Mutex已经<br />
被另一个线程获得，这个函数会失败返回<code>EBUSY</code>，而不会使线程挂起等待。<br />
加锁例子：</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;pthread.h&gt;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a>pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;<span class="co">//初始化了一个MUTEX锁</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a>int count = <span class="dv">0</span>;</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a>void *func1(void *arg)</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true"></a>{</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true"></a>    int *a = (int *) arg;</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true"></a>    printf(<span class="st">&quot;thread%d start</span><span class="sc">\n</span><span class="st">&quot;</span>, *a); <span class="co">//如果次线程被cancel掉的话，可能会出现死锁</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true"></a>    int i;</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true"></a>    for (i = <span class="dv">0</span>; i &lt; <span class="dv">10</span>; i++)</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true"></a>    {</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true"></a>        printf(<span class="st">&quot;thread%d is running</span><span class="sc">\n</span><span class="st">&quot;</span>, *a);</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true"></a>        sleep(<span class="dv">1</span>);</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true"></a>        pthread_mutex_lock(&amp;mutex); <span class="co">//给mutex加锁,这是一条原子操作，不可能出现两个线程同时执行这个代码</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true"></a>        count++; <span class="co">//这段代码受到保护，永远只有一个线程可以操作</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true"></a>        pthread_mutex_unlock(&amp;mutex); <span class="co">//给mutex解锁</span></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true"></a>    } <span class="co">//加锁的代码多了会是程序的运行效率降低</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true"></a>    printf(<span class="st">&quot;thread%d end</span><span class="sc">\n</span><span class="st">&quot;</span>, *a);</span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true"></a>    pthread_exit(NULL);</span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true"></a>}</span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true"></a>int main(int arg, char * args[])</span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true"></a>{</span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true"></a>    printf(<span class="st">&quot;process start</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true"></a>    pthread_t thr_d1, thr_d2;</span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true"></a>    int i[<span class="dv">2</span>];</span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true"></a>    i[<span class="dv">0</span>] = <span class="dv">1</span>;</span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true"></a>    i[<span class="dv">1</span>] = <span class="dv">2</span>;</span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true"></a>    pthread_create(&amp;thr_d1, NULL, func1, &amp;i[<span class="dv">0</span>]);</span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true"></a>    pthread_create(&amp;thr_d2, NULL, func1, &amp;i[<span class="dv">1</span>]);</span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true"></a>    pthread_join(thr_d1, NULL);</span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true"></a>    pthread_join(thr_d2, NULL);</span>
<span id="cb13-36"><a href="#cb13-36" aria-hidden="true"></a>    printf(<span class="st">&quot;process end</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb13-37"><a href="#cb13-37" aria-hidden="true"></a>    return <span class="dv">0</span>;</span>
<span id="cb13-38"><a href="#cb13-38" aria-hidden="true"></a>}</span></code></pre></div>
<h4 id="死锁">死锁</h4>
<ul>
<li><p>情形一：如果同一个线程先后两次调用lock，在第二次调用时，由于锁已经被占用，该线程会挂起</p></li>
<li><p>情形二：交叉死锁，线程A获得了锁1，线程B获得了锁2，这时线程A调用lock试图获得锁2，结果是需要挂起等<br />
待线程B释放锁2，而这时线程B也调用lock试图获得锁1，结果是需要挂起等待线程A释放锁1，于是线程A和B都永远处于挂起状态了</p>
<h4 id="避免死锁">避免死锁：</h4>
<p>1. 写程序时应该尽量<strong>避免同时获得多个锁</strong>，如果一定有必要这么做，则有一个原则：按相同的先后顺序（常见的是按Mutex变量的地址顺序）获得多个锁<br />
2. 如果要为所有的锁确定一个先后顺序比较困难，则应该尽量使用pthread_mutex_trylock调用代替pthread_mutex_lock调用，以免死锁</p></li>
</ul>
<h3 id="条件变量condition-variable">条件变量(Condition Variable)</h3>
<p><strong>做线程同步用</strong><br />
线程间的同步还有这样一种情况：线程A需要等某个条件成立才能继续往下执行，现在这个条件不成立，线程A就阻塞等待，而线程B在执行过程中使这个条件成立了，就唤醒线程A继续执行。<br />
在pthread库中通过条件变量（Condition Variable）来阻塞等待一个条件，或者唤醒等待这个条件的线程。Condition Variable用 pthread_cond_t 类型的变量表示，可以这样初始化和销毁：</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;pthread.h&gt;</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>int pthread_cond_destroy(pthread_cond_t *cond);</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>int pthread_cond_init(pthread_cond_t *restrict cond,</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a>const pthread_condattr_t *restrict attr);</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a>pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</span></code></pre></div>
<p>Condition Variable操作列函数：</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;pthread.h&gt;</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>int pthread_cond_timedwait(pthread_cond_t *restrict cond,</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>    pthread_mutex_t *restrict mutex,</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a>    const struct timespec *restrict abstime);</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a>int pthread_cond_wait(pthread_cond_t *restrict cond,</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true"></a>    pthread_mutex_t *restrict mutex);</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true"></a>int pthread_cond_broadcast(pthread_cond_t *cond);           <span class="co">//唤醒一个</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true"></a>int pthread_cond_signal(pthread_cond_t *cond);              <span class="co">//唤醒所有等待的线程</span></span></code></pre></div>
<p>一个线程可以调用 <code>pthread_cond_wait</code> 在一个Condition Variable上阻塞等待，这个函数做以下三步操作：<br />
<strong>1. 释放Mutex  2. 阻塞等待   3. 当被唤醒时，重新获得Mutex并返回</strong></p>
<p>假设想实现一个简单的消费者生产者模型，一个线程往队列中放入数据，一个线程往队列中取数据，取数据前需要判断一下队列中确实有数据，由于这个队列是线程间共享的，所以，需要使用互斥锁进行保护，一个线程在往队列添加数据的时候，另一个线程不能取，反之亦然。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;pthread.h&gt;</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a>struct msg {</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>    struct msg *next;</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a>    int num;</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true"></a>};</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true"></a>struct msg *head;</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true"></a>pthread_cond_t has_product = PTHREAD_COND_INITIALIZER;</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true"></a>pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true"></a>void *consumer(void *p)</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true"></a>{</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true"></a>    struct msg *mp;</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true"></a>    for (;;) {</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true"></a>        pthread_mutex_lock(&amp;lock);</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true"></a>        while (head == NULL)</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true"></a>            pthread_cond_wait(&amp;has_product, &amp;lock);</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true"></a>        mp = head;</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true"></a>        head = mp-&gt;next;</span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true"></a>        pthread_mutex_unlock(&amp;lock);</span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true"></a>        printf(<span class="st">&quot;Consume %d</span><span class="sc">\n</span><span class="st">&quot;</span>, mp-&gt;num);</span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true"></a>        free(mp);</span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true"></a>        sleep(rand() % <span class="dv">5</span>);</span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true"></a>    }</span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true"></a>}</span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true"></a>void *producer(void *p)</span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true"></a>{</span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true"></a>    struct msg *mp;</span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true"></a>    for (;;) {</span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true"></a>        mp = malloc(<span class="kw">sizeof</span>(struct msg));</span>
<span id="cb16-31"><a href="#cb16-31" aria-hidden="true"></a>        mp-&gt;num = rand() % <span class="dv">1000</span> + <span class="dv">1</span>;</span>
<span id="cb16-32"><a href="#cb16-32" aria-hidden="true"></a>        printf(<span class="st">&quot;Produce %d</span><span class="sc">\n</span><span class="st">&quot;</span>, mp-&gt;num);</span>
<span id="cb16-33"><a href="#cb16-33" aria-hidden="true"></a>        pthread_mutex_lock(&amp;lock);</span>
<span id="cb16-34"><a href="#cb16-34" aria-hidden="true"></a>        mp-&gt;next = head;</span>
<span id="cb16-35"><a href="#cb16-35" aria-hidden="true"></a>        head = mp;</span>
<span id="cb16-36"><a href="#cb16-36" aria-hidden="true"></a>        pthread_mutex_unlock(&amp;lock);</span>
<span id="cb16-37"><a href="#cb16-37" aria-hidden="true"></a>        pthread_cond_signal(&amp;has_product);</span>
<span id="cb16-38"><a href="#cb16-38" aria-hidden="true"></a>        sleep(rand() % <span class="dv">5</span>);</span>
<span id="cb16-39"><a href="#cb16-39" aria-hidden="true"></a>    }</span>
<span id="cb16-40"><a href="#cb16-40" aria-hidden="true"></a>}</span>
<span id="cb16-41"><a href="#cb16-41" aria-hidden="true"></a>int main(int argc, char *argv[])</span>
<span id="cb16-42"><a href="#cb16-42" aria-hidden="true"></a>{</span>
<span id="cb16-43"><a href="#cb16-43" aria-hidden="true"></a>    pthread_t pid, cid;</span>
<span id="cb16-44"><a href="#cb16-44" aria-hidden="true"></a>    srand(time(NULL));</span>
<span id="cb16-45"><a href="#cb16-45" aria-hidden="true"></a>    pthread_create(&amp;pid, NULL, producer, NULL);</span>
<span id="cb16-46"><a href="#cb16-46" aria-hidden="true"></a>    pthread_create(&amp;cid, NULL, consumer, NULL);</span>
<span id="cb16-47"><a href="#cb16-47" aria-hidden="true"></a>    pthread_join(pid, NULL);</span>
<span id="cb16-48"><a href="#cb16-48" aria-hidden="true"></a>    pthread_join(cid, NULL);</span>
<span id="cb16-49"><a href="#cb16-49" aria-hidden="true"></a>    return <span class="dv">0</span>;</span>
<span id="cb16-50"><a href="#cb16-50" aria-hidden="true"></a>}</span></code></pre></div>
<h3 id="semaphore信号量">Semaphore(信号量)</h3>
<p><strong>既能做互斥又能做线程同步</strong><br />
信号量用在多线程多任务同步的，一个线程完成了某一个动作就通过信号量告诉别的线程，别的线程再进行某些动作。<br />
Mutex变量是非0即1的，可看作一种<strong>资源的可用数量</strong>，初始化时Mutex是1，表示有一个可用资源，加锁时获得该资源，将Mutex减到0，表示不再有可用资源，解锁时释放该资源，将Mutex重新加到1，表示又有了一个可用资源。</p>
<p>信号量（Semaphore）和Mutex类似，<strong>表示可用资源的数量</strong>，和Mutex不同的是这个数量可以大于1。<br />
信号量是一个整数 count，提供两个原子(atom，不可分割)操作：P 操作和 V 操作，或是说 wait 和 signal 操作。<br />
* P操作 (wait操作)：count 减1；如果 count &lt; 0 那么挂起执行线程；<br />
* V操作 (signal操作)：count 加1；如果 count &lt;= 0(说明有其他的线程在等待) 那么唤醒一个执行线程；  </p>
<p>特别的,count 等于1的信号量保证了只有一个线程能进入临界区, 这种信号量被称为binary semaphore, 跟mutex是等价的。<br />
而当count大于1的时候，说明条件满足，可以有多个线程进入临界区，进入临界后要注意线程安全问题，</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;semaphore.h&gt;</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a>int sem_init(sem_t *sem, int pshared, unsigned int value);</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a>int sem_wait(sem_t *sem);</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a>int sem_trywait(sem_t *sem);</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a>int sem_post(sem_t * sem);</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a>int sem_destroy(sem_t * sem);</span></code></pre></div>
<h4 id="场景一">场景一：</h4>
<p>条件变量中的生产者－消费者的例子是基于链表的，其空间可以动态分配，现在基于固定大小的环形队列重写这个程序：</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;pthread.h&gt;</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;semaphore.h&gt;</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a><span class="pp">#define NUM 5</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true"></a>int queue[NUM];</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true"></a>sem_t blank_number, product_number;</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true"></a>void *producer(void *arg)</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true"></a>{</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true"></a>    int p = <span class="dv">0</span>;</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true"></a>    while (<span class="dv">1</span>) {</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true"></a>        sem_wait(&amp;blank_number);</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true"></a>        queue[p] = rand() % <span class="dv">1000</span> + <span class="dv">1</span>;    </span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true"></a>        printf(<span class="st">&quot;Produce %d</span><span class="sc">\n</span><span class="st">&quot;</span>, queue[p]);</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true"></a>        sem_post(&amp;product_number);</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true"></a>        p = (p+<span class="dv">1</span>)%NUM;</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true"></a>        sleep(rand()%<span class="dv">5</span>);</span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true"></a>    }</span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true"></a>}</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true"></a>void *consumer(void *arg)</span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true"></a>{</span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true"></a>    int c = <span class="dv">0</span>;</span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true"></a>    while (<span class="dv">1</span>) {</span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true"></a>        sem_wait(&amp;product_number);</span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true"></a>        printf(<span class="st">&quot;Consume %d</span><span class="sc">\n</span><span class="st">&quot;</span>, queue[c]);</span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true"></a>        queue[c] = <span class="dv">0</span>;</span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true"></a>        sem_post(&amp;blank_number);</span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true"></a>        c = (c+<span class="dv">1</span>)%NUM;</span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true"></a>        sleep(rand()%<span class="dv">5</span>);</span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true"></a>    }</span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true"></a>}</span>
<span id="cb18-32"><a href="#cb18-32" aria-hidden="true"></a>int main(int argc, char *argv[])</span>
<span id="cb18-33"><a href="#cb18-33" aria-hidden="true"></a>{</span>
<span id="cb18-34"><a href="#cb18-34" aria-hidden="true"></a>    pthread_t pid, cid;</span>
<span id="cb18-35"><a href="#cb18-35" aria-hidden="true"></a>    sem_init(&amp;blank_number, <span class="dv">0</span>, NUM);</span>
<span id="cb18-36"><a href="#cb18-36" aria-hidden="true"></a>    sem_init(&amp;product_number, <span class="dv">0</span>, <span class="dv">0</span>);</span>
<span id="cb18-37"><a href="#cb18-37" aria-hidden="true"></a>    pthread_create(&amp;pid, NULL, producer, NULL);</span>
<span id="cb18-38"><a href="#cb18-38" aria-hidden="true"></a>    pthread_create(&amp;cid, NULL, consumer, NULL);</span>
<span id="cb18-39"><a href="#cb18-39" aria-hidden="true"></a>    pthread_join(pid, NULL);</span>
<span id="cb18-40"><a href="#cb18-40" aria-hidden="true"></a>    pthread_join(cid, NULL);</span>
<span id="cb18-41"><a href="#cb18-41" aria-hidden="true"></a>    sem_destroy(&amp;blank_number);</span>
<span id="cb18-42"><a href="#cb18-42" aria-hidden="true"></a>    sem destroy(&amp;product number);</span>
<span id="cb18-43"><a href="#cb18-43" aria-hidden="true"></a>    return <span class="dv">0</span>;</span>
<span id="cb18-44"><a href="#cb18-44" aria-hidden="true"></a>}</span></code></pre></div>
<h4 id="被抛弃的信号量">被”抛弃”的信号量</h4>
<p>semaphore同时具有了mutex和condition_variable的功能, 这使得人们使用semaphore的时候很难区分某个semaphore是用来互斥的, 还是用来同步的.<br />
而大部分情况下, semaphore都是用来互斥的, 而一个binary semaphore可以<strong>在一个线程加锁, 在另一个线程解锁</strong>的行为, 很容易导致错误. <br />
<strong>而mutex则规定了在哪个线程加锁, 就得在哪个线程解锁</strong>, 否则未定义行为, 用错就挂, 至少容易发现错误. 这使得linux kernel也大范围弃用semaphore</p>
<h3 id="读写锁read-write-lock">读写锁(read-write-lock)</h3>
<p>如果共享数据是只读的，那么各线程读到的数据应该总是一致的，不会出现访问冲突。只要有一个线程可以改写数据，就必须考虑线程间同步的问题。由此引出了读者写者锁（<strong>Reader-Writer Lock</strong>）的概念，Reader之间并不互斥，可以同时读共享数据，而Writer是独占的（exclusive），在Writer修改数据时其它Reader或Writer不能访问数据，可见Reader-Writer Lock比Mutex具有更好的并发性。<br />
C++11 标准库引入了类似于 pthread_rwlock 的读写锁的概念，称为 std::shared_mutex。<br />
读写锁的三种状态：<br />
1. 当读写锁是<strong>写</strong>加锁状态时，在这个锁被解锁之前，所有试图对这个锁加锁的线程都会被阻塞<br />
2. 当读写锁在<strong>读</strong>加锁状态时，所有试图以<strong>读</strong>模式对它进行加锁的线程都可以得到访问权，但是以<strong>写</strong>模式对它进行加锁的线程将会被<strong>阻塞</strong><br />
3. 当读写锁在<strong>读</strong>模式的锁状态时，如果有另外的线程试图以<strong>写</strong>模式加锁，读写锁通常会阻塞随后的读模式锁的请求，这样可以避免读模式锁长期占用而等待的写模式锁请求则长期阻塞。也就是写模式锁的优先级高<br />
读写锁最适用于对数据结构的<strong>读操作次数多于写操作</strong>的场合，因为，读模式锁定时可以共享，而写模式锁定时只能某个线程独占资源，因而，读写锁也可以叫做个<strong>共享-独占锁</strong>。</p>
<p>pthread的例子：</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;thread&gt;</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;pthread.h&gt;</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a><span class="dt">pthread_rwlock_t</span> rwlock;</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true"></a><span class="dt">int</span> data = <span class="dv">0</span>;</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true"></a></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true"></a><span class="dt">void</span>* reader(<span class="dt">void</span>* arg) {</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true"></a>    pthread_rwlock_rdlock(&amp;rwlock);</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Reader: Data is &quot;</span> &lt;&lt; data &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true"></a>    pthread_rwlock_unlock(&amp;rwlock);</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true"></a>    <span class="cf">return</span> <span class="kw">nullptr</span>;</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true"></a>}</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true"></a></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true"></a><span class="dt">void</span>* writer(<span class="dt">void</span>* arg) {</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true"></a>    pthread_rwlock_wrlock(&amp;rwlock);</span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true"></a>    data++;</span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Writer: Data is updated to &quot;</span> &lt;&lt; data &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true"></a>    pthread_rwlock_unlock(&amp;rwlock);</span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true"></a>    <span class="cf">return</span> <span class="kw">nullptr</span>;</span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true"></a>}</span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true"></a></span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true"></a>    pthread_rwlock_init(&amp;rwlock, <span class="kw">nullptr</span>);</span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true"></a></span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true"></a>    <span class="dt">pthread_t</span> readers[<span class="dv">3</span>];</span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true"></a>    <span class="dt">pthread_t</span> writers[<span class="dv">2</span>];</span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true"></a></span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">3</span>; ++i) {</span>
<span id="cb19-30"><a href="#cb19-30" aria-hidden="true"></a>        pthread_create(&amp;readers[i], <span class="kw">nullptr</span>, reader, <span class="kw">nullptr</span>);</span>
<span id="cb19-31"><a href="#cb19-31" aria-hidden="true"></a>    }</span>
<span id="cb19-32"><a href="#cb19-32" aria-hidden="true"></a></span>
<span id="cb19-33"><a href="#cb19-33" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">2</span>; ++i) {</span>
<span id="cb19-34"><a href="#cb19-34" aria-hidden="true"></a>        pthread_create(&amp;writers[i], <span class="kw">nullptr</span>, writer, <span class="kw">nullptr</span>);</span>
<span id="cb19-35"><a href="#cb19-35" aria-hidden="true"></a>    }</span>
<span id="cb19-36"><a href="#cb19-36" aria-hidden="true"></a></span>
<span id="cb19-37"><a href="#cb19-37" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">3</span>; ++i) {</span>
<span id="cb19-38"><a href="#cb19-38" aria-hidden="true"></a>        pthread_join(readers[i], <span class="kw">nullptr</span>);</span>
<span id="cb19-39"><a href="#cb19-39" aria-hidden="true"></a>    }</span>
<span id="cb19-40"><a href="#cb19-40" aria-hidden="true"></a></span>
<span id="cb19-41"><a href="#cb19-41" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">2</span>; ++i) {</span>
<span id="cb19-42"><a href="#cb19-42" aria-hidden="true"></a>        pthread_join(writers[i], <span class="kw">nullptr</span>);</span>
<span id="cb19-43"><a href="#cb19-43" aria-hidden="true"></a>    }</span>
<span id="cb19-44"><a href="#cb19-44" aria-hidden="true"></a></span>
<span id="cb19-45"><a href="#cb19-45" aria-hidden="true"></a>    pthread_rwlock_destroy(&amp;rwlock);</span>
<span id="cb19-46"><a href="#cb19-46" aria-hidden="true"></a></span>
<span id="cb19-47"><a href="#cb19-47" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb19-48"><a href="#cb19-48" aria-hidden="true"></a>}</span></code></pre></div>

<footer id="colophon" >
		<div class="site-info col">
			Powered by <a href="https://github.com/sunxvming/my-blog">my-blog</a>
			<span class="sep"> | </span>
				<span><a target="_blank" href="http://beian.miit.gov.cn">【京ICP备19018538号】</a></span>
			<span><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11010502037753">【京公网安备 11010502037753号】</a></span>
		</div><!-- .site-info col -->
        <div class="site-info col"> This page is hosted at <a target="_blank" href="https://github.com/sunxvming">Github</a>.To see the source code you can visit the <a target="_blank" href="https://github.com/sunxvming/my-blog">repo</a> and I'd be glad if you like and star it.</div>
</footer>
</div> <!--wrapper-->
</body>
</html>
