	
第1章  新时代的语言	
	缘起	
	设计哲学	
		内存安全	
		零成本抽象	
		实用性	
	现状与未来	
		语言架构	
		开源社区	
		发展前景	
	Rust代码如何执行	
	小结	
第2章  语言精要	
	Rust语言的基本构成	
		语言规范	
		编译器	
		核心库	
		标准库	
		包管理器	
	语句与表达式	
	变量与绑定	
		位置表达式和值表达式	
		不可变绑定与可变绑定	
		所有权与引用	
            引用的作用域 s 从创建开始，一直持续到它最后一次使用的地方，这个跟变量的作用域有所不同，变量的作用域从创建持续到某一个花括号 
	函数与闭包	
		函数定义	
		作用域与生命周期	
		函数指针	
		CTFE机制	
		闭包	
	流程控制	
		条件表达式	
		循环表达式	
		match表达式与模式匹配	
		if let和while let表达式	
	基本数据类型	
		布尔类型	
		基本数字类型	
		字符类型	
		数组类型	
		范围类型	
		切片类型	
		str字符串类型	
		原生指针	
		never类型	
	复合数据类型	
		元组	
		结构体	
		枚举体	
	常用集合类型	
		线性序列：向量	
		线性序列：双端队列	
		线性序列：链表	
		Key-Value映射表：HashMap和BTreeMap	
		集合：HashSet和BTreeSet	
		优先队列：BinaryHeap	
	智能指针	
	2.10  泛型和trait	
		2.1泛型	
		2.1trait	
	2.11  错误处理	
	2.12  表达式优先级	
	2.13  注释与打印	
	2.14  小结	
第3章  类型系统	
	通用概念	
		类型系统的作用	
		类型系统的分类	
		类型系统与多态性	
	Rust类型系统概述	
		类型大小	
		类型推导	
	泛型	
		泛型函数	
		泛型返回值自动推导	
	深入trait	
		接口抽象	
		泛型约束	
		抽象类型	
		标签trait	
	类型转换	
		Deref解引用	
		as操作符	
		From和Into	
	当前trait系统的不足	
		孤儿规则的局限性	
		代码复用的效率不高	
		抽象表达能力有待改进	
	小结	
第4章  内存管理	
	通用概念	
		栈	
		堆	
		内存布局	
	Rust中的资源管理	
		变量和函数	
		智能指针与RAII	
		内存泄漏与内存安全	
		复合类型的内存分配和布局	
	小结	
第5章  所有权系统	
	通用概念	
	所有权机制	
	绑定、作用域和生命周期	
		不可变与可变	
		绑定的时间属性——生命周期	
	所有权借用
        解引用操作会获得所有权
	生命周期参数	
		显式生命周期参数	
            生命周期的主要作用是避免悬垂引用
            Rust 使用了一个借用检查器(Borrow checker)，来检查我们程序的借用正确性：即借用者的周期比出借者的短
            生命周期标注并不会改变任何引用的实际作用域
            
		省略生命周期参数(生命周期消除)
            编译器为了简化用户的使用，不用写多余的生命周期标注，运用了生命周期消除大法
            三条消除规则
                1.每一个引用参数都会获得独自的生命周期
                2.若只有一个输入生命周期(函数参数中只有一个引用类型)，那么该生命周期会被赋给所有的输出生命周期
                3.若存在多个输入生命周期，且其中一个是 &self 或 &mut self，则 &self 的生命周期被赋给所有的输出生命周期
		生命周期限定	
		trait对象的生命周期
        静态生命周期
            生命周期 `'static` 意味着能和程序活得一样久
	智能指针与所有权
        智能指针拥有资源的所有权，而普通引用只是对所有权的借用
		共享所有权 Rc<T>和 Weak<T>
            Rc<T>是单线程引用计数指针，不是线程安全的类型，Rust 也不允许它被传递或共享给别的线程
		内部可变性 Cell<T>和 RefCell<T>	
            Cell<T>提供了get/set 方法
            只有实现了 Copy 的类型 T，才可以使用 get 方法获取包裹的值，因为 get 方法返回的是对内部值的复制
            RefCell<T>提供了 borrow/borrow_mut 方法
            RefCell<T>虽然没有分配空间，但它是有运行时开销的，因为它自己维护着一个运行时借用检查器
		写时复制 Cow<T>
            Cow<T>提供的功能是，以不可变的方式访问借用内容，以及在需要可变借用或所有权的时候再克隆一份数据
            Cow<T>旨在减少复制操作，提高性能，一般用于读多写少的场景
	并发安全与所有权	
	非词法作用域生命周期	
	小结	
第6章  函数、闭包与迭代器	
	函数	
		函数屏蔽	
		函数参数模式匹配	
		函数返回值	
		泛型函数	
		方法与函数	
		高阶函数	
	闭包	
		闭包的基本语法	
		闭包的实现	
		闭包与所有权	
		闭包作为函数参数和返回值	
		高阶生命周期	
	迭代器	
		外部迭代器和内部迭代器	
		Iterator trait	
		IntoIterator trait和迭代器	
		迭代器适配器	
		消费器	
		自定义迭代器适配器	
	小结	
第7章  结构化编程	
	面向对象风格编程	
		结构体	
		枚举体	
		析构顺序	
	常用设计模式	
		建造者模式	
		访问者模式	
		RAII模式	
	小结	
第8章  字符串与集合类型	
	字符串	
		字符编码	
		字符	
		字符串分类	
		字符串的两种处理方式	
		字符串的修改	
		字符串的查找	
		与其他类型相互转换	
		回顾	
	集合类型	
		动态可增长数组	
		映射集	
	理解容量	
	小结	
第9章  构建健壮的程序	
	通用概念	
	消除失败	
	分层处理错误	
		可选值Option&lt;T&gt;	
		错误处理Result&lt;T, E&gt;	
	恐慌（Panic）	
	第三方库	
	小结	
第10章  模块化编程	
	1包管理	
		1使用Cargo创建包	
		1使用第三方包	
		1Cargo.toml文件格式	
		1自定义Cargo	
	1模块系统	
	1从零开始实现一个完整功能包	
		1使用Cargo创建新项目	
		1使用structopt解析命令行参数	
		1定义统一的错误类型	
		1读取CSV文件	
		1替换CSV文件中的内容	
		1进一步完善包	
	1可见性和私有性	
	1小结	
第11章  安全并发	
	1通用概念	
		1多进程和多线程	
		1事件驱动、异步回调和协程	
		1线程安全	
	1多线程并发编程	
		1线程管理	
		1Send和Sync	
		1使用锁进行线程同步	
		1屏障和条件变量	
		1原子类型	
		1使用Channel进行线程间通信	
		1内部可变性探究	
		1线程池	
		1使用Rayon执行并行任务	
		11.2.10  使用Crossbeam	
	1异步并发	
		1生成器	
		1Future并发模式	
		1async/await	
	1数据并行	
		1什么是SIMD	
		1在Rust中使用SIMD	
	1小结	
第12章  元编程	
	1反射	
		1通过is函数判断类型	
		1转换到具体类型	
		1非静态生命周期类型	
	1宏系统	
		1起源	
		1Rust中宏的种类	
		1编译过程	
		1声明宏	
		1过程宏	
	1编译器插件	
	1小结	
第13章  超越安全的边界	
	1Unsafe Rust介绍	
		1Unsafe语法	
		1访问和修改可变静态变量	
		1Union联合体	
		1解引用原生指针	
	1基于Unsafe进行安全抽象	
		1原生指针	
		1子类型与型变	
		1未绑定生命周期	
		1Drop检查	
		1NonNull&lt;T&gt;指针	
		1Unsafe与恐慌安全	
		1堆内存分配	
		1混合代码内存安全架构三大原则	
	1和其他语言交互	
		1外部函数接口	
		1与C/C++语言交互	
		1使用Rust提升动态语言性能	
	1Rust与WebAssembly	
		1WebAssembly要点介绍	
		1使用Rust开发WebAssembly	
		1打造WebAssembly开发生态	
	1小结	
附录A  Rust开发环境指南	
附录B  Rust如何调试代码	
封底	
