位运算符的应用 (源操作数s 掩码mask) 
(1) 按位与 `&`
```
清零特定位 (mask中特定位置0，其它位为1，s=s&mask) 
取某数中指定位 (mask中特定位置1，其它位为0，s=s&mask) 
```
(2) 按位或 `|` 
```
常用来将源操作数某些位设置成1，其它位不变。 (mask中特定位置1，其它位为0 s=s|mask) 
```
(3) 位异或 `^` 
```   
1. 使特定位的值取反 (mask中特定位置1，其它位为0 s=s^mask) 
2. 不引入第三变量，交换两个变量的值 (设 a=a1,b=b1) 
  操 作 目 标 操作后状态 
  a=a^b a=a1^b1 a=a1^b1,b=b1 
  b=a^b b=a1^b1^b1 a=a1^b1,b=a1 
  a=a^b a=b1^a1^a1 a=b1,b=a1 
```


```
(1) 判断int型变量a是奇数还是偶数            
    a&1 = 0 偶数 
    a&1 = 1 奇数 
(2) 取int型变量a的第k位 (k=0,1,2……sizeof(int))，即a>>k&1 
(3) 将int型变量a的第k位清0，即a=a&~(1 << k) 
(4) 将int型变量a的第k位置1， 即a=a |(1 < <k) 
(7)整数的平均值 
    对于两个整数x,y，如果用 (x+y)/2 求平均值，会产生溢出，因为 x+y 可能会大于INT_MAX，但是我们知道它们的平均值是肯定不会溢出的，我们用如下算法： 
    int average(int x, int y) //返回X,Y 的平均值 
    {    
        return (x&y)+((x^y)>>1); 
    } 
    
    解释：把x和y里对应的每一位（指二进制位）都分成三类，每一类分别计算平均值，最后汇总。
    其中，一类是x,y对应位都是1，用x&y计算其平均值；
    一类是x,y中对应位有且只有一位是1，用(x^y)>>1计算其平均值；
    还有一另是x,y中对应位均为0，无须计算。    
    
(8)判断一个整数是不是2的幂,对于一个数 x >= 0，判断他是不是2的幂 
    boolean power2(int x) 
    { 
        return ((x&(x-1))==0)&&(x!=0)； 
    } 


(11)取模运算转化成位运算 (在不产生溢出的情况下) 
        a % (2^n) 等价于 a & (2^n - 1) 
(12)乘法运算转化成位运算 (在不产生溢出的情况下) 
        a * (2^n) 等价于 a < < n 
(13)除法运算转化成位运算 (在不产生溢出的情况下) 
        a / (2^n) 等价于 a>> n 
   
(14) a % 2 等价于 a & 1        
(15) if (x == a) x= b; 
　　 else x= a; 
　　等价于 x= a ^ b ^ x; 
(16) x 的 相反数 表示为 (~x+1) 
```


实例 


|功能 | 示例 | 位运算 
|  ----  | ----  | ---
|去掉最后一位 | (101101->10110) | x >> 1 
|在最后加一个0 | (101101->1011010) | x < < 1 
|在最后加一个1 | (101101->1011011) | x < < 1+1 
|把最后一位变成1 | (101100->101101) | x | 1 
|把最后一位变成0 | (101101->101100) | x | 1-1 
|最后一位取反 | (101101->101100) | x ^ 1 
|把右数第k位变成1 | (101001->101101,k=3) | x | (1 < < (k-1)) 
|把右数第k位变成0 | (101101->101001,k=3) | x & ~ (1 < < (k-1)) 
|右数第k位取反 | (101001->101101,k=3) | x ^ (1 < < (k-1)) 
|取末三位 | (1101101->101) | x & 7 
|取末k位 | (1101101->1101,k=5) | x & ((1 < < k)-1) 
|
|取右数第k位 | (1101101->1,k=4) | x >> (k-1) & 1 
|
|把末k位变成1 | (101001->101111,k=4) | x | (1 < < k-1) 
|末k位取反 | (101001->100110,k=4) | x ^ (1 < < k-1) 
|把右边连续的1变成0 | (100101111->100100000) | x & (x+1) 
|把右起第一个0变成1 | (100101111->100111111) | x | (x+1) 
|把右边连续的0变成1 | (11011000->11011111) | x | (x-1) 
|取右边连续的1 | (100101111->1111) | (x ^ (x+1)) >> 1 
|去掉右起第一个1的左边 | (100101000->1000) | x & (x ^ (x-1)) 
|判断奇数 (x&1)==1 
|判断偶数 (x&1)==0        


例如求从x位（高）到y位（低）间共有多少个1 
```
int FindChessNum(int x, int y, ushort k) 
{ 
    int re = 0; 
    for (int i = y; i <= x; i++) 
    { 
        re += ((k >> (i - 1)) & 1); 
    } 
    return re; 
} 
```