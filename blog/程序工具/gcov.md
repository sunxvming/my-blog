## 一、gcov简介
### gcov是什么

* gcov是一个测试代码覆盖率的工具。与GCC一起使用来分析程序，以帮助创建更高效、更快的运行代码，并发现程序的未测试部分
* 是一个命令行方式的控制台程序。需要结合`lcov`,`gcovr`等前端图形工具才能实现统计数据图形化
* 伴随GCC发布，不需要单独下载gcov工具。配合GCC共同实现对c/c++文件的语句覆盖和分支覆盖测试
* 与程序概要分析工具（`profiling tool`，例如`gprof`）一起工作，可以估计程序中哪段代码最耗时


### gcov能做什么
使用象gcov或gprof这样的分析器，您可以找到一些基本的性能统计数据：   
* 每一行代码执行的频率是多少   
* 实际执行了哪些行代码，配合测试用例达到满意的覆盖率和预期工作   
* 每段代码使用了多少计算时间，从而找到热点优化代码   
* gcov创建一个`sourcefile.gcov`的日志文件，此文件标识源文件`sourcefile.c`每一行执行的次数,您可以与`gprof`一起使用这些日志文件来帮助优化程序的性能。`gprof`提供了您可以使用的时间信息以及从gcov获得的信息。


## 二、gcov过程概况
![](index_files/1f4e51ca-1e99-4ace-a1db-829636d1dd44.png)
### 主要工作流
* 1) 编译前，在编译器中加入编译器参数`-fprofile-arcs -ftest-coverage`；
* 2) 源码经过编译预处理，然后编译成汇编文件，在生成汇编文件的同时完成插桩。插桩是在生成汇编文件的阶段完成的，因此插桩是汇编时候的插桩，每个桩点插入3~4条汇编语句，直接插入生成的*.s文件中，最后汇编文件汇编生成目标文件，生成可执行文件；并且生成关联BB和ARC的.gcno文件；
* 3) 执行可执行文件，在运行过程中之前插入桩点负责收集程序的执行信息。所谓桩点，其实就是一个变量，内存中的一个格子，对应的代码执行一次，则其值增加一次；
* 4) 生成.gcda文件，其中有BB和ARC的执行统计次数等，由此经过加工可得到覆盖率。




## 三、使用gcov
* 编译后生成 *.gcno。
* 运行程序后，可以看到数据文件*.gcda生成。
* 执行 gcov  *.cpp.gcno 就生成 *.cpp.gcov 测试结果。如果没有运行可执行程序，则运行时的覆盖率为0。
* 其中`.gcno` `.gcda`为二进制文件      `.gcov`为覆盖率的文本文件


左图是没有运行可执行文件的gcov文件，右图是运行了可执行文件的gcov文件
* 其中`#####`表示未运行的行 
* 每行前面的数字表示行运行的次数
![](index_files/9da05fe4-8822-4bc5-944a-4d33c649a53b.png)




## 四、gcov文件可视化
上述生成的`.gcov`文件可视化成都较低，需要借助`lcov`，`genhtml`工具直接生成html报告。
根据.gcno .gcda文件生成图形化报告
```
$ lcov -c -d . -o helloworld_gcov.info
$ genhtml -o result helloworld_gcov.info  (生成了result文件夹，借助web服务器，我们就可以很直观的看到结果了)
```
![](index_files/d6afc5b7-7a05-4c5e-8998-b96c8198b8be.png)



## 参考链接
- [gcov代码覆盖率测试-原理和实践总结](https://blog.csdn.net/yanxiangyfg/article/details/80989680)